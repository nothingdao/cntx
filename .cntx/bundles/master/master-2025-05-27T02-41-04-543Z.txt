<?xml version="1.0" encoding="UTF-8"?>
<bundle id="master-2025-05-27T02-41-04-543Z" created="2025-05-27T02:41:04.543Z" fileCount="78">
  
  <metadata>
    <projectName>project</projectName>
    <totalFiles>78</totalFiles>
    <bundleType>master</bundleType>
    <ignorePatterns>
      <pattern>node_modules</pattern>
      <pattern>.git</pattern>
      <pattern>dist</pattern>
      <pattern>build</pattern>
      <pattern>coverage</pattern>
      <pattern>.next</pattern>
      <pattern>.cache</pattern>
      <pattern>.netlify</pattern>
      <pattern>package-lock.json</pattern>
      <pattern>yarn.lock</pattern>
      <pattern>.DS_Store</pattern>
      <pattern>Thumbs.db</pattern>
      <pattern>*.mp3</pattern>
      <pattern>*.mp4</pattern>
      <pattern>*.wav</pattern>
      <pattern>*.ogg</pattern>
      <pattern>*.m4a</pattern>
      <pattern>*.flac</pattern>
      <pattern>*.jpg</pattern>
      <pattern>*.jpeg</pattern>
      <pattern>*.png</pattern>
      <pattern>*.gif</pattern>
      <pattern>*.webp</pattern>
      <pattern>*.svg</pattern>
      <pattern>*.ico</pattern>
      <pattern>*.pxd</pattern>
      <pattern>*.pdf</pattern>
      <pattern>*.doc</pattern>
      <pattern>*.docx</pattern>
      <pattern>*.zip</pattern>
      <pattern>*.tar</pattern>
      <pattern>*.gz</pattern>
      <pattern>*.rar</pattern>
      <pattern>example-project</pattern>
      <pattern>issues</pattern>
    </ignorePatterns>
  </metadata>

  <directoryTree>
  <directory name=".cursor" path=".cursor">
    <file name="rules" path=".cursor/rules" size="0" lastModified="2025-05-26T20:50:24.992Z">
      <tags>configuration,external-apis</tags>
    </file>
  </directory>
  <directory name="bin" path="bin">
    <file name="cntx.cjs" path="bin/cntx.cjs" size="0" lastModified="2025-05-22T03:34:42.887Z">
      <tags>cli-package,app-core</tags>
    </file>
  </directory>
  <directory name="src" path="src">
    <directory name="components" path="src/components">
      <directory name="theme" path="src/components/theme">
        <file name="mode-toggle.tsx" path="src/components/theme/mode-toggle.tsx" size="0" lastModified="2025-05-22T00:43:04.227Z">
          <tags>theming-styles,ui-components</tags>
        </file>
        <file name="theme-provider.tsx" path="src/components/theme/theme-provider.tsx" size="0" lastModified="2025-05-22T00:43:04.227Z">
          <tags>theming-styles,ui-components</tags>
        </file>
      </directory>
      <directory name="ui" path="src/components/ui">
        <file name="alert-dialog.tsx" path="src/components/ui/alert-dialog.tsx" size="0" lastModified="2025-05-22T00:43:04.227Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="alert.tsx" path="src/components/ui/alert.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="avatar.tsx" path="src/components/ui/avatar.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="badge.tsx" path="src/components/ui/badge.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="button.tsx" path="src/components/ui/button.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="card.tsx" path="src/components/ui/card.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="checkbox.tsx" path="src/components/ui/checkbox.tsx" size="0" lastModified="2025-05-22T00:43:04.228Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="dialog.tsx" path="src/components/ui/dialog.tsx" size="0" lastModified="2025-05-22T00:43:04.229Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="dropdown-menu.tsx" path="src/components/ui/dropdown-menu.tsx" size="0" lastModified="2025-05-22T00:43:04.229Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="input.tsx" path="src/components/ui/input.tsx" size="0" lastModified="2025-05-22T00:43:04.229Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="label.tsx" path="src/components/ui/label.tsx" size="0" lastModified="2025-05-23T18:23:43.006Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="popover.tsx" path="src/components/ui/popover.tsx" size="0" lastModified="2025-05-22T00:43:04.229Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="progress.tsx" path="src/components/ui/progress.tsx" size="0" lastModified="2025-05-22T00:43:04.229Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="scroll-area.tsx" path="src/components/ui/scroll-area.tsx" size="0" lastModified="2025-05-22T00:43:04.230Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="select.tsx" path="src/components/ui/select.tsx" size="0" lastModified="2025-05-22T00:43:04.230Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="separator.tsx" path="src/components/ui/separator.tsx" size="0" lastModified="2025-05-23T22:47:54.986Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="switch.tsx" path="src/components/ui/switch.tsx" size="0" lastModified="2025-05-23T18:22:51.626Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="table.tsx" path="src/components/ui/table.tsx" size="0" lastModified="2025-05-22T00:43:04.230Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="tabs.tsx" path="src/components/ui/tabs.tsx" size="0" lastModified="2025-05-22T00:43:04.230Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="textarea.tsx" path="src/components/ui/textarea.tsx" size="0" lastModified="2025-05-23T22:47:27.005Z">
          <tags>ui-primitives</tags>
        </file>
        <file name="tooltip.tsx" path="src/components/ui/tooltip.tsx" size="0" lastModified="2025-05-22T00:43:04.230Z">
          <tags>ui-primitives</tags>
        </file>
      </directory>
      <file name="ApplicationContainer.tsx" path="src/components/ApplicationContainer.tsx" size="0" lastModified="2025-05-27T02:36:49.585Z">
        <tags>ui-components,app-core</tags>
      </file>
      <file name="BatchTagButton.tsx" path="src/components/BatchTagButton.tsx" size="0" lastModified="2025-05-23T20:54:02.995Z">
        <tags>ui-components,business-logic</tags>
      </file>
      <file name="BundleAnalysisBadge.tsx" path="src/components/BundleAnalysisBadge.tsx" size="0" lastModified="2025-05-27T00:51:18.714Z">
        <tags>ui-components,business-logic</tags>
      </file>
      <file name="BundleMainViewer.tsx" path="src/components/BundleMainViewer.tsx" size="0" lastModified="2025-05-27T01:14:16.369Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="BundleView.tsx" path="src/components/BundleView.tsx" size="0" lastModified="2025-05-27T01:52:28.567Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="ConfigPanel.tsx" path="src/components/ConfigPanel.tsx" size="0" lastModified="2025-05-26T20:46:58.098Z">
        <tags>ui-components,configuration</tags>
      </file>
      <file name="CursorRulesPanel.tsx" path="src/components/CursorRulesPanel.tsx" size="0" lastModified="2025-05-26T20:46:09.564Z">
        <tags>ui-components,external-apis</tags>
      </file>
      <file name="Dashboard.tsx" path="src/components/Dashboard.tsx" size="0" lastModified="2025-05-27T00:42:48.858Z">
        <tags>ui-components,business-logic</tags>
      </file>
      <file name="DirectoryPanel.tsx" path="src/components/DirectoryPanel.tsx" size="0" lastModified="2025-05-24T20:26:27.809Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="DirectoryTree.tsx" path="src/components/DirectoryTree.tsx" size="0" lastModified="2025-05-24T02:36:43.535Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="FileTagsDisplay.tsx" path="src/components/FileTagsDisplay.tsx" size="0" lastModified="2025-05-26T22:06:10.781Z">
        <tags>ui-components,business-logic</tags>
      </file>
      <file name="InitializationModal.tsx" path="src/components/InitializationModal.tsx" size="0" lastModified="2025-05-26T20:48:53.009Z">
        <tags>ui-components,configuration</tags>
      </file>
      <file name="MainContainer.tsx" path="src/components/MainContainer.tsx" size="0" lastModified="2025-05-24T19:56:48.720Z">
        <tags>ui-components,app-core</tags>
      </file>
      <file name="MasterBundleButton.tsx" path="src/components/MasterBundleButton.tsx" size="0" lastModified="2025-05-22T00:43:04.226Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="TagBundleCreator.tsx" path="src/components/TagBundleCreator.tsx" size="0" lastModified="2025-05-24T03:33:41.692Z">
        <tags>ui-components,file-operations</tags>
      </file>
      <file name="TagsMainViewer.tsx" path="src/components/TagsMainViewer.tsx" size="0" lastModified="2025-05-27T01:34:02.830Z">
        <tags>ui-components,business-logic</tags>
      </file>
    </directory>
    <directory name="constants" path="src/constants">
      <file name="index.ts" path="src/constants/index.ts" size="0" lastModified="2025-05-22T01:02:49.262Z">
        <tags>configuration,business-logic</tags>
      </file>
    </directory>
    <directory name="contexts" path="src/contexts">
      <file name="BundleContext.tsx" path="src/contexts/BundleContext.tsx" size="0" lastModified="2025-05-27T01:30:25.308Z">
        <tags>state-context,file-operations</tags>
      </file>
      <file name="CntxProvider.tsx" path="src/contexts/CntxProvider.tsx" size="0" lastModified="2025-05-26T20:15:22.286Z">
        <tags>state-context,app-core</tags>
      </file>
      <file name="CursorRulesContext.tsx" path="src/contexts/CursorRulesContext.tsx" size="0" lastModified="2025-05-26T20:45:30.198Z">
        <tags>state-context,external-apis</tags>
      </file>
      <file name="DirectoryContext.tsx" path="src/contexts/DirectoryContext.tsx" size="0" lastModified="2025-05-22T05:01:23.326Z">
        <tags>state-context,file-operations</tags>
      </file>
      <file name="FileContext.tsx" path="src/contexts/FileContext.tsx" size="0" lastModified="2025-05-23T22:36:54.817Z">
        <tags>state-context,file-operations</tags>
      </file>
      <file name="ProjectConfigContext.tsx" path="src/contexts/ProjectConfigContext.tsx" size="0" lastModified="2025-05-23T22:42:10.887Z">
        <tags>state-context,configuration</tags>
      </file>
      <file name="TagContext.tsx" path="src/contexts/TagContext.tsx" size="0" lastModified="2025-05-23T20:54:30.123Z">
        <tags>state-context,business-logic</tags>
      </file>
      <file name="types.ts" path="src/contexts/types.ts" size="0" lastModified="2025-05-23T22:44:49.097Z">
        <tags>types-definitions,state-context</tags>
      </file>
    </directory>
    <directory name="lib" path="src/lib">
      <file name="utils.ts" path="src/lib/utils.ts" size="0" lastModified="2025-05-22T00:43:04.232Z">
        <tags>business-logic</tags>
      </file>
    </directory>
    <directory name="types" path="src/types">
      <file name="types.ts" path="src/types/types.ts" size="0" lastModified="2025-05-24T03:09:39.942Z">
        <tags>types-definitions</tags>
      </file>
    </directory>
    <directory name="utils" path="src/utils">
      <file name="bundle-utils.ts" path="src/utils/bundle-utils.ts" size="0" lastModified="2025-05-22T00:43:04.234Z">
        <tags>business-logic,file-operations</tags>
      </file>
      <file name="cursor-rules.ts" path="src/utils/cursor-rules.ts" size="0" lastModified="2025-05-26T20:42:29.289Z">
        <tags>business-logic,external-apis</tags>
      </file>
      <file name="directory-tree.ts" path="src/utils/directory-tree.ts" size="0" lastModified="2025-05-22T00:43:04.234Z">
        <tags>business-logic,ui-components</tags>
      </file>
      <file name="file-state.ts" path="src/utils/file-state.ts" size="0" lastModified="2025-05-27T01:22:50.035Z">
        <tags>business-logic,file-operations</tags>
      </file>
      <file name="file-utils.ts" path="src/utils/file-utils.ts" size="0" lastModified="2025-05-24T03:55:53.587Z">
        <tags>business-logic,file-operations</tags>
      </file>
      <file name="project-utils.ts" path="src/utils/project-utils.ts" size="0" lastModified="2025-05-27T01:25:17.353Z">
        <tags>business-logic,file-operations</tags>
      </file>
    </directory>
    <file name="App.tsx" path="src/App.tsx" size="0" lastModified="2025-05-23T18:26:41.778Z">
      <tags>app-core,ui-components</tags>
    </file>
    <file name="index.css" path="src/index.css" size="0" lastModified="2025-05-22T00:43:04.232Z">
      <tags>theming-styles</tags>
    </file>
    <file name="main.tsx" path="src/main.tsx" size="0" lastModified="2025-05-22T00:43:04.233Z">
      <tags>app-core</tags>
    </file>
    <file name="vite-env.d.ts" path="src/vite-env.d.ts" size="0" lastModified="2025-05-22T00:43:04.235Z">
      <tags>types-definitions,configuration</tags>
    </file>
  </directory>
  <file name=".gitignore" path=".gitignore" size="0" lastModified="2025-05-26T20:53:40.040Z">
    <tags>configuration</tags>
  </file>
  <file name=".npmignore" path=".npmignore" size="0" lastModified="2025-05-22T02:29:16.100Z">
    <tags>configuration,cli-package</tags>
  </file>
  <file name="components.json" path="components.json" size="0" lastModified="2025-05-22T00:43:04.221Z">
    <tags>configuration,ui-primitives</tags>
  </file>
  <file name="DEVELOPMENT.md" path="DEVELOPMENT.md" size="0" lastModified="2025-05-24T20:29:51.011Z">
    <tags>documentation</tags>
  </file>
  <file name="eslint.config.js" path="eslint.config.js" size="0" lastModified="2025-05-22T00:43:04.221Z">
    <tags>configuration</tags>
  </file>
  <file name="index.html" path="index.html" size="0" lastModified="2025-05-22T00:43:06.221Z">
    <tags>app-core</tags>
  </file>
  <file name="package.json" path="package.json" size="0" lastModified="2025-05-24T20:54:59.589Z">
    <tags>configuration,cli-package</tags>
  </file>
  <file name="postcss.config.cjs" path="postcss.config.cjs" size="0" lastModified="2025-05-22T02:39:25.675Z">
    <tags>configuration,theming-styles</tags>
  </file>
  <file name="README.md" path="README.md" size="0" lastModified="2025-05-26T20:52:15.437Z">
    <tags>documentation</tags>
  </file>
  <file name="tailwind.config.js" path="tailwind.config.js" size="0" lastModified="2025-05-22T00:43:04.235Z">
    <tags>configuration,theming-styles</tags>
  </file>
  <file name="tsconfig.app.json" path="tsconfig.app.json" size="0" lastModified="2025-05-22T00:43:04.235Z">
    <tags>configuration</tags>
  </file>
  <file name="tsconfig.app.tsbuildinfo" path="tsconfig.app.tsbuildinfo" size="0" lastModified="2025-05-22T02:29:37.045Z">
    <tags>configuration</tags>
  </file>
  <file name="tsconfig.json" path="tsconfig.json" size="0" lastModified="2025-05-22T00:43:04.235Z">
    <tags>configuration</tags>
  </file>
  <file name="tsconfig.node.json" path="tsconfig.node.json" size="0" lastModified="2025-05-22T00:43:04.235Z">
    <tags>configuration</tags>
  </file>
  <file name="tsconfig.node.tsbuildinfo" path="tsconfig.node.tsbuildinfo" size="0" lastModified="2025-05-22T02:29:37.202Z">
    <tags>configuration</tags>
  </file>
  <file name="vite.config.ts" path="vite.config.ts" size="0" lastModified="2025-05-22T00:43:04.235Z">
    <tags>configuration</tags>
  </file>
</directoryTree>

  <asciiTree>
project/
├── .cursor/
│   └── rules [configuration,external-apis]
├── bin/
│   └── cntx.cjs [cli-package,app-core]
├── src/
│   ├── components/
│   │   ├── theme/
│   │   │   ├── mode-toggle.tsx [theming-styles,ui-components]
│   │   │   └── theme-provider.tsx [theming-styles,ui-components]
│   │   ├── ui/
│   │   │   ├── alert-dialog.tsx [ui-primitives]
│   │   │   ├── alert.tsx [ui-primitives]
│   │   │   ├── avatar.tsx [ui-primitives]
│   │   │   ├── badge.tsx [ui-primitives]
│   │   │   ├── button.tsx [ui-primitives]
│   │   │   ├── card.tsx [ui-primitives]
│   │   │   ├── checkbox.tsx [ui-primitives]
│   │   │   ├── dialog.tsx [ui-primitives]
│   │   │   ├── dropdown-menu.tsx [ui-primitives]
│   │   │   ├── input.tsx [ui-primitives]
│   │   │   ├── label.tsx [ui-primitives]
│   │   │   ├── popover.tsx [ui-primitives]
│   │   │   ├── progress.tsx [ui-primitives]
│   │   │   ├── scroll-area.tsx [ui-primitives]
│   │   │   ├── select.tsx [ui-primitives]
│   │   │   ├── separator.tsx [ui-primitives]
│   │   │   ├── switch.tsx [ui-primitives]
│   │   │   ├── table.tsx [ui-primitives]
│   │   │   ├── tabs.tsx [ui-primitives]
│   │   │   ├── textarea.tsx [ui-primitives]
│   │   │   └── tooltip.tsx [ui-primitives]
│   │   ├── ApplicationContainer.tsx [ui-components,app-core]
│   │   ├── BatchTagButton.tsx [ui-components,business-logic]
│   │   ├── BundleAnalysisBadge.tsx [ui-components,business-logic]
│   │   ├── BundleMainViewer.tsx [ui-components,file-operations]
│   │   ├── BundleView.tsx [ui-components,file-operations]
│   │   ├── ConfigPanel.tsx [ui-components,configuration]
│   │   ├── CursorRulesPanel.tsx [ui-components,external-apis]
│   │   ├── Dashboard.tsx [ui-components,business-logic]
│   │   ├── DirectoryPanel.tsx [ui-components,file-operations]
│   │   ├── DirectoryTree.tsx [ui-components,file-operations]
│   │   ├── FileTagsDisplay.tsx [ui-components,business-logic]
│   │   ├── InitializationModal.tsx [ui-components,configuration]
│   │   ├── MainContainer.tsx [ui-components,app-core]
│   │   ├── MasterBundleButton.tsx [ui-components,file-operations]
│   │   ├── TagBundleCreator.tsx [ui-components,file-operations]
│   │   └── TagsMainViewer.tsx [ui-components,business-logic]
│   ├── constants/
│   │   └── index.ts [configuration,business-logic]
│   ├── contexts/
│   │   ├── BundleContext.tsx [state-context,file-operations]
│   │   ├── CntxProvider.tsx [state-context,app-core]
│   │   ├── CursorRulesContext.tsx [state-context,external-apis]
│   │   ├── DirectoryContext.tsx [state-context,file-operations]
│   │   ├── FileContext.tsx [state-context,file-operations]
│   │   ├── ProjectConfigContext.tsx [state-context,configuration]
│   │   ├── TagContext.tsx [state-context,business-logic]
│   │   └── types.ts [types-definitions,state-context]
│   ├── lib/
│   │   └── utils.ts [business-logic]
│   ├── types/
│   │   └── types.ts [types-definitions]
│   ├── utils/
│   │   ├── bundle-utils.ts [business-logic,file-operations]
│   │   ├── cursor-rules.ts [business-logic,external-apis]
│   │   ├── directory-tree.ts [business-logic,ui-components]
│   │   ├── file-state.ts [business-logic,file-operations]
│   │   ├── file-utils.ts [business-logic,file-operations]
│   │   └── project-utils.ts [business-logic,file-operations]
│   ├── App.tsx [app-core,ui-components]
│   ├── index.css [theming-styles]
│   ├── main.tsx [app-core]
│   └── vite-env.d.ts [types-definitions,configuration]
├── .gitignore [configuration]
├── .npmignore [configuration,cli-package]
├── components.json [configuration,ui-primitives]
├── DEVELOPMENT.md [documentation]
├── eslint.config.js [configuration]
├── index.html [app-core]
├── package.json [configuration,cli-package]
├── postcss.config.cjs [configuration,theming-styles]
├── README.md [documentation]
├── tailwind.config.js [configuration,theming-styles]
├── tsconfig.app.json [configuration]
├── tsconfig.app.tsbuildinfo [configuration]
├── tsconfig.json [configuration]
├── tsconfig.node.json [configuration]
├── tsconfig.node.tsbuildinfo [configuration]
└── vite.config.ts [configuration]

78 files, 11 directories
  </asciiTree>

  <documents>
    
    <document>
      <source>.cursor/rules</source>
      <tags>configuration,external-apis</tags>
      <metadata>
        <size>8980</size>
        <lastModified>2025-05-26T20:50:24.992Z</lastModified>
        <extension>cursor/rules</extension>
        <directory>.cursor</directory>
      </metadata>
      <content># Cntx-UI Rules

## Project Overview

This is a React + TypeScript application that helps developers organize, tag, and bundle codebase files for AI tools. It uses the File System Access API to work directly with local files without uploads.

## Core Technologies &amp; Patterns

### Tech Stack

- React 18 with TypeScript (strict mode)
- Vite for build tooling
- Tailwind CSS + shadcn/ui components
- File System Access API for file operations
- React Context for state management
- Express.js server for NPX package delivery

### Architecture Principles

- Context-based state management (no Redux/Zustand for global state)
- Functional components with hooks only
- Custom hooks for reusable logic
- Proper TypeScript types and interfaces
- File System Access API integration patterns

## Code Style &amp; Standards

### TypeScript

- Always use strict TypeScript - no `any` types
- Define proper interfaces for all data structures
- Use explicit return types for public functions
- Handle File System Access API errors with proper try/catch
- Use type guards for browser API availability

### React Patterns

- Functional components with hooks only (no class components)
- Use React.memo() for performance optimization when needed
- Custom hooks should start with `use` and follow React hooks rules
- Proper dependency arrays in useEffect/useCallback/useMemo
- Context providers should handle loading and error states

### File Organization

- Components in PascalCase: `DirectoryTree.tsx`
- Utilities in kebab-case: `file-utils.ts`
- Contexts end with `Context.tsx`
- Types in `types.ts` files
- Constants in `constants/index.ts`

### Naming Conventions

- Component props interfaces: `ComponentNameProps`
- Context types: `ComponentNameContextType`
- Utility functions: descriptive camelCase
- File paths: use forward slashes and normalize paths
- Bundle IDs: `bundle-timestamp-random` or `master-timestamp`

## File System Access API Guidelines

### Security &amp; Permissions

- Always check for File System Access API support
- Handle permission denial gracefully
- Use try/catch for all file operations
- Never assume file/directory exists - always check

### File Operations Patterns

```typescript
// Always wrap in try/catch
try {
  const dirHandle = await window.showDirectoryPicker({ mode: &#39;readwrite&#39; })
  // Operations...
} catch (error) {
  if (error.name === &#39;AbortError&#39;) {
    // User cancelled
  } else {
    // Handle other errors
  }
}

// Check file existence before operations
try {
  await dirHandle.getFileHandle(&#39;filename&#39;)
} catch (error) {
  if (error.name === &#39;NotFoundError&#39;) {
    // File doesn&#39;t exist
  }
}
```

### Performance Considerations

- Use async generators for large directory processing
- Implement ignore patterns to skip unnecessary files
- Cache file handles when possible
- Use AbortController for cancellable operations

## State Management Patterns

### Context Architecture

- Each major feature has its own context (Directory, File, Bundle, Tag)
- Contexts handle their own loading/error states
- Use context composition in `CntxProvider.tsx`
- Avoid prop drilling - use context for shared state

### State Updates

- Always preserve existing data when updating state
- Use functional updates for complex state changes
- Handle race conditions in async operations
- Implement optimistic updates where appropriate

### Tag System

- Tags are stored in `.cntx/state/file.json`
- Never filter out files with tags during state operations
- Always preserve existing tags when updating file state
- Use proper tag color validation (hex colors)

## Bundle System

### Bundle Creation

- Use XML format with proper escaping
- Include file content, metadata, and tags
- Generate unique bundle IDs with timestamps
- Save both bundle file and manifest
- Master bundles go in `bundles/master/` subdirectory

### Bundle Analysis

- Calculate staleness based on file modification times
- Track which files have changed since bundle creation
- Provide meaningful progress feedback during creation
- Handle large bundles efficiently

## UI/UX Guidelines

### Component Design

- Use shadcn/ui components as base
- Implement proper loading states for async operations
- Show progress for long-running operations
- Provide clear error messages and recovery options
- Use tooltips for complex features

### Accessibility

- Proper ARIA labels for interactive elements
- Keyboard navigation support
- Screen reader friendly file trees
- Color contrast compliance
- Focus management in modals/dialogs

### Performance

- Virtualize large file lists when needed
- Implement proper memo patterns
- Use React.Suspense for code splitting
- Optimize re-renders with proper dependencies

## Error Handling

### File System Errors

- Handle NotFoundError (file/directory doesn&#39;t exist)
- Handle NotAllowedError (permission denied)
- Handle AbortError (user cancelled operation)
- Handle QuotaExceededError (storage limits)

### User Experience

- Show specific error messages, not generic &quot;Something went wrong&quot;
- Provide actionable recovery steps
- Log errors for debugging but don&#39;t expose internals to users
- Use toast notifications for operation feedback

## Testing Considerations

### Browser Compatibility

- File System Access API only works in Chromium browsers
- Gracefully degrade functionality in unsupported browsers
- Test in Chrome, Edge, and Opera
- Provide clear browser compatibility messaging

### Development Testing

- Test with various project structures
- Test ignore patterns thoroughly
- Test tag persistence across app restarts
- Test bundle creation with large files
- Test error scenarios (permissions, disk space, etc.)

## NPX Package Guidelines

### Server Implementation

- Express server serves built React app
- Proper CORS headers for File System Access API
- Graceful shutdown handling
- Port conflict detection and messaging
- ASCII art banner and helpful startup messages

### Package Distribution

- Include only necessary files in NPM package
- Proper binary configuration in package.json
- Clear installation and usage instructions
- Version management and changelog

## AI Integration Features

### Cursor Rules Integration

- Import existing `.cursorrules` files
- Merge with cntx semantic organization
- Export unified AI context
- Store in `.cntx/config/ai-instructions.json`

### Bundle Format for AI

- XML structure optimized for AI consumption
- Include directory tree visualization
- Preserve file relationships and context
- Tag-based organization for semantic understanding

## Security Best Practices

### File Access

- Validate file paths and prevent directory traversal
- Sanitize file content before processing
- Limit file sizes for bundle operations
- Respect user&#39;s ignore patterns

### Data Storage

- Store configuration in project `.cntx` directory
- Never store sensitive information
- Use proper JSON validation for config files
- Handle corrupted state files gracefully

## Development Workflow

### Code Organization

- Keep components focused and single-purpose
- Extract complex logic into custom hooks
- Use proper TypeScript generics for reusable code
- Document complex algorithms and business logic

### Debugging

- Use descriptive console.log messages with emoji prefixes
- Implement proper error boundaries
- Use React DevTools for component debugging
- Monitor File System API calls in browser DevTools

### Git Integration

- Commit `.cntx` directory for team AI context sharing
- Proper gitignore for development files
- Meaningful commit messages following conventional commits
- Feature branch workflow for new functionality

## Common Patterns to Follow

### Context Updates

```typescript
// Always preserve existing state
const updateState = useCallback((updates: Partial&lt;State&gt;) =&gt; {
  setState((current) =&gt; ({ ...current, ...updates }))
}, [])
```

### File Processing

```typescript
// Handle ignore patterns properly
const shouldIgnore = (path: string) =&gt; {
  return ignorePatterns.some((pattern) =&gt; {
    if (pattern.startsWith(&#39;*.&#39;)) {
      return path.endsWith(pattern.slice(1))
    }
    return path.includes(pattern)
  })
}
```

### Error Boundaries

```typescript
// Provide meaningful error context
catch (error) {
  console.error(`Failed to ${operation}:`, error);
  setError(`Unable to ${operation}. ${getHelpfulMessage(error)}`);
}
```

## When Making Changes

1. **File System Operations**: Always test with different file structures and edge cases
2. **State Updates**: Ensure tag preservation and data consistency
3. **UI Changes**: Test with various screen sizes and accessibility tools
4. **Bundle Creation**: Verify XML format and proper escaping
5. **Context Changes**: Check for proper provider composition and cleanup
6. **Error Handling**: Test error scenarios and recovery paths

Remember: This app helps developers create better AI context, so the code itself should be exemplary and well-documented for AI tools to understand and work with effectively.
</content>
    </document>

    <document>
      <source>bin/cntx.cjs</source>
      <tags>cli-package,app-core</tags>
      <metadata>
        <size>2896</size>
        <lastModified>2025-05-22T03:34:42.887Z</lastModified>
        <extension>cjs</extension>
        <directory>bin</directory>
      </metadata>
      <content>#!/usr/bin/env node

const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);
const open = require(&#39;open&#39;);
const fs = require(&#39;fs&#39;);

const app = express();
const port = 3000;

// ASCII art banner
const banner = `
┌─────────────────────────────────────────┐
│                                         │
│   ██████╗███╗   ██╗████████╗██╗  ██╗    │
│  ██╔════╝████╗  ██║╚══██╔══╝╚██╗██╔╝    │
│  ██║     ██╔██╗ ██║   ██║    ╚███╔╝     │
│  ██║     ██║╚██╗██║   ██║    ██╔██╗     │
│  ╚██████╗██║ ╚████║   ██║   ██╔╝ ██╗    │
│   ╚═════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝    │
│                                         │
│    File bundling &amp; tagging for AI      │
│                                         │
└─────────────────────────────────────────┘
`;

console.log(banner);
console.log(&#39;🚀 Starting Cntx...\n&#39;);

// Check if dist directory exists
const distPath = path.join(__dirname, &#39;../dist&#39;);
if (!fs.existsSync(distPath)) {
  console.error(&#39;❌ Error: Build files not found.&#39;);
  console.log(&#39;This usually means the package was not built properly.&#39;);
  console.log(&#39;If you\&#39;re developing locally, run: npm run build&#39;);
  process.exit(1);
}

// Serve the built React app with proper headers for File System Access API
app.use((req, res, next) =&gt; {
  // Set headers needed for File System Access API
  res.setHeader(&#39;Cross-Origin-Embedder-Policy&#39;, &#39;require-corp&#39;);
  res.setHeader(&#39;Cross-Origin-Opener-Policy&#39;, &#39;same-origin&#39;);
  next();
});

app.use(express.static(distPath));

// Handle React Router routes
app.get(&#39;*&#39;, (req, res) =&gt; {
  res.sendFile(path.join(distPath, &#39;index.html&#39;));
});

// Handle server shutdown gracefully
process.on(&#39;SIGINT&#39;, () =&gt; {
  console.log(&#39;\n👋 Shutting down Cntx...&#39;);
  process.exit(0);
});

process.on(&#39;SIGTERM&#39;, () =&gt; {
  console.log(&#39;\n👋 Shutting down Cntx...&#39;);
  process.exit(0);
});

const server = app.listen(port, () =&gt; {
  console.log(`🌐 Server running at http://localhost:${port}`);
  console.log(&#39;📁 Select a directory to get started!&#39;);
  console.log(&#39;\n💡 Tips:&#39;);
  console.log(&#39;   • Use Chromium-based browsers (Chrome, Edge, Opera)&#39;);
  console.log(&#39;   • File System Access API required for full functionality&#39;);
  console.log(&#39;   • Press Ctrl+C to stop the server\n&#39;);

  // Open browser
  console.log(&#39;🔗 Opening browser...&#39;);
  open(`http://localhost:${port}`).catch(() =&gt; {
    console.log(&#39;Could not open browser automatically.&#39;);
    console.log(`Please visit: http://localhost:${port}`);
  });
});

// Handle port already in use
server.on(&#39;error&#39;, (err) =&gt; {
  if (err.code === &#39;EADDRINUSE&#39;) {
    console.error(`❌ Port ${port} is already in use.`);
    console.log(&#39;Either:&#39;);
    console.log(`  • Stop the process using port ${port}`);
    console.log(`  • Visit http://localhost:${port} if Cntx is already running`);
    process.exit(1);
  } else {
    console.error(&#39;❌ Server error:&#39;, err.message);
    process.exit(1);
  }
});
</content>
    </document>

    <document>
      <source>src/types/types.ts</source>
      <tags>types-definitions</tags>
      <metadata>
        <size>6434</size>
        <lastModified>2025-05-24T03:09:39.942Z</lastModified>
        <extension>ts</extension>
        <directory>src/types</directory>
      </metadata>
      <content>// src/types.ts

/*
███████╗██╗██╗     ███████╗    ███████╗██╗   ██╗███████╗████████╗███████╗███╗   ███╗
██╔════╝██║██║     ██╔════╝    ██╔════╝╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔════╝████╗ ████║
█████╗  ██║██║     █████╗      ███████╗ ╚████╔╝ ███████╗   ██║   █████╗  ██╔████╔██║
██╔══╝  ██║██║     ██╔══╝      ╚════██║  ╚██╔╝  ╚════██║   ██║   ██╔══╝  ██║╚██╔╝██║
██║     ██║███████╗███████╗    ███████║   ██║   ███████║   ██║   ███████╗██║ ╚═╝ ██║
╚═╝     ╚═╝╚══════╝╚══════╝    ╚══════╝   ╚═╝   ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝
*/

interface FileSystemHandle {
  kind: &#39;file&#39; | &#39;directory&#39;
  name: string
  getFile(): Promise&lt;File&gt;
}

export interface FileSystemWritableFileStream extends WritableStream {
  write(data: string | BufferSource | Blob): Promise&lt;void&gt;
  seek(position: number): Promise&lt;void&gt;
  truncate(size: number): Promise&lt;void&gt;
}

export interface FileSystemFileHandle extends FileSystemHandle {
  kind: &#39;file&#39;
  getFile(): Promise&lt;File&gt;
  createWritable(options?: {
    keepExistingData?: boolean
  }): Promise&lt;FileSystemWritableFileStream&gt;
  isSameEntry(other: FileSystemHandle): Promise&lt;boolean&gt;
  entries(): AsyncIterableIterator&lt;[string, FileSystemHandle]&gt;
  keys(): AsyncIterableIterator&lt;string&gt;
  values(): AsyncIterableIterator&lt;FileSystemHandle&gt;
}

export interface FileSystemDirectoryHandle extends FileSystemHandle {
  kind: &#39;directory&#39;
  getDirectoryHandle(
    name: string,
    options?: { create?: boolean }
  ): Promise&lt;FileSystemDirectoryHandle&gt;
  getFileHandle(
    name: string,
    options?: { create?: boolean }
  ): Promise&lt;FileSystemFileHandle&gt;
  removeEntry(name: string, options?: { recursive?: boolean }): Promise&lt;void&gt;
  resolve(possibleDescendant: FileSystemHandle): Promise&lt;string[] | null&gt;
  [Symbol.asyncIterator](): AsyncIterableIterator&lt;FileSystemHandle&gt;
  isSameEntry(other: FileSystemHandle): Promise&lt;boolean&gt;
  entries(): AsyncIterableIterator&lt;[string, FileSystemHandle]&gt;
  keys(): AsyncIterableIterator&lt;string&gt;
  values(): AsyncIterableIterator&lt;FileSystemHandle&gt;
}

declare global {
  interface Window {
    showDirectoryPicker(options?: {
      mode?: &#39;read&#39; | &#39;readwrite&#39;
    }): Promise&lt;FileSystemDirectoryHandle&gt;
  }
}

declare global {
  type NativeFileSystemHandle = FileSystemHandle
  type NativeFileSystemFileHandle = FileSystemFileHandle
  type NativeFileSystemDirectoryHandle = FileSystemDirectoryHandle
}

/*
██████╗ ██╗   ██╗███╗   ██╗██████╗ ██╗     ███████╗███████╗
██╔══██╗██║   ██║████╗  ██║██╔══██╗██║     ██╔════╝██╔════╝
██████╔╝██║   ██║██╔██╗ ██║██║  ██║██║     █████╗  ███████╗
██╔══██╗██║   ██║██║╚██╗██║██║  ██║██║     ██╔══╝  ╚════██║
██████╔╝╚██████╔╝██║ ╚████║██████╔╝███████╗███████╗███████║
╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚══════╝╚══════╝╚══════╝
*/

export type BundleType = &#39;master&#39; | &#39;tag-derived&#39; | &#39;custom&#39;
export interface BundleManifest {
  id: string
  created: string
  fileCount: number

  // NEW: Bundle type metadata
  type: BundleType
  derivedFromTag?: string
  description?: string

  files: {
    path: string
    lastModified: string
    tags?: string[]
  }[]

  // Optional tag bundle specific metadata
  tagBundleMetadata?: {
    tagName: string
    autoGenerated: boolean
    createdFrom: string
    filesMatchingTag: number
  }
}

export interface Bundle {
  name: string
  timestamp: Date
  fileCount: number
  tagCount?: number

  // NEW: Explicit bundle type and metadata
  type: BundleType
  derivedFromTag?: string // For tag-derived bundles
  description?: string
  id: string
}

export interface FileState {
  masterBundleId?: string
  lastModified: string
  isStaged: boolean
}

/*
████████╗ █████╗  ██████╗ ███████╗
╚══██╔══╝██╔══██╗██╔════╝ ██╔════╝
   ██║   ███████║██║  ███╗███████╗
   ██║   ██╔══██║██║   ██║╚════██║
   ██║   ██║  ██║╚██████╔╝███████║
   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝
*/

export type TagsConfig = {
  [tagName: string]: {
    color?: string
    description?: string
  }
}

/*
██╗    ██╗ █████╗ ████████╗ ██████╗██╗  ██╗███████╗██████╗ 
██║    ██║██╔══██╗╚══██╔══╝██╔════╝██║  ██║██╔════╝██╔══██╗
██║ █╗ ██║███████║   ██║   ██║     ███████║█████╗  ██████╔╝
██║███╗██║██╔══██║   ██║   ██║     ██╔══██║██╔══╝  ██╔══██╗
╚███╔███╔╝██║  ██║   ██║   ╚██████╗██║  ██║███████╗██║  ██║
 ╚══╝╚══╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
*/
//
export interface WatchedFile {
  path: string
  name: string
  directory: string
  lastModified: Date
  isChanged: boolean
  isStaged: boolean
  masterBundleId?: string
  handle?: FileSystemFileHandle
  tags: string[]
}

export interface WatchState {
  lastAccessed: string
  files: {
    [path: string]: {
      name: string
      directory: string
      lastModified: string
      isChanged: boolean
      isStaged: boolean
      masterBundleId?: string
      tags: string[]
    }
  }
  masterBundle: {
    id: string
    created: string
    fileCount: number
  } | null
}

export type DirectoryWatcherContextType = {
  watchedFiles: WatchedFile[]
  stagedFiles: WatchedFile[]
  selectDirectory: () =&gt; Promise&lt;void&gt;
  refreshFiles: () =&gt; Promise&lt;void&gt;
  isWatching: boolean
  createBundle: () =&gt; Promise&lt;string&gt;
  toggleStaged: (paths: string[]) =&gt; void
  bundles: Bundle[]
  loadBundles: () =&gt; Promise&lt;void&gt;
  currentDirectory: string | null
  createMasterBundle: () =&gt; Promise&lt;void&gt;
  cntxDir: FileSystemDirectoryHandle | null
  tags: TagsConfig
  addTag: (name: string, color: string, description: string) =&gt; void
  deleteTag: (name: string) =&gt; void
  updateTag: (name: string, color: string, description: string) =&gt; void
  addTagToFiles: (tag: string, paths: string[]) =&gt; Promise&lt;void&gt;
  removeTagFromFiles: (tag: string, paths: string[]) =&gt; Promise&lt;void&gt;
  getFilesWithTag: (tag: string) =&gt; WatchedFile[]
  getTagsForFile: (path: string) =&gt; string[]
}

/*
 ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗ 
██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝ 
██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗
██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║
╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝
 ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝ 
*/

export type WatchConfig = {
  ignore: string[] // Patterns to ignore
  include?: string[] // Optional patterns to include
}

export const DEFAULT_CONFIG: WatchConfig = {
  ignore: [
    &#39;node_modules&#39;,
    &#39;dist&#39;,
    &#39;.git&#39;,
    &#39;build&#39;,
    &#39;coverage&#39;,
    &#39;.next&#39;,
    &#39;.cache&#39;,
    &#39;package-lock.json&#39;,
    &#39;yarn.lock&#39;,
  ],
  include: [&#39;*.ts&#39;, &#39;*.tsx&#39;, &#39;*.js&#39;, &#39;*.jsx&#39;, &#39;*.md&#39;, &#39;*.json&#39;],
}
</content>
    </document>

    <document>
      <source>src/contexts/BundleContext.tsx</source>
      <tags>state-context,file-operations</tags>
      <metadata>
        <size>12891</size>
        <lastModified>2025-05-27T01:30:25.308Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/BundleContext.tsx - Enhanced with update operations
import React, { createContext, useState, useCallback, useContext, useEffect } from &#39;react&#39;;
import type { Bundle } from &#39;@/types/types&#39;;
import { useDirectory } from &#39;./DirectoryContext&#39;;
import { useFiles } from &#39;./FileContext&#39;;
import { useProjectConfig } from &#39;./ProjectConfigContext&#39;;
import { createBundleFile, createTagBundleFile } from &#39;@/utils/file-state&#39;;
import { createMasterBundle as createMasterBundleUtil } from &#39;@/utils/project-utils&#39;;

// Enhanced context type with update operations
type BundleContextType = {
  bundles: Bundle[];
  masterBundle: Bundle | null;
  createBundle: () =&gt; Promise&lt;string&gt;;
  createTagBundle: (tagName: string) =&gt; Promise&lt;string&gt;;
  updateBundle: (
    bundleName: string,
    filesToInclude: any[],
    filesToRemove?: string[]
  ) =&gt; Promise&lt;{ success: boolean; error?: string; bundleId?: string }&gt;;
  createMasterBundle: () =&gt; Promise&lt;void&gt;;
  loadBundles: () =&gt; Promise&lt;void&gt;;
};

const BundleContext = createContext&lt;BundleContextType&gt;({
  bundles: [],
  masterBundle: null,
  createBundle: async () =&gt; &#39;&#39;,
  createTagBundle: async () =&gt; &#39;&#39;,
  updateBundle: async () =&gt; ({ success: false }),
  createMasterBundle: async () =&gt; { },
  loadBundles: async () =&gt; { },
});

export function BundleProvider({ children }: { children: React.ReactNode }) {
  const [bundles, setBundles] = useState&lt;Bundle[]&gt;([]);
  const [masterBundle, setMasterBundle] = useState&lt;Bundle | null&gt;(null);
  const { directoryHandle, isWatching } = useDirectory();
  const { watchedFiles, stagedFiles, refreshFiles } = useFiles();
  const { ignorePatterns } = useProjectConfig();

  // Helper function to load a bundle with proper type detection and metadata extraction
  const loadBundleWithType = useCallback(async (
    entry: FileSystemFileHandle,
    dir: FileSystemDirectoryHandle,
    defaultType: &#39;master&#39; | &#39;tag-derived&#39; | &#39;custom&#39;,
    derivedFromTag?: string
  ): Promise&lt;Bundle | null&gt; =&gt; {
    try {
      const file = await entry.getFile();
      const content = await file.text();
      const fileCount = (content.match(/&lt;document&gt;/g) || []).length;

      // Extract enhanced metadata from bundle XML content
      const typeMatch = content.match(/type=&quot;([^&quot;]+)&quot;/);
      const derivedTagMatch = content.match(/&lt;derivedFromTag&gt;([^&lt;]+)&lt;\/derivedFromTag&gt;/);
      const descriptionMatch = content.match(/&lt;description&gt;([^&lt;]+)&lt;\/description&gt;/);

      // Determine actual bundle type and metadata
      const bundleType = (typeMatch?.[1] as any) || defaultType;
      const actualDerivedTag = derivedTagMatch?.[1] || derivedFromTag;
      const description = descriptionMatch?.[1];

      // Generate bundle ID from filename
      const bundleId = entry.name.replace(/\.txt$/, &#39;&#39;);

      // Try to load manifest for enhanced tag counting
      let tagsCount = 0;
      try {
        const manifestName = `${bundleId}-manifest.json`;
        const manifestFile = await dir.getFileHandle(manifestName);
        const manifestContent = await manifestFile.getFile().then(f =&gt; f.text());
        const manifest = JSON.parse(manifestContent);

        // Count how many files in the manifest have tags (from current watchedFiles)
        const taggedFilePaths = new Set(watchedFiles.filter(f =&gt; f.tags?.length &gt; 0).map(f =&gt; f.path));
        const manifestFilesWithTags = manifest.files.filter((f: any) =&gt; taggedFilePaths.has(f.path));
        tagsCount = manifestFilesWithTags.length;
      } catch (error) {
        console.log(`Could not load manifest for ${entry.name}:`, error);
      }

      // Generate automatic description for tag-derived bundles if not provided
      const finalDescription = description ||
        (bundleType === &#39;tag-derived&#39; ? `Files tagged with &quot;${actualDerivedTag}&quot;` : undefined);

      return {
        name: entry.name,
        timestamp: new Date(file.lastModified),
        fileCount,
        tagCount: tagsCount,
        type: bundleType,
        id: bundleId,
        derivedFromTag: actualDerivedTag,
        description: finalDescription,
      };
    } catch (error) {
      console.error(`Error loading bundle ${entry.name}:`, error);
      return null;
    }
  }, [watchedFiles]);

  const loadBundles = useCallback(async () =&gt; {
    if (!directoryHandle || !isWatching) return;

    try {
      console.log(&#39;🔄 Loading bundles with enhanced type detection...&#39;);
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);
      const loadedBundles: Bundle[] = [];

      // 1. Load custom bundles (regular bundles in root bundles directory)
      console.log(&#39;📦 Loading custom bundles...&#39;);
      for await (const entry of bundlesDir.values()) {
        if (entry.kind === &#39;file&#39; &amp;&amp; entry.name.endsWith(&#39;.txt&#39;) &amp;&amp; !entry.name.startsWith(&#39;master-&#39;)) {
          const bundle = await loadBundleWithType(entry, bundlesDir, &#39;custom&#39;);
          if (bundle) {
            console.log(`✅ Loaded custom bundle: ${bundle.name} (${bundle.fileCount} files)`);
            loadedBundles.push(bundle);
          }
        }
      }

      // 2. Load tag-derived bundles from tag-bundles subdirectory
      console.log(&#39;🏷️  Loading tag-derived bundles...&#39;);
      try {
        const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;);

        for await (const tagDirEntry of tagBundlesDir.values()) {
          if (tagDirEntry.kind === &#39;directory&#39;) {
            const tagDir = tagDirEntry as FileSystemDirectoryHandle;
            const tagName = tagDirEntry.name;

            console.log(`🔍 Checking tag directory: ${tagName}`);

            for await (const bundleEntry of tagDir.values()) {
              if (bundleEntry.kind === &#39;file&#39; &amp;&amp; bundleEntry.name.endsWith(&#39;.txt&#39;)) {
                const bundle = await loadBundleWithType(bundleEntry, tagDir, &#39;tag-derived&#39;, tagName);
                if (bundle) {
                  console.log(`✅ Loaded tag-derived bundle: ${bundle.name} (tag: ${tagName}, ${bundle.fileCount} files)`);
                  loadedBundles.push(bundle);
                }
              }
            }
          }
        }
      } catch (error) {
        console.log(&#39;ℹ️  No tag-bundles directory found or error loading tag bundles:&#39;, error);
      }

      // 3. Load master bundles (keep existing logic but with enhanced type detection)
      console.log(&#39;👑 Loading master bundles...&#39;);
      try {
        const masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true });

        let latestMasterBundle: Bundle | null = null;
        let latestTimestamp = 0;

        for await (const entry of masterDir.values()) {
          if (entry.kind === &#39;file&#39; &amp;&amp; entry.name.endsWith(&#39;.txt&#39;)) {
            const bundle = await loadBundleWithType(entry, masterDir, &#39;master&#39;);
            if (bundle &amp;&amp; bundle.timestamp.getTime() &gt; latestTimestamp) {
              latestTimestamp = bundle.timestamp.getTime();
              latestMasterBundle = bundle;
              console.log(`🔍 Found master bundle: ${bundle.name}, timestamp: ${bundle.timestamp}`);
            }
          }
        }

        if (latestMasterBundle) {
          console.log(`👑 Setting master bundle to: ${latestMasterBundle.name}`);
          setMasterBundle(latestMasterBundle);
        } else {
          console.log(&#39;ℹ️  No master bundles found&#39;);
          setMasterBundle(null);
        }
      } catch (error) {
        console.error(&#39;❌ Error loading master bundles:&#39;, error);
        setMasterBundle(null);
      }

      // Sort all bundles by timestamp (newest first)
      const sortedBundles = loadedBundles.sort((a, b) =&gt; b.timestamp.getTime() - a.timestamp.getTime());

      // Log summary statistics
      const bundleStats = {
        custom: sortedBundles.filter(b =&gt; b.type === &#39;custom&#39;).length,
        tagDerived: sortedBundles.filter(b =&gt; b.type === &#39;tag-derived&#39;).length,
        master: masterBundle ? 1 : 0,
        total: sortedBundles.length + (masterBundle ? 1 : 0)
      };

      console.log(`📊 Bundle loading complete:`, bundleStats);
      console.log(`   • ${bundleStats.custom} custom bundles`);
      console.log(`   • ${bundleStats.tagDerived} tag-derived bundles`);
      console.log(`   • ${bundleStats.master} master bundle`);
      console.log(`   • ${bundleStats.total} total bundles`);

      setBundles(sortedBundles);
    } catch (error) {
      console.error(&#39;❌ Error loading bundles:&#39;, error);
    }
  }, [directoryHandle, isWatching, watchedFiles, loadBundleWithType]);

  // Load bundles when directory is selected
  useEffect(() =&gt; {
    if (directoryHandle &amp;&amp; isWatching) {
      loadBundles();
    }
  }, [directoryHandle, isWatching, loadBundles]);

  const createBundle = useCallback(async () =&gt; {
    if (!directoryHandle) return &#39;&#39;;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      console.log(&#39;Creating bundle with staged files...&#39;);
      const result = await createBundleFile(stagedFiles, cntxDir);

      if (result.success) {
        console.log(&#39;Bundle created successfully:&#39;, result.bundleId);
        await loadBundles(); // Refresh bundle list
        await refreshFiles(); // Refresh file states
        return result.bundleId || &#39;&#39;;
      }

      console.error(&#39;Failed to create bundle:&#39;, result.error);
      return &#39;&#39;;
    } catch (error) {
      console.error(&#39;Error creating bundle:&#39;, error);
      return &#39;&#39;;
    }
  }, [directoryHandle, stagedFiles, loadBundles, refreshFiles]);

  // Create tag-derived bundle
  const createTagBundle = useCallback(async (tagName: string, existingBundle?: Bundle) =&gt; {
    if (!directoryHandle) {
      throw new Error(&#39;No directory handle available&#39;);
    }

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const filesWithTag = watchedFiles.filter(file =&gt; file.tags?.includes(tagName));

      if (filesWithTag.length === 0) {
        throw new Error(`No files found with tag &quot;${tagName}&quot;`);
      }

      console.log(`${existingBundle ? &#39;Updating&#39; : &#39;Creating&#39;} tag bundle for &quot;${tagName}&quot; with ${filesWithTag.length} files`);

      // Pass existing bundle ID if updating
      const result = await createTagBundleFile(
        filesWithTag,
        tagName,
        cntxDir,
        existingBundle?.id // Pass existing ID for updates
      );

      if (result.success) {
        console.log(`Tag bundle ${existingBundle ? &#39;updated&#39; : &#39;created&#39;} successfully:`, result.bundleId);
        await loadBundles();
        await refreshFiles();
        return result.bundleId || &#39;&#39;;
      }

      throw new Error(result.error || &#39;Failed to create tag bundle&#39;);
    } catch (error) {
      console.error(&#39;Error with tag bundle:&#39;, error);
      throw error;
    }
  }, [directoryHandle, watchedFiles, loadBundles, refreshFiles]);

  const createMasterBundle = useCallback(async (existingBundle?: Bundle) =&gt; {
    if (!directoryHandle) {
      console.error(&#39;No directory handle available&#39;);
      return;
    }

    try {
      console.log(`${existingBundle ? &#39;Updating&#39; : &#39;Creating&#39;} master bundle with ignore patterns:`, ignorePatterns);
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // Pass existing bundle ID if updating
      const result = await createMasterBundleUtil(
        watchedFiles,
        cntxDir,
        ignorePatterns,
        existingBundle?.id // Pass existing ID for updates
      );

      if (result.success) {
        console.log(`Master bundle ${existingBundle ? &#39;updated&#39; : &#39;created&#39;} successfully!`);
        await loadBundles();
        await refreshFiles();
      } else {
        console.error(&#39;Failed to create master bundle:&#39;, result.error);
        throw new Error(result.error || &#39;Failed to create master bundle&#39;);
      }
    } catch (error) {
      console.error(&#39;Error creating master bundle:&#39;, error);
      throw error;
    }
  }, [directoryHandle, watchedFiles, ignorePatterns, loadBundles, refreshFiles]);

  // Update bundle - placeholder for future implementation
  const updateBundle = useCallback(async (
    bundleName: string,
    filesToInclude: any[],
    filesToRemove?: string[]
  ) =&gt; {
    // TODO: Implement bundle update logic
    console.log(&#39;Bundle update not yet implemented:&#39;, { bundleName, filesToInclude, filesToRemove });
    return { success: false, error: &#39;Bundle update not yet implemented&#39; };
  }, []);

  const value = {
    bundles,
    masterBundle,
    createBundle,
    createTagBundle,
    createMasterBundle,
    updateBundle,
    loadBundles,
  };

  return (
    &lt;BundleContext.Provider value={value}&gt;
      {children}
    &lt;/BundleContext.Provider&gt;
  );
}

export function useBundles() {
  const context = useContext(BundleContext);
  if (!context) {
    throw new Error(&#39;useBundles must be used within a BundleProvider&#39;);
  }
  return context;
}
</content>
    </document>

    <document>
      <source>src/contexts/CntxProvider.tsx</source>
      <tags>state-context,app-core</tags>
      <metadata>
        <size>848</size>
        <lastModified>2025-05-26T20:15:22.286Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// Updated src/contexts/CntxProvider.tsx
import React from &#39;react&#39;;
import { DirectoryProvider } from &#39;./DirectoryContext&#39;;
import { ProjectConfigProvider } from &#39;./ProjectConfigContext&#39;;
import { FileProvider } from &#39;./FileContext&#39;;
import { BundleProvider } from &#39;./BundleContext&#39;;
import { TagProvider } from &#39;./TagContext&#39;;
import { CursorRulesProvider } from &#39;./CursorRulesContext&#39;;

export function CntxProvider({ children }: { children: React.ReactNode }) {
  return (
    &lt;DirectoryProvider&gt;
      &lt;ProjectConfigProvider&gt;
        &lt;FileProvider&gt;
          &lt;BundleProvider&gt;
            &lt;TagProvider&gt;
              &lt;CursorRulesProvider&gt;
                {children}
              &lt;/CursorRulesProvider&gt;
            &lt;/TagProvider&gt;
          &lt;/BundleProvider&gt;
        &lt;/FileProvider&gt;
      &lt;/ProjectConfigProvider&gt;
    &lt;/DirectoryProvider&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/contexts/ProjectConfigContext.tsx</source>
      <tags>state-context,configuration</tags>
      <metadata>
        <size>5497</size>
        <lastModified>2025-05-23T22:42:10.887Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/ProjectConfigContext.tsx - Enhanced with project metadata
import React, { createContext, useState, useCallback, useContext, useEffect } from &#39;react&#39;;
import type { ProjectConfigContextType, ProjectMetadata } from &#39;./types&#39;;
import { DEFAULT_BUNDLE_IGNORE } from &#39;@/constants&#39;;
import { initializeProject, loadPatternIgnore, loadProjectMetadata, saveProjectMetadata } from &#39;@/utils/project-utils&#39;;
import { useDirectory } from &#39;./DirectoryContext&#39;;
import { useFiles } from &#39;./FileContext&#39;;

const ProjectConfigContext = createContext&lt;ProjectConfigContextType&gt;({
  ignorePatterns: DEFAULT_BUNDLE_IGNORE,
  updateIgnorePatterns: () =&gt; { },
  isProjectInitialized: false,
  initializeProject: async () =&gt; { },
  projectMetadata: null,
  updateProjectMetadata: async () =&gt; { },
});

export function ProjectConfigProvider({ children }: { children: React.ReactNode }) {
  const [ignorePatterns, setIgnorePatterns] = useState&lt;string[]&gt;([]);
  const [isProjectInitialized, setIsProjectInitialized] = useState(false);
  const [projectMetadata, setProjectMetadata] = useState&lt;ProjectMetadata | null&gt;(null);
  const { directoryHandle } = useDirectory();
  const { refreshFiles } = useFiles();

  // Check if project is initialized when directory changes
  useEffect(() =&gt; {
    const checkInitialization = async () =&gt; {
      if (!directoryHandle) {
        setIsProjectInitialized(false);
        setProjectMetadata(null);
        return;
      }

      try {
        const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
        console.log(&quot;Loading patterns from pattern-ignore.ts...&quot;);
        const patterns = await loadPatternIgnore(cntxDir);
        console.log(&quot;ProjectConfigContext - Loaded patterns:&quot;, patterns);

        // Load project metadata
        const metadata = await loadProjectMetadata(cntxDir);
        console.log(&quot;ProjectConfigContext - Loaded project metadata:&quot;, metadata);

        // Set the patterns and metadata in state
        setIgnorePatterns(patterns);
        setProjectMetadata(metadata);
        setIsProjectInitialized(true);
      } catch (error) {
        console.error(&#39;Project not initialized or error loading config:&#39;, error);
        setIsProjectInitialized(false);
        setProjectMetadata(null);
      }
    };

    checkInitialization();
  }, [directoryHandle]);

  const updateIgnorePatterns = useCallback(async (patterns: string[]) =&gt; {
    if (!directoryHandle) return;

    try {
      // Update state immediately
      setIgnorePatterns(patterns);
      console.log(&quot;Setting ignorePatterns state to:&quot;, patterns);

      // Get the config directory handle
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;);

      // Create a very simple format that&#39;s easy to parse
      const content = `// .cntx/config/pattern-ignore.ts
export default [
  ${patterns.map(p =&gt; `&#39;${p}&#39;`).join(&#39;,\n  &#39;)}
] as const;
`;

      console.log(&quot;Writing pattern file with content:&quot;, content);

      // Write to file
      const ignoreHandle = await configDir.getFileHandle(&#39;pattern-ignore.ts&#39;, {
        create: true,
      });
      const writable = await ignoreHandle.createWritable();
      await writable.write(content);
      await writable.close();

      // Force refresh files with the new patterns
      setTimeout(() =&gt; refreshFiles(), 100);
    } catch (error) {
      console.error(&#39;Error updating ignore patterns:&#39;, error);
    }
  }, [directoryHandle, refreshFiles]);

  const updateProjectMetadata = useCallback(async (metadata: ProjectMetadata) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // Save the metadata
      await saveProjectMetadata(cntxDir, metadata);

      // Update state
      setProjectMetadata(metadata);

      console.log(&#39;✅ Project metadata updated:&#39;, metadata);
    } catch (error) {
      console.error(&#39;Error updating project metadata:&#39;, error);
    }
  }, [directoryHandle]);

  const initProject = useCallback(async () =&gt; {
    if (!directoryHandle) {
      throw new Error(&#39;No directory handle provided&#39;);
    }

    try {
      const { cntxDir } = await initializeProject(directoryHandle);

      // Load ignore patterns
      const patterns = await loadPatternIgnore(cntxDir);
      setIgnorePatterns(patterns);

      // Load or create default project metadata
      const defaultMetadata: ProjectMetadata = {
        name: directoryHandle.name || &#39;Untitled Project&#39;,
        description: &#39;&#39;,
        version: &#39;1.0.0&#39;,
        author: &#39;&#39;,
        lastUpdated: new Date().toISOString(),
      };

      await saveProjectMetadata(cntxDir, defaultMetadata);
      setProjectMetadata(defaultMetadata);

      setIsProjectInitialized(true);
    } catch (error) {
      console.error(&#39;Project initialization failed:&#39;, error);
      setIsProjectInitialized(false);
      throw error;
    }
  }, [directoryHandle]);

  const value = {
    ignorePatterns,
    updateIgnorePatterns,
    isProjectInitialized,
    initializeProject: initProject,
    projectMetadata,
    updateProjectMetadata,
  };

  return (
    &lt;ProjectConfigContext.Provider value={value}&gt;
      {children}
    &lt;/ProjectConfigContext.Provider&gt;
  );
}

export function useProjectConfig() {
  const context = useContext(ProjectConfigContext);
  if (!context) {
    throw new Error(&#39;useProjectConfig must be used within a ProjectConfigProvider&#39;);
  }
  return context;
}
</content>
    </document>

    <document>
      <source>src/contexts/CursorRulesContext.tsx</source>
      <tags>state-context,external-apis</tags>
      <metadata>
        <size>4926</size>
        <lastModified>2025-05-26T20:45:30.198Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/CursorRulesContext.tsx
import React, { createContext, useContext, useState, useCallback, useEffect } from &#39;react&#39;;
import { useDirectory } from &#39;./DirectoryContext&#39;;
import {
  loadCursorRules,
  saveCursorRules,
} from &#39;@/utils/cursor-rules&#39;;

interface CursorRulesContextType {
  // Simplified state
  rulesContent: string;
  rulesLocation: string;
  filePath: string;
  hasExistingRules: boolean;
  isLoading: boolean;
  error: string | null;

  // Simplified actions
  loadRules: () =&gt; Promise&lt;void&gt;;
  saveRules: (content: string) =&gt; Promise&lt;void&gt;;
  createNewRules: (content: string, location?: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39;) =&gt; Promise&lt;void&gt;;
  clearError: () =&gt; void;
}

const CursorRulesContext = createContext&lt;CursorRulesContextType&gt;({
  rulesContent: &#39;&#39;,
  rulesLocation: &#39;&#39;,
  filePath: &#39;&#39;,
  hasExistingRules: false,
  isLoading: false,
  error: null,
  loadRules: async () =&gt; { },
  saveRules: async () =&gt; { },
  createNewRules: async () =&gt; { },
  clearError: () =&gt; { }
});

export function CursorRulesProvider({ children }: { children: React.ReactNode }) {
  const [rulesContent, setRulesContent] = useState&lt;string&gt;(&#39;&#39;);
  const [rulesLocation, setRulesLocation] = useState&lt;string&gt;(&#39;&#39;);
  const [filePath, setFilePath] = useState&lt;string&gt;(&#39;&#39;);
  const [hasExistingRules, setHasExistingRules] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);

  const { directoryHandle, isWatching } = useDirectory();

  // Load rules when directory changes
  useEffect(() =&gt; {
    if (directoryHandle &amp;&amp; isWatching) {
      loadRules();
    }
  }, [directoryHandle, isWatching]);

  const loadRules = useCallback(async () =&gt; {
    if (!directoryHandle) return;

    setIsLoading(true);
    setError(null);

    try {
      console.log(&#39;🔄 Loading Cursor rules...&#39;);
      const rules = await loadCursorRules(directoryHandle);

      if (rules) {
        setRulesContent(rules.content);
        setRulesLocation(rules.location);
        setFilePath(rules.filePath);
        setHasExistingRules(true);
        console.log(`✅ Loaded rules from ${rules.filePath}`);
      } else {
        setRulesContent(&#39;&#39;);
        setRulesLocation(&#39;&#39;);
        setFilePath(&#39;&#39;);
        setHasExistingRules(false);
        console.log(&#39;ℹ️ No existing rules found&#39;);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : &#39;Failed to load Cursor rules&#39;;
      console.error(&#39;❌ Error loading Cursor rules:&#39;, err);
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [directoryHandle]);

  const saveRules = useCallback(async (content: string) =&gt; {
    if (!directoryHandle) {
      throw new Error(&#39;No directory selected&#39;);
    }

    setIsLoading(true);
    setError(null);

    try {
      console.log(&#39;💾 Saving Cursor rules...&#39;);
      await saveCursorRules(directoryHandle, content);

      setRulesContent(content);
      setHasExistingRules(true);

      // Reload to get updated location info
      await loadRules();

      console.log(&#39;✅ Cursor rules saved successfully&#39;);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : &#39;Failed to save Cursor rules&#39;;
      console.error(&#39;❌ Error saving Cursor rules:&#39;, err);
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [directoryHandle, loadRules]);

  const createNewRules = useCallback(async (
    content: string,
    location?: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39;
  ) =&gt; {
    if (!directoryHandle) {
      throw new Error(&#39;No directory selected&#39;);
    }

    setIsLoading(true);
    setError(null);

    try {
      console.log(&#39;🆕 Creating new Cursor rules...&#39;);
      await saveCursorRules(directoryHandle, content, location);

      setRulesContent(content);
      setHasExistingRules(true);

      // Reload to get updated location info
      await loadRules();

      console.log(&#39;✅ New Cursor rules created successfully&#39;);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : &#39;Failed to create Cursor rules&#39;;
      console.error(&#39;❌ Error creating Cursor rules:&#39;, err);
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [directoryHandle, loadRules]);

  const clearError = useCallback(() =&gt; {
    setError(null);
  }, []);

  const value = {
    rulesContent,
    rulesLocation,
    filePath,
    hasExistingRules,
    isLoading,
    error,
    loadRules,
    saveRules,
    createNewRules,
    clearError
  };

  return (
    &lt;CursorRulesContext.Provider value={value}&gt;
      {children}
    &lt;/CursorRulesContext.Provider&gt;
  );
}

export function useCursorRules() {
  const context = useContext(CursorRulesContext);
  if (!context) {
    throw new Error(&#39;useCursorRules must be used within a CursorRulesProvider&#39;);
  }
  return context;
}
</content>
    </document>

    <document>
      <source>src/contexts/DirectoryContext.tsx</source>
      <tags>state-context,file-operations</tags>
      <metadata>
        <size>7182</size>
        <lastModified>2025-05-22T05:01:23.326Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/DirectoryContext.tsx
import React, { createContext, useState, useCallback, useContext, useRef } from &#39;react&#39;;
import type { DirectoryContextType } from &#39;./types&#39;;
import type { FileSystemDirectoryHandle } from &#39;@/types/types&#39;;
import { InitializationModal } from &#39;@/components/InitializationModal&#39;;
import { processDirectory } from &#39;@/utils/file-utils&#39;;

export const WATCHER_HEARTBEAT = 1000;

type DirectoryState = {
  currentDirectory: string | null;
  directoryHandle: FileSystemDirectoryHandle | null;
  isWatching: boolean;
  recentChanges: Array&lt;{
    kind: string;
    name: string;
    timestamp: Date;
  }&gt;;
};

const initialState: DirectoryState = {
  currentDirectory: null,
  directoryHandle: null,
  isWatching: false,
  recentChanges: []
};

const DirectoryContext = createContext&lt;DirectoryContextType&gt;({
  ...initialState,
  WATCHER_HEARTBEAT,
  selectDirectory: async () =&gt; { },
  clearDirectory: () =&gt; { },
  watchDirectory: async () =&gt; { },
});

export function DirectoryProvider({ children }: { children: React.ReactNode }) {
  // Core state
  const [state, setState] = useState&lt;DirectoryState&gt;(initialState);
  const [showInitModal, setShowInitModal] = useState(false);
  const [updateTrigger, setUpdateTrigger] = useState(0);  // Add this for force update

  // Refs for cleanup
  const watcherInterval = useRef&lt;number | null&gt;(null);
  const lastKnownFiles = useRef(new Map&lt;string, number&gt;());

  // Force update function
  const forceAppUpdate = useCallback(() =&gt; {
    console.log(&#39;Forcing app update&#39;);
    setUpdateTrigger(prev =&gt; prev + 1);
  }, []);

  // Helper to update state partially
  const updateState = useCallback((updates: Partial&lt;DirectoryState&gt;) =&gt; {
    setState(current =&gt; ({ ...current, ...updates }));
  }, []);

  // Clean up watcher
  const stopWatching = useCallback(() =&gt; {
    if (watcherInterval.current) {
      clearInterval(watcherInterval.current);
      watcherInterval.current = null;
    }
    updateState({ isWatching: false });
  }, [updateState]);

  // Start watching a directory
  const startWatching = useCallback(async (handle: FileSystemDirectoryHandle) =&gt; {
    // Stop any existing watcher
    stopWatching();

    console.log(&#39;Starting directory watch...&#39;);
    updateState({ isWatching: true });

    watcherInterval.current = window.setInterval(async () =&gt; {
      try {
        const currentFiles = new Map&lt;string, number&gt;();
        const snapshot = await processDirectory(handle);

        snapshot.forEach(file =&gt; {
          currentFiles.set(file.path, file.lastModified.getTime());
        });

        // Track changes
        for (const [path, currentTime] of currentFiles) {
          const previousTime = lastKnownFiles.current.get(path);

          if (!previousTime) {
            updateState({
              recentChanges: [{
                kind: &#39;create&#39;,
                name: path,
                timestamp: new Date()
              }, ...state.recentChanges].slice(0, 50)
            });
          } else if (previousTime !== currentTime) {
            updateState({
              recentChanges: [{
                kind: &#39;modify&#39;,
                name: path,
                timestamp: new Date()
              }, ...state.recentChanges].slice(0, 50)
            });
          }
        }

        // Check for deletions
        for (const [path] of lastKnownFiles.current) {
          if (!currentFiles.has(path)) {
            updateState({
              recentChanges: [{
                kind: &#39;remove&#39;,
                name: path,
                timestamp: new Date()
              }, ...state.recentChanges].slice(0, 50)
            });
          }
        }

        lastKnownFiles.current = currentFiles;
      } catch (error) {
        console.error(&#39;Error in watcher heartbeat:&#39;, error);
        stopWatching();
      }
    }, WATCHER_HEARTBEAT);
  }, [state.recentChanges, stopWatching, updateState]);

  // Initialize directory watching
  const watchDirectory = useCallback(async (handle: FileSystemDirectoryHandle) =&gt; {
    if (!handle) return;

    try {
      // Verify .cntx exists
      await handle.getDirectoryHandle(&#39;.cntx&#39;, { create: false });

      // Update state and start watching
      updateState({
        directoryHandle: handle,
        currentDirectory: handle.name
      });
      await startWatching(handle);

      // Force update after watching starts
      forceAppUpdate();
    } catch (error) {
      console.log(&#39;Cannot start watching - directory not initialized&#39;);
    }
  }, [startWatching, updateState, forceAppUpdate]);

  // Clear all state
  const clearDirectory = useCallback(() =&gt; {
    stopWatching();
    setState(initialState);
    setShowInitModal(false);
  }, [stopWatching]);

  // Handle directory selection
  const selectDirectory = useCallback(async () =&gt; {
    try {
      const handle = await window.showDirectoryPicker({ mode: &#39;readwrite&#39; });

      // Update state with new handle
      updateState({
        directoryHandle: handle,
        currentDirectory: handle.name
      });

      try {
        // Check if directory is already initialized
        await handle.getDirectoryHandle(&#39;.cntx&#39;, { create: false });
        await startWatching(handle);
        forceAppUpdate();  // Force update after successful initialization
      } catch {
        // Not initialized - show modal
        setShowInitModal(true);
      }
    } catch (error) {
      console.error(&#39;Error selecting directory:&#39;, error);
      clearDirectory();
    }
  }, [clearDirectory, startWatching, updateState, forceAppUpdate]);

  // Handle initialization completion
  const handleInitializationComplete = useCallback(async () =&gt; {
    if (!state.directoryHandle) {
      console.error(&#39;No directory handle available&#39;);
      return;
    }

    try {
      // Start watching with existing handle
      await startWatching(state.directoryHandle);
      setShowInitModal(false);
      forceAppUpdate();  // Force update after initialization completes
    } catch (error) {
      console.error(&#39;Error starting watch after initialization:&#39;, error);
      clearDirectory();
    }
  }, [state.directoryHandle, startWatching, clearDirectory, forceAppUpdate]);

  // Cleanup on unmount
  React.useEffect(() =&gt; {
    return () =&gt; {
      stopWatching();
    };
  }, [stopWatching]);

  // Include updateTrigger in the render to ensure updates propagate
  React.useEffect(() =&gt; {
    console.log(&#39;Update triggered:&#39;, updateTrigger);
  }, [updateTrigger]);

  return (
    &lt;DirectoryContext.Provider value={{
      ...state,
      WATCHER_HEARTBEAT,
      selectDirectory,
      clearDirectory,
      watchDirectory,
    }}&gt;
      {children}
      &lt;InitializationModal
        isOpen={showInitModal}
        onComplete={handleInitializationComplete}
        dirHandle={state.directoryHandle!}
        forceAppUpdate={forceAppUpdate}  // Pass the force update function
      /&gt;
    &lt;/DirectoryContext.Provider&gt;
  );
}

export function useDirectory() {
  const context = useContext(DirectoryContext);
  if (!context) {
    throw new Error(&#39;useDirectory must be used within a DirectoryProvider&#39;);
  }
  return context;
}

export default DirectoryContext;
</content>
    </document>

    <document>
      <source>src/contexts/TagContext.tsx</source>
      <tags>state-context,business-logic</tags>
      <metadata>
        <size>7988</size>
        <lastModified>2025-05-23T20:54:30.123Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/TagContext.tsx - FIXED to ensure all tags load properly
import React, { createContext, useState, useCallback, useContext, useEffect } from &#39;react&#39;;
import type { TagContextType } from &#39;./types&#39;;
import type { TagsConfig, WatchedFile } from &#39;@/types/types&#39;;
import { DEFAULT_TAGS } from &#39;@/constants&#39;;
import { useDirectory } from &#39;./DirectoryContext&#39;;
import { useFiles } from &#39;./FileContext&#39;;
import { loadState, saveState } from &#39;@/utils/file-state&#39;;
import { loadTagsConfig, saveTagsConfig } from &#39;@/utils/project-utils&#39;;

const TagContext = createContext&lt;TagContextType&gt;({
  tags: {},
  addTag: () =&gt; { },
  deleteTag: () =&gt; { },
  updateTag: () =&gt; { },
  getFilesWithTag: () =&gt; [],
  addTagToFiles: async () =&gt; { },
  removeTagFromFiles: async () =&gt; { },
});

export function TagProvider({ children }: { children: React.ReactNode }) {
  const [tags, setTags] = useState&lt;TagsConfig&gt;(DEFAULT_TAGS);
  const [isLoading, setIsLoading] = useState(true);
  const { directoryHandle, isWatching } = useDirectory();
  const { watchedFiles } = useFiles();

  useEffect(() =&gt; {
    const loadTags = async () =&gt; {
      console.log(&#39;🏷️  TagContext: Loading tags...&#39;);
      setIsLoading(true);

      if (!directoryHandle || !isWatching) {
        console.log(&#39;🏷️  TagContext: No directory handle or not watching, using DEFAULT_TAGS&#39;);
        setTags(DEFAULT_TAGS);
        setIsLoading(false);
        return;
      }

      try {
        const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
        const existingTags = await loadTagsConfig(cntxDir);

        console.log(&#39;🏷️  TagContext: Loaded tags from config:&#39;, Object.keys(existingTags));
        console.log(&#39;🏷️  TagContext: Tag count:&#39;, Object.keys(existingTags).length);

        // Merge with defaults to ensure we have all standard tags plus custom ones
        const mergedTags = {
          ...DEFAULT_TAGS,
          ...existingTags
        };

        console.log(&#39;🏷️  TagContext: Final merged tags:&#39;, Object.keys(mergedTags));
        setTags(mergedTags);
      } catch (error) {
        console.error(&#39;🏷️  TagContext: Error loading tags:&#39;, error);
        console.log(&#39;🏷️  TagContext: Falling back to DEFAULT_TAGS&#39;);
        setTags(DEFAULT_TAGS);
      } finally {
        setIsLoading(false);
      }
    };

    loadTags();
  }, [directoryHandle, isWatching]);

  // Debug: Log whenever tags change
  useEffect(() =&gt; {
    console.log(&#39;🏷️  TagContext: Tags state updated:&#39;, {
      count: Object.keys(tags).length,
      tags: Object.keys(tags),
      isLoading
    });
  }, [tags, isLoading]);

  const addTag = useCallback(async (name: string, color: string, description: string) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const newTags = {
        ...tags,
        [name]: { color, description }
      };

      console.log(`🏷️  TagContext: Adding new tag &quot;${name}&quot;`);
      await saveTagsConfig(cntxDir, newTags);
      setTags(newTags);
      console.log(`✅ TagContext: Successfully added tag &quot;${name}&quot;`);
    } catch (error) {
      console.error(&#39;Error adding tag:&#39;, error);
    }
  }, [directoryHandle, tags]);

  const deleteTag = useCallback(async (name: string) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // Remove tag from tags config
      const { [name]: _, ...remainingTags } = tags;
      await saveTagsConfig(cntxDir, remainingTags);

      // CRITICAL FIX: Remove tag from all files in state safely
      // Load state without filtering to get ALL files including tagged ones
      const state = await loadState(cntxDir, []); // No filtering to preserve all files

      let removedFromCount = 0;
      Object.keys(state.files).forEach(path =&gt; {
        const originalTags = state.files[path].tags;
        state.files[path].tags = state.files[path].tags.filter(t =&gt; t !== name);

        if (originalTags.length !== state.files[path].tags.length) {
          removedFromCount++;
        }
      });

      console.log(`🗑️  Removed tag &quot;${name}&quot; from ${removedFromCount} files`);

      // Save state with tag preservation (other tags are kept)
      await saveState(cntxDir, state, []); // No filtering to preserve all files

      setTags(remainingTags);
    } catch (error) {
      console.error(&#39;Error deleting tag:&#39;, error);
    }
  }, [directoryHandle, tags]);

  const updateTag = useCallback(async (name: string, color: string, description: string) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const updatedTags = {
        ...tags,
        [name]: { color, description }
      };

      await saveTagsConfig(cntxDir, updatedTags);
      setTags(updatedTags);
    } catch (error) {
      console.error(&#39;Error updating tag:&#39;, error);
    }
  }, [directoryHandle, tags]);

  const getFilesWithTag = useCallback((tag: string): WatchedFile[] =&gt; {
    return watchedFiles.filter(file =&gt; file.tags?.includes(tag));
  }, [watchedFiles]);

  const addTagToFiles = useCallback(async (tag: string, paths: string[]) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // CRITICAL FIX: Load state without filtering to preserve ALL existing files
      const state = await loadState(cntxDir, []); // No filtering

      let addedToCount = 0;

      paths.forEach(path =&gt; {
        if (!state.files[path]) {
          // Create new file entry if it doesn&#39;t exist
          const pathParts = path.split(&#39;/&#39;);
          state.files[path] = {
            name: pathParts[pathParts.length - 1],
            directory: pathParts.slice(0, -1).join(&#39;/&#39;) || &#39;Root&#39;,
            lastModified: new Date().toISOString(),
            isChanged: false,
            isStaged: false,
            tags: [tag]
          };
          addedToCount++;
        } else if (!state.files[path].tags.includes(tag)) {
          // Add tag to existing file if it doesn&#39;t already have it
          state.files[path].tags.push(tag);
          addedToCount++;
        }
      });

      console.log(`🏷️  Added tag &quot;${tag}&quot; to ${addedToCount} files`);

      // Save state with all file preservation
      await saveState(cntxDir, state, []); // No filtering to preserve all files
    } catch (error) {
      console.error(&#39;Error adding tags to files:&#39;, error);
    }
  }, [directoryHandle]);

  const removeTagFromFiles = useCallback(async (tag: string, paths: string[]) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // CRITICAL FIX: Load state without filtering to preserve ALL existing files
      const state = await loadState(cntxDir, []); // No filtering

      let removedFromCount = 0;

      paths.forEach(path =&gt; {
        if (state.files[path]) {
          const originalLength = state.files[path].tags.length;
          state.files[path].tags = state.files[path].tags.filter(t =&gt; t !== tag);

          if (originalLength !== state.files[path].tags.length) {
            removedFromCount++;
          }
        }
      });

      console.log(`🗑️  Removed tag &quot;${tag}&quot; from ${removedFromCount} files`);

      // Save state with all file preservation
      await saveState(cntxDir, state, []); // No filtering to preserve all files
    } catch (error) {
      console.error(&#39;Error removing tags from files:&#39;, error);
    }
  }, [directoryHandle]);

  const value = {
    tags,
    addTag,
    deleteTag,
    updateTag,
    getFilesWithTag,
    addTagToFiles,
    removeTagFromFiles,
  };

  return (
    &lt;TagContext.Provider value={value}&gt;
      {children}
    &lt;/TagContext.Provider&gt;
  );
}

export function useTags() {
  const context = useContext(TagContext);
  if (!context) {
    throw new Error(&#39;useTags must be used within a TagProvider&#39;);
  }
  return context;
}
</content>
    </document>

    <document>
      <source>src/contexts/types.ts</source>
      <tags>types-definitions,state-context</tags>
      <metadata>
        <size>2038</size>
        <lastModified>2025-05-23T22:44:49.097Z</lastModified>
        <extension>ts</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/types.ts
import { Bundle, TagsConfig, WatchedFile } from &#39;@/types/types&#39;

export interface ProjectMetadata {
  name: string
  description: string
  version: string
  author: string
  lastUpdated: string
  repository?: string
  license?: string
  keywords?: string[]
}
export interface DirectoryContextType {
  currentDirectory: string | null
  directoryHandle: FileSystemDirectoryHandle | null
  isWatching: boolean
  recentChanges: Array&lt;{
    kind: string
    name: string
    timestamp: Date
  }&gt;
  WATCHER_HEARTBEAT: number
  selectDirectory: () =&gt; Promise&lt;void&gt;
  clearDirectory: () =&gt; void
  watchDirectory: (handle: FileSystemDirectoryHandle) =&gt; Promise&lt;void&gt;
}

export interface FileContextType {
  watchedFiles: WatchedFile[]
  stagedFiles: WatchedFile[]
  toggleStaged: (paths: string[]) =&gt; void
  refreshFiles: () =&gt; Promise&lt;void&gt;
  filterFiles: (criteria: Partial&lt;WatchedFile&gt;) =&gt; WatchedFile[]
}

export interface BundleContextType {
  bundles: Bundle[]
  masterBundle: Bundle | null
  createBundle: () =&gt; Promise&lt;string&gt;
  updateBundle: (
    bundleName: string,
    filesToInclude: WatchedFile[],
    filesToRemove?: string[]
  ) =&gt; Promise&lt;{ success: boolean; error?: string; bundleId?: string }&gt;
  createMasterBundle: () =&gt; Promise&lt;void&gt;
  loadBundles: () =&gt; Promise&lt;void&gt;
}

export interface TagContextType {
  tags: TagsConfig
  addTag: (name: string, color: string, description: string) =&gt; void
  deleteTag: (name: string) =&gt; void
  updateTag: (name: string, color: string, description: string) =&gt; void
  getFilesWithTag: (tag: string) =&gt; WatchedFile[]
  addTagToFiles: (tag: string, paths: string[]) =&gt; Promise&lt;void&gt;
  removeTagFromFiles: (tag: string, paths: string[]) =&gt; Promise&lt;void&gt;
}

export interface ProjectConfigContextType {
  ignorePatterns: string[]
  updateIgnorePatterns: (patterns: string[]) =&gt; void
  isProjectInitialized: boolean
  initializeProject: () =&gt; Promise&lt;void&gt;
  projectMetadata: ProjectMetadata | null
  updateProjectMetadata: (metadata: ProjectMetadata) =&gt; Promise&lt;void&gt;
}
</content>
    </document>

    <document>
      <source>src/contexts/FileContext.tsx</source>
      <tags>state-context,file-operations</tags>
      <metadata>
        <size>11964</size>
        <lastModified>2025-05-23T22:36:54.817Z</lastModified>
        <extension>tsx</extension>
        <directory>src/contexts</directory>
      </metadata>
      <content>// src/contexts/FileContext.tsx - ULTIMATE VERSION with bulletproof tag preservation
import React, { createContext, useState, useCallback, useContext, useEffect } from &#39;react&#39;;
import type { FileContextType } from &#39;./types&#39;;
import type { BundleManifest, WatchedFile } from &#39;@/types/types&#39;;
import { useDirectory } from &#39;./DirectoryContext&#39;;
import { processDirectory, shouldIgnorePath } from &#39;@/utils/file-utils&#39;;
import { loadState, saveState } from &#39;@/utils/file-state&#39;;
import { useProjectConfig } from &#39;./ProjectConfigContext&#39;;

const FileContext = createContext&lt;FileContextType&gt;({
  watchedFiles: [],
  stagedFiles: [],
  toggleStaged: () =&gt; { },
  refreshFiles: async () =&gt; { },
  filterFiles: () =&gt; [],
});

export function FileProvider({ children }: { children: React.ReactNode }) {
  const [watchedFiles, setWatchedFiles] = useState&lt;WatchedFile[]&gt;([]);
  const { directoryHandle, isWatching, recentChanges } = useDirectory();
  const { ignorePatterns } = useProjectConfig();
  const [lastProcessedChange, setLastProcessedChange] = useState&lt;Date | null&gt;(null);

  const refreshFiles = useCallback(async () =&gt; {
    if (!directoryHandle || !isWatching) return;

    try {
      console.log(&#39;🔄 Refreshing files - ULTIMATE tag preservation mode...&#39;);

      // Process directory to get current filesystem files
      const files = await processDirectory(directoryHandle, &#39;&#39;, ignorePatterns);
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // ULTIMATE FIX: Load existing state with ZERO filtering to preserve ALL tags
      const existingState = await loadState(cntxDir, []); // NO filtering whatsoever
      console.log(&#39;📂 Loaded existing state for&#39;, Object.keys(existingState.files).length, &#39;files&#39;);

      // Log all files with tags before processing
      const existingTaggedFiles = Object.entries(existingState.files).filter(([, state]) =&gt;
        state.tags &amp;&amp; state.tags.length &gt; 0
      );
      console.log(`🏷️  Found ${existingTaggedFiles.length} files with existing tags to preserve`);

      let masterManifest: BundleManifest | null = null;

      try {
        const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);
        let masterDir;
        try {
          masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true });
        } catch (error) {
          console.error(&#39;Error getting/creating master directory:&#39;, error);
          throw error;
        }

        const manifests = [];

        for await (const entry of masterDir.values()) {
          if (entry.kind === &#39;file&#39; &amp;&amp; entry.name.endsWith(&#39;-manifest.json&#39;)) {
            const file = await entry.getFile();
            manifests.push({
              file,
              entry,
              lastModified: file.lastModified
            });
          }
        }

        if (manifests.length &gt; 0) {
          const latestManifest = manifests.reduce((latest, current) =&gt; {
            return current.lastModified &gt; latest.lastModified ? current : latest;
          });

          console.log(`Found master manifest: ${latestManifest.entry.name}`);
          const content = await latestManifest.file.text();

          try {
            masterManifest = JSON.parse(content);
            console.log(`Parsed master manifest, contains ${masterManifest.fileCount} files`);
          } catch (parseError) {
            console.error(&#39;Error parsing master manifest:&#39;, parseError);
          }
        } else {
          console.log(&#39;No master manifests found&#39;);
        }
      } catch (error) {
        console.log(&#39;No master bundle found or error reading it:&#39;, error);
      }

      // ULTIMATE MERGE: Combine filesystem data with preserved state data
      const updatedFiles = files.map(file =&gt; {
        // Check if this file exists in the master manifest
        const masterFile = masterManifest?.files.find(f =&gt; f.path === file.path);

        // File is changed if it exists in master bundle and has a newer timestamp
        const isChanged = masterFile
          ? new Date(file.lastModified) &gt; new Date(masterFile.lastModified)
          : true; // New file if not in master

        // ULTIMATE PRESERVATION: Always prioritize existing state data
        const existingFileState = existingState.files[file.path];

        if (existingFileState) {
          // File exists in state - ABSOLUTELY PRESERVE ALL existing data
          console.log(`🏷️  PRESERVING existing state for ${file.path}:`, {
            tags: existingFileState.tags,
            staged: existingFileState.isStaged,
            bundleId: existingFileState.masterBundleId
          });

          return {
            ...file,
            isStaged: existingFileState.isStaged,
            isChanged,
            masterBundleId: existingFileState.masterBundleId || masterManifest?.id,
            // ULTIMATE: NEVER EVER lose existing tags
            tags: Array.isArray(existingFileState.tags) ? [...existingFileState.tags] : []
          };
        } else {
          // New file - create default state
          console.log(`➕ Creating new state for ${file.path}`);
          return {
            ...file,
            isStaged: false,
            isChanged,
            masterBundleId: masterManifest?.id,
            tags: []
          };
        }
      });

      setWatchedFiles(updatedFiles);

      // ULTIMATE STATE UPDATE: Start with existing state and only update what&#39;s necessary
      const newState = {
        ...existingState,
        lastAccessed: new Date().toISOString()
      };

      // Update state for files that exist in filesystem
      updatedFiles.forEach(file =&gt; {
        const existingFileState = newState.files[file.path];

        if (existingFileState) {
          // PRESERVE EVERYTHING, only update what actually changed
          newState.files[file.path] = {
            ...existingFileState, // Start with EVERYTHING from existing state
            // Only update filesystem-derived properties
            name: file.name,
            directory: file.directory,
            lastModified: file.lastModified.toISOString(),
            isChanged: file.isChanged,
            // Keep existing staging and bundle states unless explicitly changed
            isStaged: existingFileState.isStaged,
            masterBundleId: file.masterBundleId || existingFileState.masterBundleId,
            // ULTIMATE: ABSOLUTELY NEVER touch existing tags
            tags: existingFileState.tags || []
          };
        } else {
          // New file - create fresh entry
          newState.files[file.path] = {
            name: file.name,
            directory: file.directory,
            lastModified: file.lastModified.toISOString(),
            isChanged: file.isChanged,
            isStaged: file.isStaged,
            masterBundleId: file.masterBundleId,
            tags: []
          };
        }
      });

      // ULTIMATE RULE: Files with tags are NEVER removed from state
      // Even if they don&#39;t exist in the current filesystem scan
      const preservedTaggedFiles = Object.entries(existingState.files).filter(([path, state]) =&gt; {
        const hasImportantData = (state.tags &amp;&amp; state.tags.length &gt; 0) ||
          state.isStaged ||
          state.masterBundleId;
        const notInCurrentScan = !updatedFiles.find(f =&gt; f.path === path);

        return hasImportantData &amp;&amp; notInCurrentScan;
      });

      if (preservedTaggedFiles.length &gt; 0) {
        console.log(`🏷️  PRESERVING ${preservedTaggedFiles.length} files with important data that weren&#39;t in current scan:`);
        preservedTaggedFiles.forEach(([path, state]) =&gt; {
          console.log(`  ${path}: tags=[${state.tags?.join(&#39;, &#39;) || &#39;none&#39;}], staged=${state.isStaged}, bundleId=${state.masterBundleId}`);
          // Keep these files in the state even though they weren&#39;t scanned
          newState.files[path] = state;
        });
      }

      // Log final tag preservation verification
      const finalTaggedFiles = Object.entries(newState.files).filter(([, fileState]) =&gt;
        fileState.tags &amp;&amp; fileState.tags.length &gt; 0
      );
      console.log(`✅ FINAL VERIFICATION: Preserving ${finalTaggedFiles.length} files with tags:`,
        finalTaggedFiles.slice(0, 5).map(([path, state]) =&gt; `${path} [${state.tags.join(&#39;, &#39;)}]`)
      );

      // Save state with ULTIMATE tag preservation (no filtering)
      await saveState(cntxDir, newState, []); // NEVER filter when saving

    } catch (error) {
      console.error(&#39;❌ Error refreshing files:&#39;, error);
    }
  }, [directoryHandle, isWatching, ignorePatterns]);

  // Clear state when directory changes
  useEffect(() =&gt; {
    if (!directoryHandle) {
      setWatchedFiles([]);
    }
  }, [directoryHandle]);

  // Separate effect for ignore pattern changes
  useEffect(() =&gt; {
    if (directoryHandle &amp;&amp; isWatching &amp;&amp; ignorePatterns.length &gt; 0) {
      console.log(&#39;🔧 Ignore patterns changed, refreshing with ULTIMATE tag preservation:&#39;, ignorePatterns);
      refreshFiles();
    }
  }, [ignorePatterns, directoryHandle, isWatching, refreshFiles]);

  // Separate effect for file changes
  useEffect(() =&gt; {
    if (!directoryHandle || !isWatching) return;

    const handleChanges = async () =&gt; {
      if (recentChanges.length &gt; 0) {
        const latestChange = recentChanges[0];
        if (!lastProcessedChange || latestChange.timestamp &gt; lastProcessedChange) {
          await refreshFiles();
          setLastProcessedChange(latestChange.timestamp);
        }
      }
    };

    handleChanges();
  }, [directoryHandle, isWatching, recentChanges, lastProcessedChange, refreshFiles]);

  const toggleStaged = useCallback(async (paths: string[]) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);

      // ULTIMATE: Load state without ANY filtering to preserve ALL tagged files
      const state = await loadState(cntxDir, []); // Absolutely no filtering
      const firstPath = paths[0];
      let targetState = false;

      if (state.files[firstPath]) {
        targetState = !state.files[firstPath].isStaged;
      }

      paths.forEach(path =&gt; {
        if (!state.files[path]) {
          const pathParts = path.split(&#39;/&#39;);
          state.files[path] = {
            name: pathParts[pathParts.length - 1],
            directory: pathParts.slice(0, -1).join(&#39;/&#39;) || &#39;Root&#39;,
            lastModified: new Date().toISOString(),
            isChanged: false,
            isStaged: targetState,
            masterBundleId: undefined,
            tags: []
          };
        } else {
          // ULTIMATE PRESERVATION: Keep everything, only change isStaged
          state.files[path] = {
            ...state.files[path], // PRESERVE EVERYTHING including tags
            isStaged: targetState  // Only change this one property
          };
        }
      });

      // Save with ULTIMATE tag preservation (no filtering)
      await saveState(cntxDir, state, []); // Never filter when saving

      setWatchedFiles(prev =&gt; prev.map(file =&gt;
        paths.includes(file.path)
          ? { ...file, isStaged: targetState }
          : file
      ));
    } catch (error) {
      console.error(&#39;❌ Error toggling staged status:&#39;, error);
    }
  }, [directoryHandle]);

  const filterFiles = useCallback((criteria: Partial&lt;WatchedFile&gt;) =&gt; {
    return watchedFiles.filter(file =&gt;
      Object.entries(criteria).every(([key, value]) =&gt; file[key as keyof WatchedFile] === value)
    );
  }, [watchedFiles]);

  const stagedFiles = watchedFiles.filter(file =&gt; file.isStaged);

  const value = {
    watchedFiles,
    stagedFiles,
    toggleStaged,
    refreshFiles,
    filterFiles,
  };

  return (
    &lt;FileContext.Provider value={value}&gt;
      {children}
    &lt;/FileContext.Provider&gt;
  );
}

export function useFiles() {
  const context = useContext(FileContext);
  if (!context) {
    throw new Error(&#39;useFiles must be used within a FileProvider&#39;);
  }
  return context;
}
</content>
    </document>

    <document>
      <source>src/constants/index.ts</source>
      <tags>configuration,business-logic</tags>
      <metadata>
        <size>1653</size>
        <lastModified>2025-05-22T01:02:49.262Z</lastModified>
        <extension>ts</extension>
        <directory>src/constants</directory>
      </metadata>
      <content>// src/constants/index.ts

export const DEFAULT_BUNDLE_IGNORE = [
  // Directories
  &#39;node_modules&#39;,
  &#39;.git&#39;,
  &#39;dist&#39;,
  &#39;build&#39;,
  &#39;coverage&#39;,
  &#39;.next&#39;,
  &#39;.cache&#39;,
  &#39;.netlify&#39;,

  // Package files
  &#39;package-lock.json&#39;,
  &#39;yarn.lock&#39;,

  // System files
  &#39;.DS_Store&#39;,
  &#39;Thumbs.db&#39;,

  // Media files
  &#39;*.mp3&#39;,
  &#39;*.mp4&#39;,
  &#39;*.wav&#39;,
  &#39;*.ogg&#39;,
  &#39;*.m4a&#39;,
  &#39;*.flac&#39;,
  &#39;*.jpg&#39;,
  &#39;*.jpeg&#39;,
  &#39;*.png&#39;,
  &#39;*.gif&#39;,
  &#39;*.webp&#39;,
  &#39;*.svg&#39;,
  &#39;*.ico&#39;,
  &#39;*.pxd&#39;,

  // Documents and archives
  &#39;*.pdf&#39;,
  &#39;*.doc&#39;,
  &#39;*.docx&#39;,
  &#39;*.zip&#39;,
  &#39;*.tar&#39;,
  &#39;*.gz&#39;,
  &#39;*.rar&#39;,

  // Other
  &#39;example-project&#39;,
  &#39;issues&#39;,
]

export const DEFAULT_TAGS: Record&lt;
  string,
  { color: string; description: string }
&gt; = {
  application: {
    color: &#39;#0ea5e9&#39;, // sky-500
    description: &#39;Main application code and logic&#39;,
  },
  infrastructure: {
    color: &#39;#f97316&#39;, // orange-500
    description: &#39;Deployment, CI/CD, infrastructure-as-code&#39;,
  },
  configuration: {
    color: &#39;#94a3b8&#39;, // slate-400
    description: &#39;Build, tooling, and environment configuration&#39;,
  },
  documentation: {
    color: &#39;#8b5cf6&#39;, // violet-500
    description: &#39;Documentation, markdown files, and comments&#39;,
  },
  testing: {
    color: &#39;#22c55e&#39;, // green-500
    description: &#39;Unit tests, integration tests, and mocks&#39;,
  },
  assets: {
    color: &#39;#78716c&#39;, // stone-500
    description: &#39;Static files, images, media, and fonts&#39;,
  },
  libraries: {
    color: &#39;#ec4899&#39;, // pink-500
    description: &#39;Shared utilities, helper functions, and internal packages&#39;,
  },
  types: {
    color: &#39;#6366f1&#39;, // indigo-500
    description: &#39;Type definitions and interfaces&#39;,
  },
}
</content>
    </document>

    <document>
      <source>src/utils/project-utils.ts</source>
      <tags>business-logic,file-operations</tags>
      <metadata>
        <size>23070</size>
        <lastModified>2025-05-27T01:25:17.353Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/project-utils.ts - FIXED to preserve tags during master bundle creation
import { DEFAULT_BUNDLE_IGNORE, DEFAULT_TAGS } from &#39;../constants&#39;
import type {
  WatchedFile,
  WatchState,
  FileSystemDirectoryHandle,
  TagsConfig,
  BundleManifest,
} from &#39;../types/types&#39;
import { loadState, saveState, saveBundleManifest } from &#39;./file-state&#39;
import { processDirectory } from &#39;./file-utils&#39;

export async function initializeProject(dirHandle: FileSystemDirectoryHandle) {
  try {
    console.log(&#39;Starting initialization...&#39;)
    // Create .cntx directory first
    const cntxDir = await dirHandle.getDirectoryHandle(&#39;.cntx&#39;, {
      create: true,
    })

    console.log(&#39;Creating directory structure...&#39;)
    // Create directory structure
    await createDirectoryStructure(cntxDir)

    console.log(&#39;Creating initial configuration...&#39;)
    // Create initial configuration
    await createInitialConfig(cntxDir)

    console.log(&#39;Scanning directory...&#39;)
    // Now process directory AFTER we&#39;ve created all the necessary structure
    await new Promise((resolve) =&gt; setTimeout(resolve, 100)) // Small delay to ensure FS is ready
    const initialFiles = await processDirectory(dirHandle)

    console.log(`Found ${initialFiles.length} files, creating state...`)
    // Initialize state file with processed files
    await initializeStateFile(cntxDir, initialFiles)

    // Ensure pattern-ignore.ts is created with default patterns
    await savePatternIgnore(cntxDir, DEFAULT_BUNDLE_IGNORE)

    console.log(&#39;Initialization complete&#39;)
    return { cntxDir }
  } catch (error) {
    console.error(&#39;Error initializing project:&#39;, error)
    throw error
  }
}

async function createDirectoryStructure(cntxDir: FileSystemDirectoryHandle) {
  // Create all required directories
  await cntxDir.getDirectoryHandle(&#39;config&#39;, { create: true })
  const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;, {
    create: true,
  })
  // Explicitly create master directory with create: true
  await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true })
  // await cntxDir.getDirectoryHandle(&#39;sent&#39;, { create: true })
  await cntxDir.getDirectoryHandle(&#39;state&#39;, { create: true })
}

async function createInitialConfig(cntxDir: FileSystemDirectoryHandle) {
  const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)

  // Create bundle-ignore.ts
  const content = `// .cntx/config/bundle-ignore.ts
export default ${JSON.stringify(DEFAULT_BUNDLE_IGNORE, null, 2)} as const;
`
  const ignoreHandle = await configDir.getFileHandle(&#39;bundle-ignore.ts&#39;, {
    create: true,
  })
  const writable = await ignoreHandle.createWritable()
  await writable.write(content)
  await writable.close()

  // Create tags.ts with default tags
  const tagsContent = `// .cntx/config/tags.ts
export default ${JSON.stringify(DEFAULT_TAGS, null, 2)} as const;
`
  const tagsHandle = await configDir.getFileHandle(&#39;tags.ts&#39;, { create: true })
  const tagsWritable = await tagsHandle.createWritable()
  await tagsWritable.write(tagsContent)
  await tagsWritable.close()
}

async function initializeStateFile(
  cntxDir: FileSystemDirectoryHandle,
  initialFiles: WatchedFile[]
) {
  const stateDir = await cntxDir.getDirectoryHandle(&#39;state&#39;, { create: true })

  // Create initial state with processed files
  const initialState: WatchState = {
    lastAccessed: new Date().toISOString(),
    files: Object.fromEntries(
      initialFiles.map((file) =&gt; [
        file.path,
        {
          name: file.name,
          directory: file.directory,
          lastModified: file.lastModified.toISOString(),
          isChanged: false,
          isStaged: false,
          masterBundleId: undefined,
          tags: [],
        },
      ])
    ),
    masterBundle: null,
  }

  const stateHandle = await stateDir.getFileHandle(&#39;file.json&#39;, {
    create: true,
  })
  const writable = await stateHandle.createWritable()
  await writable.write(JSON.stringify(initialState, null, 2))
  await writable.close()
}

// CRITICAL FIX: Enhanced createMasterBundle function that preserves tags
import { buildDirectoryTree, getFileExtension } from &#39;./directory-tree&#39;
import { ProjectMetadata } from &#39;@/contexts/types&#39;

export async function createMasterBundle(
  files: WatchedFile[],
  cntxDir: FileSystemDirectoryHandle,
  ignorePatterns: string[] = [],
  existingBundleId?: string // Add this parameter for updates
): Promise&lt;{ success: boolean; error?: string; bundleId?: string }&gt; {
  try {
    console.log(&#39;🔄 Starting master bundle creation with tag preservation...&#39;)
    console.log(&#39;📋 Applying ignore patterns:&#39;, ignorePatterns)

    // CRITICAL: Load existing state WITHOUT filtering to preserve ALL tagged files
    const state = await loadState(cntxDir, []) // Empty patterns = no filtering
    console.log(
      &#39;📂 Loaded existing state for&#39;,
      Object.keys(state.files).length,
      &#39;files&#39;
    )

    const bundleId =
      existingBundleId ||
      `master-${new Date().toISOString().replace(/[:.]/g, &#39;-&#39;)}`
    const timestamp = new Date().toISOString()

    console.log(
      `🔄 ${
        existingBundleId ? &#39;Updating&#39; : &#39;Creating&#39;
      } master bundle: ${bundleId}`
    )

    // Filter files based on ignore patterns BUT preserve important tagged files
    const filteredFiles = files.filter((file) =&gt; {
      const isIgnored = ignorePatterns.some((pattern) =&gt; {
        if (pattern.startsWith(&#39;*.&#39;)) {
          const extension = pattern.slice(1)
          return file.path.toLowerCase().endsWith(extension.toLowerCase())
        }

        const normalizedPath = file.path.toLowerCase()
        const normalizedPattern = pattern.toLowerCase()

        return (
          normalizedPath === normalizedPattern ||
          normalizedPath.includes(`/${normalizedPattern}/`) ||
          normalizedPath.endsWith(`/${normalizedPattern}`) ||
          normalizedPath.startsWith(`${normalizedPattern}/`)
        )
      })

      // PRESERVE files that have tags, even if they match ignore patterns
      const hasImportantTags = file.tags &amp;&amp; file.tags.length &gt; 0
      const isStaged = file.isStaged
      const hasBundleId = file.masterBundleId

      if (isIgnored &amp;&amp; (hasImportantTags || isStaged || hasBundleId)) {
        console.log(
          `🏷️  Preserving tagged/important file despite ignore pattern: ${
            file.path
          } [tags: ${file.tags?.join(&#39;, &#39;) || &#39;none&#39;}]`
        )
        return true // Keep it despite ignore pattern
      }

      return !isIgnored
    })

    console.log(
      `📁 Processing ${filteredFiles.length} files for master bundle...`
    )

    // ENSURE we&#39;re using the most up-to-date tags from the state
    const filesWithPreservedTags = filteredFiles.map((file) =&gt; {
      const stateFile = state.files[file.path]
      if (stateFile &amp;&amp; stateFile.tags &amp;&amp; stateFile.tags.length &gt; 0) {
        console.log(`🏷️  Preserving tags for ${file.path}:`, stateFile.tags)
        return {
          ...file,
          tags: stateFile.tags, // Use tags from state
        }
      }
      return file
    })

    // Get the bundles directory
    const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;, {
      create: true,
    })

    // Create master directory
    let masterDir
    try {
      masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, {
        create: true,
      })
    } catch (error) {
      console.error(&#39;Failed to get/create master directory:&#39;, error)
      return {
        success: false,
        error: `Failed to create master directory: ${
          error instanceof Error ? error.message : String(error)
        }`,
      }
    }

    // Build directory tree
    const projectName = &#39;project&#39; // You could get this from directory name
    const { xmlTree, asciiTree } = buildDirectoryTree(
      filesWithPreservedTags,
      projectName
    )

    // Create document content for each file
    const documentStrings = await Promise.all(
      filesWithPreservedTags.map(async (file) =&gt; {
        try {
          if (!file.handle) {
            console.warn(`No file handle for ${file.path}`)
            return createDocumentString(
              file,
              &#39;&lt;!-- File content not available --&gt;&#39;
            )
          }

          const fileObj = await file.handle.getFile()
          const fileContent = await fileObj.text()
          return createDocumentString(file, fileContent)
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error)
          return createDocumentString(
            file,
            `&lt;!-- Error reading file: ${
              error instanceof Error ? error.message : &#39;unknown error&#39;
            } --&gt;`
          )
        }
      })
    )

    // Create the complete bundle content with enhanced format
    const bundleContent = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bundle id=&quot;${bundleId}&quot; created=&quot;${timestamp}&quot; fileCount=&quot;${
      filesWithPreservedTags.length
    }&quot;&gt;
  
  &lt;metadata&gt;
    &lt;projectName&gt;${projectName}&lt;/projectName&gt;
    &lt;totalFiles&gt;${filesWithPreservedTags.length}&lt;/totalFiles&gt;
    &lt;bundleType&gt;master&lt;/bundleType&gt;
    &lt;ignorePatterns&gt;
${ignorePatterns
  .map((pattern) =&gt; `      &lt;pattern&gt;${escapeXML(pattern)}&lt;/pattern&gt;`)
  .join(&#39;\n&#39;)}
    &lt;/ignorePatterns&gt;
  &lt;/metadata&gt;

  ${xmlTree}

  &lt;asciiTree&gt;
${asciiTree}
  &lt;/asciiTree&gt;

  &lt;documents&gt;
    
${documentStrings.join(&#39;\n\n&#39;)}
    
  &lt;/documents&gt;

&lt;/bundle&gt;`

    console.log(
      `📦 Master bundle content created (${bundleContent.length} bytes)`
    )

    // Save the bundle to a file
    try {
      const bundleHandle = await masterDir.getFileHandle(`${bundleId}.txt`, {
        create: true,
      })
      const writable = await bundleHandle.createWritable()
      await writable.write(bundleContent)
      await writable.close()
      console.log(`💾 Master bundle file written: ${bundleId}.txt`)
    } catch (error) {
      console.error(&#39;Error writing master bundle file:&#39;, error)
      return {
        success: false,
        error: `Failed to write master bundle file: ${
          error instanceof Error ? error.message : String(error)
        }`,
      }
    }

    // Create and save manifest with preserved tags
    const manifest: BundleManifest = {
      id: bundleId,
      created: timestamp,
      fileCount: filesWithPreservedTags.length,
      files: filesWithPreservedTags.map((file) =&gt; ({
        path: file.path,
        lastModified: file.lastModified.toISOString(),
        tags: file.tags || [], // CRITICAL: Include tags in manifest
      })),
    }

    try {
      await saveBundleManifest(bundlesDir, manifest, true)
      console.log(&#39;📋 Master bundle manifest saved with tags&#39;)
    } catch (error) {
      console.error(&#39;Error saving master bundle manifest:&#39;, error)
      return {
        success: false,
        error: `Failed to save master bundle manifest: ${
          error instanceof Error ? error.message : String(error)
        }`,
      }
    }

    // CRITICAL: Update state while preserving ALL existing tags
    filesWithPreservedTags.forEach((file) =&gt; {
      const existingFileState = state.files[file.path]

      if (existingFileState) {
        // PRESERVE all existing data, especially tags
        state.files[file.path] = {
          ...existingFileState, // Keep everything from existing state
          lastModified: file.lastModified.toISOString(),
          isChanged: false, // Reset changed status after bundling
          masterBundleId: bundleId,
          // CRITICAL: Keep existing tags, don&#39;t overwrite
          tags: existingFileState.tags || [],
        }
      } else {
        // New file entry
        state.files[file.path] = {
          name: file.name,
          directory: file.directory,
          lastModified: file.lastModified.toISOString(),
          isChanged: false,
          isStaged: false,
          masterBundleId: bundleId,
          tags: file.tags || [],
        }
      }
    })

    state.masterBundle = {
      id: bundleId,
      created: timestamp,
      fileCount: filesWithPreservedTags.length,
    }

    try {
      // CRITICAL: Save state without any filtering to preserve all tagged files
      await saveState(cntxDir, state, []) // Empty patterns to preserve everything
      console.log(&#39;✅ State updated with master bundle info and preserved tags&#39;)
    } catch (error) {
      console.error(&#39;Error saving state with master bundle info:&#39;, error)
      return {
        success: false,
        error: `Failed to update state: ${
          error instanceof Error ? error.message : String(error)
        }`,
      }
    }

    console.log(
      &#39;🎉 Master bundle creation completed successfully with tag preservation&#39;
    )
    return { success: true, bundleId }
  } catch (error) {
    console.error(&#39;❌ Error creating master bundle:&#39;, error)
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : &#39;Failed to create master bundle&#39;,
    }
  }
}

/**
 * Helper function to create document string with enhanced metadata including tags
 */
function createDocumentString(file: WatchedFile, content: string): string {
  const tagsString =
    file.tags &amp;&amp; file.tags.length &gt; 0 ? file.tags.join(&#39;,&#39;) : &#39;&#39;

  return `    &lt;document&gt;
      &lt;source&gt;${escapeXML(file.path)}&lt;/source&gt;
      &lt;tags&gt;${escapeXML(tagsString)}&lt;/tags&gt;
      &lt;metadata&gt;
        &lt;size&gt;${content.length}&lt;/size&gt;
        &lt;lastModified&gt;${file.lastModified.toISOString()}&lt;/lastModified&gt;
        &lt;extension&gt;${getFileExtension(file.path)}&lt;/extension&gt;
        &lt;directory&gt;${escapeXML(file.directory)}&lt;/directory&gt;
      &lt;/metadata&gt;
      &lt;content&gt;${escapeXML(content)}&lt;/content&gt;
    &lt;/document&gt;`
}

/**
 * Escapes XML special characters
 */
function escapeXML(str: string): string {
  return str
    .replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;)
    .replace(/&#39;/g, &#39;&amp;#39;&#39;)
}

export async function loadBundleIgnore(
  cntxDir: FileSystemDirectoryHandle
): Promise&lt;string[]&gt; {
  try {
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    const ignoreHandle = await configDir.getFileHandle(&#39;bundle-ignore.ts&#39;)
    const file = await ignoreHandle.getFile()
    const content = await file.text()

    const match = content.match(/\[([\s\S]*?)\]/)
    if (!match) {
      console.log(&#39;No ignore patterns found, using defaults&#39;)
      return DEFAULT_BUNDLE_IGNORE
    }

    const arrayContent = match[1]
      .split(&#39;,&#39;)
      .map((item) =&gt; item.trim().replace(/[&quot;&#39;]/g, &#39;&#39;))
      .filter((item) =&gt; item.length &gt; 0)

    return arrayContent
  } catch (error) {
    console.error(&#39;Error loading bundle ignore patterns:&#39;, error)
    console.log(&#39;Using default ignore patterns:&#39;, DEFAULT_BUNDLE_IGNORE)
    return DEFAULT_BUNDLE_IGNORE
  }
}

// Improved loadTagsConfig function for src/utils/project-utils.ts

export async function loadTagsConfig(
  cntxDir: FileSystemDirectoryHandle
): Promise&lt;TagsConfig&gt; {
  console.log(&#39;🏷️  loadTagsConfig: Starting to load tags from config...&#39;)

  try {
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    console.log(&#39;🏷️  loadTagsConfig: Found config directory&#39;)

    const tagsHandle = await configDir.getFileHandle(&#39;tags.ts&#39;)
    console.log(&#39;🏷️  loadTagsConfig: Found tags.ts file&#39;)

    const file = await tagsHandle.getFile()
    const content = await file.text()

    console.log(
      &#39;🏷️  loadTagsConfig: Read file content, length:&#39;,
      content.length
    )
    console.log(
      &#39;🏷️  loadTagsConfig: Content preview:&#39;,
      content.substring(0, 200) + &#39;...&#39;
    )

    // More robust regex to match different export formats
    const patterns = [
      /export\s+default\s*({[\s\S]*?})\s*as\s+const/, // export default {...} as const
      /default\s*:\s*({[\s\S]*?}),?\s*}\s*as\s+const/, // default: {...} } as const
      /default\s*({[\s\S]*?})\s*as\s+const/, // default {...} as const
      /=\s*({[\s\S]*?})\s*as\s+const/, // = {...} as const
    ]

    let match = null
    let usedPattern = -1

    for (let i = 0; i &lt; patterns.length; i++) {
      match = content.match(patterns[i])
      if (match) {
        usedPattern = i
        console.log(`🏷️  loadTagsConfig: Matched pattern ${i}:`, patterns[i])
        break
      }
    }

    if (!match) {
      console.warn(&#39;🏷️  loadTagsConfig: No matching pattern found in tags.ts&#39;)
      console.log(&#39;🏷️  loadTagsConfig: File content:&#39;, content)
      console.warn(&#39;🏷️  loadTagsConfig: Returning DEFAULT_TAGS as fallback&#39;)
      return DEFAULT_TAGS
    }

    console.log(
      &#39;🏷️  loadTagsConfig: Extracted object string:&#39;,
      match[1].substring(0, 100) + &#39;...&#39;
    )

    try {
      // Safer parsing approach
      const objectString = match[1]

      // Clean up the object string for safer eval
      const cleanedString = objectString
        .replace(/\/\/.*$/gm, &#39;&#39;) // Remove single-line comments
        .replace(/\/\*[\s\S]*?\*\//g, &#39;&#39;) // Remove multi-line comments

      console.log(&#39;🏷️  loadTagsConfig: Attempting to parse object...&#39;)
      const parsedTags = eval(&#39;(&#39; + cleanedString + &#39;)&#39;)

      console.log(
        &#39;🏷️  loadTagsConfig: Successfully parsed tags:&#39;,
        Object.keys(parsedTags)
      )
      console.log(
        &#39;🏷️  loadTagsConfig: Tag count:&#39;,
        Object.keys(parsedTags).length
      )

      // Merge with DEFAULT_TAGS to ensure we have all standard tags
      const mergedTags = {
        ...DEFAULT_TAGS,
        ...parsedTags,
      }

      console.log(
        &#39;🏷️  loadTagsConfig: Final merged tag count:&#39;,
        Object.keys(mergedTags).length
      )
      return mergedTags
    } catch (parseError) {
      console.error(
        &#39;🏷️  loadTagsConfig: Error parsing tags object:&#39;,
        parseError
      )
      console.log(&#39;🏷️  loadTagsConfig: Problematic object string:&#39;, match[1])
      console.warn(
        &#39;🏷️  loadTagsConfig: Returning DEFAULT_TAGS due to parse error&#39;
      )
      return DEFAULT_TAGS
    }
  } catch (error) {
    console.error(&#39;🏷️  loadTagsConfig: Error loading tags config:&#39;, error)

    if (error.name === &#39;NotFoundError&#39;) {
      console.log(
        &#39;🏷️  loadTagsConfig: tags.ts file not found, this is normal for new projects&#39;
      )
    } else {
      console.error(&#39;🏷️  loadTagsConfig: Unexpected error:&#39;, error)
    }

    console.log(&#39;🏷️  loadTagsConfig: Returning DEFAULT_TAGS as fallback&#39;)
    return DEFAULT_TAGS
  }
}

// Also improve saveTagsConfig to ensure proper formatting
export async function saveTagsConfig(
  cntxDir: FileSystemDirectoryHandle,
  tags: TagsConfig
) {
  try {
    console.log(&#39;🏷️  saveTagsConfig: Saving tags:&#39;, Object.keys(tags))

    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    const tagsHandle = await configDir.getFileHandle(&#39;tags.ts&#39;, {
      create: true,
    })
    const writable = await tagsHandle.createWritable()

    // Create properly formatted content
    const content = `// .cntx/config/tags.ts
// Auto-generated tags configuration
export default ${JSON.stringify(tags, null, 2)} as const;
`

    console.log(
      &#39;🏷️  saveTagsConfig: Writing content with length:&#39;,
      content.length
    )
    await writable.write(content)
    await writable.close()

    console.log(&#39;✅ saveTagsConfig: Successfully saved tags to tags.ts&#39;)
  } catch (error) {
    console.error(&#39;🏷️  saveTagsConfig: Error saving tags config:&#39;, error)
    throw error
  }
}

export async function loadPatternIgnore(
  cntxDir: FileSystemDirectoryHandle
): Promise&lt;string[]&gt; {
  try {
    // First try to get the config directory
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    console.log(&#39;Found config directory, looking for pattern-ignore.ts&#39;)

    try {
      // Try to load pattern-ignore.ts first (this should be the user&#39;s patterns)
      const patternIgnoreHandle = await configDir.getFileHandle(
        &#39;pattern-ignore.ts&#39;
      )
      const file = await patternIgnoreHandle.getFile()
      const content = await file.text()
      console.log(&#39;Loaded pattern-ignore.ts content:&#39;, content)

      // Use a simple regex to extract the pattern array
      const match = content.match(/\[([\s\S]*?)\]/)
      if (match &amp;&amp; match[1]) {
        const patterns = match[1]
          .split(&#39;,&#39;)
          .map((line) =&gt; line.trim().replace(/[&#39;&quot;,]/g, &#39;&#39;))
          .filter((item) =&gt; item.length &gt; 0)

        console.log(
          &#39;Successfully parsed patterns from pattern-ignore.ts:&#39;,
          patterns
        )
        return patterns
      }

      console.log(
        &#39;No patterns found in pattern-ignore.ts, falling back to defaults&#39;
      )
      return DEFAULT_BUNDLE_IGNORE
    } catch (e) {
      console.error(&#39;Error loading pattern-ignore.ts:&#39;, e)
      return DEFAULT_BUNDLE_IGNORE
    }
  } catch (error) {
    console.error(&#39;Error in loadPatternIgnore:&#39;, error)
    return DEFAULT_BUNDLE_IGNORE
  }
}

export async function savePatternIgnore(
  cntxDir: FileSystemDirectoryHandle,
  patterns: string[]
): Promise&lt;void&gt; {
  try {
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    console.log(&#39;Saving patterns to pattern-ignore.ts:&#39;, patterns)

    const content = `// .cntx/config/pattern-ignore.ts
export default [
  ${patterns.map((p) =&gt; `&#39;${p}&#39;`).join(&#39;,\n  &#39;)}
] as const;
`

    const ignoreHandle = await configDir.getFileHandle(&#39;pattern-ignore.ts&#39;, {
      create: true,
    })
    const writable = await ignoreHandle.createWritable()
    await writable.write(content)
    await writable.close()

    console.log(&#39;Successfully saved patterns to pattern-ignore.ts&#39;)
  } catch (error) {
    console.error(&#39;Error saving pattern ignore:&#39;, error)
    throw error
  }
}

// Project metadata management
export async function loadProjectMetadata(
  cntxDir: FileSystemDirectoryHandle
): Promise&lt;ProjectMetadata&gt; {
  try {
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    const metadataHandle = await configDir.getFileHandle(
      &#39;project-metadata.json&#39;
    )
    const file = await metadataHandle.getFile()
    const content = await file.text()

    const metadata = JSON.parse(content)
    console.log(&#39;📋 Loaded project metadata:&#39;, metadata)
    return metadata
  } catch (error) {
    console.log(&#39;📋 No project metadata found, returning defaults&#39;)
    return {
      name: &#39;Untitled Project&#39;,
      description: &#39;&#39;,
      version: &#39;1.0.0&#39;,
      author: &#39;&#39;,
      lastUpdated: new Date().toISOString(),
    }
  }
}

export async function saveProjectMetadata(
  cntxDir: FileSystemDirectoryHandle,
  metadata: ProjectMetadata
): Promise&lt;void&gt; {
  try {
    const configDir = await cntxDir.getDirectoryHandle(&#39;config&#39;)
    const metadataHandle = await configDir.getFileHandle(
      &#39;project-metadata.json&#39;,
      {
        create: true,
      }
    )

    const content = JSON.stringify(metadata, null, 2)
    const writable = await metadataHandle.createWritable()
    await writable.write(content)
    await writable.close()

    console.log(&#39;📋 Saved project metadata&#39;)
  } catch (error) {
    console.error(&#39;Error saving project metadata:&#39;, error)
    throw error
  }
}
</content>
    </document>

    <document>
      <source>src/utils/file-utils.ts</source>
      <tags>business-logic,file-operations</tags>
      <metadata>
        <size>4518</size>
        <lastModified>2025-05-24T03:55:53.587Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/file-utils.ts
import { WatchedFile } from &#39;@/types/types&#39;
import { DEFAULT_BUNDLE_IGNORE } from &#39;@/constants&#39;

// src/utils/file-utils.ts
export function normalizePath(path: string): string {
  return path.replace(/\\/g, &#39;/&#39;)
}

export function shouldIgnorePath(
  path: string,
  config: { ignore: string[] },
  isDirectory: boolean = false
): boolean {
  const normalizedPath = path.toLowerCase().replace(/\\/g, &#39;/&#39;)

  // Always ignore .cntx directory and its contents
  if (normalizedPath === &#39;.cntx&#39; || normalizedPath.startsWith(&#39;.cntx/&#39;)) {
    return true
  }

  // Cache the normalized patterns for better performance
  const normalizedPatterns = config.ignore.map((pattern) =&gt; ({
    original: pattern,
    normalized: pattern.toLowerCase().replace(/^\.\//, &#39;&#39;),
  }))

  return normalizedPatterns.some(({ original, normalized }) =&gt; {
    // Handle wildcard file extension patterns (e.g., *.js)
    if (original.startsWith(&#39;*.&#39;)) {
      const extension = normalized.slice(1) // Keep the dot
      const result = normalizedPath.endsWith(extension)
      if (result) {
        // console.log(`Path &quot;${path}&quot; matches extension pattern &quot;${original}&quot;`)
      }
      return result
    }

    // Handle directory matching
    if (isDirectory) {
      const result =
        normalizedPath === normalized ||
        normalizedPath.startsWith(normalized + &#39;/&#39;) ||
        normalizedPath.endsWith(&#39;/&#39; + normalized) ||
        normalizedPath.includes(&#39;/&#39; + normalized + &#39;/&#39;)

      if (result) {
        console.log(`Directory &quot;${path}&quot; matches pattern &quot;${original}&quot;`)
      }
      return result
    }

    // Handle exact file matches
    const result =
      normalizedPath === normalized || normalizedPath.endsWith(&#39;/&#39; + normalized)

    if (result) {
      console.log(`File &quot;${path}&quot; matches pattern &quot;${original}&quot;`)
    }
    return result
  })
}

export function getPathParts(fullPath: string) {
  const normalizedPath = normalizePath(fullPath)
  const parts = normalizedPath.split(&#39;/&#39;)
  const name = parts.pop() || &#39;&#39;
  const directory = parts.length &gt; 0 ? parts.join(&#39;/&#39;) : &#39;Root&#39;

  return {
    name,
    directory,
    path: normalizedPath,
  }
}

export function getAllDirectories(paths: string[]): string[] {
  const directories = new Set&lt;string&gt;()
  directories.add(&#39;Root&#39;)

  paths.forEach((path) =&gt; {
    const parts = normalizePath(path).split(&#39;/&#39;)
    // Remove the file name
    parts.pop()

    // Add each level of directory
    let currentPath = &#39;&#39;
    parts.forEach((part) =&gt; {
      currentPath = currentPath ? `${currentPath}/${part}` : part
      directories.add(currentPath)
    })
  })

  return Array.from(directories).sort((a, b) =&gt; a.localeCompare(b))
}

export async function processDirectory(
  dirHandle: FileSystemDirectoryHandle,
  relativePath: string = &#39;&#39;,
  ignorePatterns: string[] = []
): Promise&lt;WatchedFile[]&gt; {
  const files: WatchedFile[] = []

  // Ensure we have patterns to use
  const patternsToUse =
    Array.isArray(ignorePatterns) &amp;&amp; ignorePatterns.length &gt; 0
      ? ignorePatterns
      : DEFAULT_BUNDLE_IGNORE

  // console.log(
  //   `Processing directory &quot;${relativePath}&quot; with patterns:`,
  //   patternsToUse
  // )

  try {
    for await (const entry of dirHandle.values()) {
      const entryPath = relativePath
        ? `${relativePath}/${entry.name}`
        : entry.name

      // Check if path should be ignored
      if (
        shouldIgnorePath(
          entryPath,
          { ignore: patternsToUse },
          entry.kind === &#39;directory&#39;
        )
      ) {
        // console.log(`Ignoring path: ${entryPath}`)
        continue
      }

      if (entry.kind === &#39;file&#39;) {
        const handle = entry
        const file = await handle.getFile()
        const { name, directory, path } = getPathParts(entryPath)

        files.push({
          path,
          name,
          directory,
          lastModified: new Date(file.lastModified),
          isChanged: false,
          isStaged: false,
          handle,
          tags: [],
        })
      } else if (entry.kind === &#39;directory&#39;) {
        // Only process subdirectory if it&#39;s not ignored
        const subFiles = await processDirectory(
          entry as FileSystemDirectoryHandle,
          entryPath,
          patternsToUse
        )
        files.push(...subFiles)
      }
    }
  } catch (error) {
    console.error(&#39;Error processing directory:&#39;, error)
    console.error(&#39;Path:&#39;, relativePath)
    console.error(&#39;Patterns:&#39;, patternsToUse)
  }

  return files
}
</content>
    </document>

    <document>
      <source>src/utils/bundle-utils.ts</source>
      <tags>business-logic,file-operations</tags>
      <metadata>
        <size>6874</size>
        <lastModified>2025-05-22T00:43:04.234Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/bundle-utils.ts
import type { Bundle, BundleManifest, WatchedFile } from &#39;@/types/types&#39;

export type BundleAnalysis = {
  bundle: Bundle
  staleFiles: string[] // List of file paths that have changed since bundle creation
  freshFiles: string[] // List of file paths that haven&#39;t changed since bundle creation
  missingFiles: string[] // List of file paths in bundle that no longer exist
  tags: Record&lt;string, number&gt; // Count of files with each tag
  staleness: number // Percentage of files that are stale (0-100)
  manifest?: BundleManifest // Original manifest if available
}

/**
 * Analyzes a bundle to determine its staleness, tags, and other metadata
 */
export async function analyzeBundleHealth(
  bundle: Bundle,
  manifest: BundleManifest | null,
  watchedFiles: WatchedFile[]
): Promise&lt;BundleAnalysis&gt; {
  // Default values if we can&#39;t find a manifest
  const staleFiles: string[] = []
  const freshFiles: string[] = []
  const missingFiles: string[] = []
  const tags: Record&lt;string, number&gt; = {}

  // If we don&#39;t have a manifest, we can&#39;t determine staleness accurately
  if (!manifest) {
    return {
      bundle,
      staleFiles,
      freshFiles,
      missingFiles,
      tags,
      staleness: 0,
      manifest: null,
    }
  }

  // Find which files in the bundle are stale
  manifest.files.forEach((manifestFile) =&gt; {
    const path = manifestFile.path
    const watchedFile = watchedFiles.find((f) =&gt; f.path === path)

    // If file exists in watched files
    if (watchedFile) {
      // Get file tags from the manifest or from current watchedFile
      const fileTags = manifestFile.tags || watchedFile.tags || []

      // Count tags
      if (fileTags.length &gt; 0) {
        fileTags.forEach((tag) =&gt; {
          tags[tag] = (tags[tag] || 0) + 1
        })
      }

      // Check if file is newer than the manifest file
      const manifestTimestamp = new Date(manifestFile.lastModified).getTime()
      const fileTimestamp = watchedFile.lastModified.getTime()

      if (fileTimestamp &gt; manifestTimestamp) {
        staleFiles.push(path)
      } else {
        freshFiles.push(path)
      }
    } else {
      // File in manifest but not in watched files (might have been deleted)
      missingFiles.push(path)

      // Count tags from manifest for missing files too
      if (manifestFile.tags &amp;&amp; manifestFile.tags.length &gt; 0) {
        manifestFile.tags.forEach((tag) =&gt; {
          tags[tag] = (tags[tag] || 0) + 1
        })
      }
    }
  })

  // Calculate staleness percentage
  const totalTrackedFiles = staleFiles.length + freshFiles.length
  const staleness =
    totalTrackedFiles &gt; 0
      ? Math.round((staleFiles.length / totalTrackedFiles) * 100)
      : 0

  return {
    bundle,
    staleFiles,
    freshFiles,
    missingFiles,
    tags,
    staleness,
    manifest,
  }
}

/**
 * Get a color for staleness based on percentage
 */
export function getStalenessColor(staleness: number): string {
  if (staleness &lt;= 20) return &#39;green&#39;
  if (staleness &lt;= 50) return &#39;yellow&#39;
  if (staleness &lt;= 80) return &#39;orange&#39;
  return &#39;red&#39;
}

/**
 * Sort tags by count in descending order
 */
export function getSortedTags(
  tags: Record&lt;string, number&gt;
): [string, number][] {
  return Object.entries(tags).sort((a, b) =&gt; b[1] - a[1])
}

/**
 * Load a manifest for a bundle
 */
export async function loadBundleManifest(
  cntxDir: FileSystemDirectoryHandle,
  bundleName: string
): Promise&lt;BundleManifest | null&gt; {
  try {
    console.log(`Attempting to load manifest for ${bundleName}...`)
    const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;)

    // Extract bundle ID from the name
    // Bundle name format is usually bundleId.txt
    const bundleId = bundleName.replace(/\.txt$/, &#39;&#39;)

    // Master bundles are in a subdirectory
    let manifestFile
    let manifestName = `${bundleId}-manifest.json`

    if (bundleName.startsWith(&#39;master-&#39;)) {
      try {
        console.log(`Looking for master manifest: ${manifestName}`)
        const masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, {
          create: true,
        })
        manifestFile = await masterDir.getFileHandle(manifestName)
        console.log(&#39;Master manifest file found&#39;)
      } catch (error) {
        console.error(
          `Error accessing master manifest for ${bundleName}:`,
          error
        )
        // Try alternate manifest name formatting
        manifestName = bundleName.replace(&#39;.txt&#39;, &#39;-manifest.json&#39;)
        try {
          const masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, {
            create: true,
          })
          manifestFile = await masterDir.getFileHandle(manifestName)
          console.log(
            `Found master manifest with alternate name: ${manifestName}`
          )
        } catch (altError) {
          console.error(
            `Also failed with alternate master manifest name:`,
            altError
          )
          return null
        }
      }
    } else {
      // Regular bundles have their manifest in the bundles directory
      try {
        console.log(`Looking for regular manifest: ${manifestName}`)
        manifestFile = await bundlesDir.getFileHandle(manifestName)
        console.log(&#39;Regular manifest file found&#39;)
      } catch (error) {
        console.error(
          `Error accessing regular manifest for ${bundleName}:`,
          error
        )
        // Try alternate manifest name formatting
        manifestName = bundleName.replace(&#39;.txt&#39;, &#39;-manifest.json&#39;)
        try {
          manifestFile = await bundlesDir.getFileHandle(manifestName)
          console.log(
            `Found regular manifest with alternate name: ${manifestName}`
          )
        } catch (altError) {
          console.error(
            `Also failed with alternate regular manifest name:`,
            altError
          )
          return null
        }
      }
    }

    if (!manifestFile) {
      console.error(`No manifest file found for ${bundleName}`)
      return null
    }

    // Load and parse the manifest content
    try {
      const file = await manifestFile.getFile()
      const content = await file.text()
      console.log(`Successfully loaded manifest content for ${bundleName}`)

      try {
        const manifest = JSON.parse(content)
        console.log(`Successfully parsed manifest for ${bundleName}`)
        return manifest
      } catch (parseError) {
        console.error(
          `Error parsing manifest content for ${bundleName}:`,
          parseError
        )
        console.error(&#39;Manifest content:&#39;, content.substring(0, 200) + &#39;...&#39;)
        return null
      }
    } catch (fileError) {
      console.error(`Error reading manifest file for ${bundleName}:`, fileError)
      return null
    }
  } catch (error) {
    console.error(&#39;Error in loadBundleManifest:&#39;, error)
    return null
  }
}
</content>
    </document>

    <document>
      <source>src/utils/directory-tree.ts</source>
      <tags>business-logic,ui-components</tags>
      <metadata>
        <size>6013</size>
        <lastModified>2025-05-22T00:43:04.234Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/directory-tree.ts
import type { WatchedFile } from &#39;@/types/types&#39;

interface TreeNode {
  name: string
  path: string
  isDirectory: boolean
  children: TreeNode[]
  file?: WatchedFile
}

/**
 * Builds both XML and ASCII representations of the directory tree
 */
export function buildDirectoryTree(files: WatchedFile[], projectName?: string) {
  const tree = buildTreeStructure(files)

  return {
    xmlTree: buildXMLTree(tree),
    asciiTree: buildASCIITree(tree, files.length, projectName),
  }
}

/**
 * Creates a hierarchical tree structure from flat file list
 */
function buildTreeStructure(files: WatchedFile[]): TreeNode {
  const root: TreeNode = {
    name: &#39;root&#39;,
    path: &#39;&#39;,
    isDirectory: true,
    children: [],
  }

  // Sort files by path for consistent ordering
  const sortedFiles = [...files].sort((a, b) =&gt; a.path.localeCompare(b.path))

  sortedFiles.forEach((file) =&gt; {
    const pathParts = file.path.split(&#39;/&#39;)
    let currentNode = root

    // Navigate/create directory structure
    for (let i = 0; i &lt; pathParts.length - 1; i++) {
      const dirName = pathParts[i]
      const dirPath = pathParts.slice(0, i + 1).join(&#39;/&#39;)

      let dirNode = currentNode.children.find(
        (child) =&gt; child.isDirectory &amp;&amp; child.name === dirName
      )

      if (!dirNode) {
        dirNode = {
          name: dirName,
          path: dirPath,
          isDirectory: true,
          children: [],
        }
        currentNode.children.push(dirNode)
      }

      currentNode = dirNode
    }

    // Add the file
    const fileName = pathParts[pathParts.length - 1]
    currentNode.children.push({
      name: fileName,
      path: file.path,
      isDirectory: false,
      children: [],
      file: file,
    })
  })

  // Sort children: directories first, then files, both alphabetically
  sortTreeNode(root)

  return root
}

/**
 * Recursively sorts tree nodes
 */
function sortTreeNode(node: TreeNode) {
  node.children.sort((a, b) =&gt; {
    // Directories first
    if (a.isDirectory &amp;&amp; !b.isDirectory) return -1
    if (!a.isDirectory &amp;&amp; b.isDirectory) return 1

    // Then alphabetically
    return a.name.localeCompare(b.name)
  })

  // Recursively sort children
  node.children.forEach((child) =&gt; {
    if (child.isDirectory) {
      sortTreeNode(child)
    }
  })
}

/**
 * Generates XML tree structure
 */
function buildXMLTree(tree: TreeNode): string {
  const buildXMLNode = (node: TreeNode, depth: number = 0): string =&gt; {
    const indent = &#39;  &#39;.repeat(depth)

    if (node.isDirectory &amp;&amp; node.name !== &#39;root&#39;) {
      const childrenXML = node.children
        .map((child) =&gt; buildXMLNode(child, depth + 1))
        .join(&#39;\n&#39;)

      return `${indent}&lt;directory name=&quot;${escapeXML(
        node.name
      )}&quot; path=&quot;${escapeXML(node.path)}&quot;&gt;
${childrenXML}
${indent}&lt;/directory&gt;`
    } else if (!node.isDirectory &amp;&amp; node.file) {
      const file = node.file
      const tags = file.tags &amp;&amp; file.tags.length &gt; 0 ? file.tags.join(&#39;,&#39;) : &#39;&#39;

      return `${indent}&lt;file name=&quot;${escapeXML(node.name)}&quot; path=&quot;${escapeXML(
        node.path
      )}&quot; size=&quot;${getFileSize(
        file
      )}&quot; lastModified=&quot;${file.lastModified.toISOString()}&quot;&gt;
${indent}  &lt;tags&gt;${escapeXML(tags)}&lt;/tags&gt;
${indent}&lt;/file&gt;`
    } else {
      // Root node - just return children
      return node.children.map((child) =&gt; buildXMLNode(child, depth)).join(&#39;\n&#39;)
    }
  }

  return `&lt;directoryTree&gt;
${buildXMLNode(tree, 1)}
&lt;/directoryTree&gt;`
}

/**
 * Generates ASCII tree structure
 */
function buildASCIITree(
  tree: TreeNode,
  totalFiles: number,
  projectName?: string
): string {
  const lines: string[] = []

  // Add project header
  if (projectName) {
    lines.push(`${projectName}/`)
  }

  const buildASCIINode = (
    node: TreeNode,
    prefix: string = &#39;&#39;,
    isLast: boolean = true
  ) =&gt; {
    if (node.name === &#39;root&#39;) {
      // Root node - just process children
      node.children.forEach((child, index) =&gt; {
        const isLastChild = index === node.children.length - 1
        buildASCIINode(child, &#39;&#39;, isLastChild)
      })
      return
    }

    // Create the current line
    const connector = isLast ? &#39;└── &#39; : &#39;├── &#39;
    const tagsStr =
      node.file?.tags &amp;&amp; node.file.tags.length &gt; 0
        ? ` [${node.file.tags.join(&#39;,&#39;)}]`
        : &#39;&#39;

    const displayName = node.isDirectory ? `${node.name}/` : node.name
    lines.push(`${prefix}${connector}${displayName}${tagsStr}`)

    // Process children if it&#39;s a directory
    if (node.isDirectory &amp;&amp; node.children.length &gt; 0) {
      const newPrefix = prefix + (isLast ? &#39;    &#39; : &#39;│   &#39;)

      node.children.forEach((child, index) =&gt; {
        const isLastChild = index === node.children.length - 1
        buildASCIINode(child, newPrefix, isLastChild)
      })
    }
  }

  buildASCIINode(tree)

  // Add summary
  const dirCount = countDirectories(tree)
  lines.push(&#39;&#39;)
  lines.push(`${totalFiles} files, ${dirCount} directories`)

  return lines.join(&#39;\n&#39;)
}

/**
 * Counts directories in the tree
 */
function countDirectories(node: TreeNode): number {
  let count = 0

  if (node.isDirectory &amp;&amp; node.name !== &#39;root&#39;) {
    count = 1
  }

  node.children.forEach((child) =&gt; {
    count += countDirectories(child)
  })

  return count
}

/**
 * Gets file size (placeholder - you might want to get actual file size)
 */
function getFileSize(file: WatchedFile): number {
  // For now, return 0 - you could enhance this to get actual file size
  // by reading the file content length or using file.handle if available
  return 0
}

/**
 * Escapes XML special characters
 */
function escapeXML(str: string): string {
  return str
    .replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;)
    .replace(/&#39;/g, &#39;&amp;#39;&#39;)
}

/**
 * Helper function to get file extension
 */
export function getFileExtension(filePath: string): string {
  const lastDot = filePath.lastIndexOf(&#39;.&#39;)
  return lastDot === -1 ? &#39;&#39; : filePath.substring(lastDot + 1)
}
</content>
    </document>

    <document>
      <source>src/utils/cursor-rules.ts</source>
      <tags>business-logic,external-apis</tags>
      <metadata>
        <size>5212</size>
        <lastModified>2025-05-26T20:42:29.289Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/cursor-rules.ts
import type { FileSystemDirectoryHandle } from &#39;@/types/types&#39;

export interface CursorRules {
  rules: string[]
  patterns?: string[]
  preferences?: Record&lt;string, any&gt;
  source?: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39; | &#39;created-new&#39;
}

// UPDATE: loadCursorRules to return simpler structure
export async function loadCursorRules(
  dirHandle: FileSystemDirectoryHandle
): Promise&lt;{ content: string; location: string; filePath: string } | null&gt; {
  console.log(&#39;🔍 Looking for Cursor rules...&#39;)

  // Try .cursorrules first
  try {
    const cursorRulesHandle = await dirHandle.getFileHandle(&#39;.cursorrules&#39;)
    const file = await cursorRulesHandle.getFile()
    const content = await file.text()

    return {
      content,
      location: &#39;cursorrules-file&#39;,
      filePath: &#39;.cursorrules&#39;,
    }
  } catch (error) {
    console.log(&#39;No .cursorrules file found, checking .cursor directory...&#39;)
  }

  // Try .cursor/rules
  try {
    const cursorDir = await dirHandle.getDirectoryHandle(&#39;.cursor&#39;)
    const rulesHandle = await cursorDir.getFileHandle(&#39;rules&#39;)
    const file = await rulesHandle.getFile()
    const content = await file.text()

    return {
      content,
      location: &#39;cursor-directory&#39;,
      filePath: &#39;.cursor/rules&#39;,
    }
  } catch (error) {
    console.log(&#39;No .cursor/rules file found&#39;)
  }

  console.log(&#39;ℹ️ No existing Cursor rules found&#39;)
  return null
}

// UPDATE: saveCursorRules to save to detected location
export async function saveCursorRules(
  dirHandle: FileSystemDirectoryHandle,
  content: string, // Just save raw content, not structured rules
  preferredLocation?: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39;
): Promise&lt;void&gt; {
  console.log(&#39;💾 Saving Cursor rules...&#39;)

  // Determine where to save based on existing files or preference
  const location = await determineRulesLocation(dirHandle, preferredLocation)

  if (location === &#39;cursorrules-file&#39;) {
    const cursorRulesHandle = await dirHandle.getFileHandle(&#39;.cursorrules&#39;, {
      create: true,
    })
    const writable = await cursorRulesHandle.createWritable()
    await writable.write(content)
    await writable.close()
  } else {
    // Save to .cursor/rules
    const cursorDir = await dirHandle.getDirectoryHandle(&#39;.cursor&#39;, {
      create: true,
    })
    const rulesHandle = await cursorDir.getFileHandle(&#39;rules&#39;, { create: true })
    const writable = await rulesHandle.createWritable()
    await writable.write(content)
    await writable.close()
  }

  console.log(`✅ Cursor rules saved to ${location}`)
}

// Helper functions
async function fileExists(
  dirHandle: FileSystemDirectoryHandle,
  fileName: string
): Promise&lt;boolean&gt; {
  try {
    await dirHandle.getFileHandle(fileName)
    return true
  } catch {
    return false
  }
}

async function dirExists(
  dirHandle: FileSystemDirectoryHandle,
  dirName: string
): Promise&lt;boolean&gt; {
  try {
    await dirHandle.getDirectoryHandle(dirName)
    return true
  } catch {
    return false
  }
}

// NEW: Determine best location for rules
async function determineRulesLocation(
  dirHandle: FileSystemDirectoryHandle,
  preference?: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39;
): Promise&lt;&#39;cursorrules-file&#39; | &#39;cursor-directory&#39;&gt; {
  // Check what already exists
  const hasRulesFile = await fileExists(dirHandle, &#39;.cursorrules&#39;)
  const hasCursorDir = await dirExists(dirHandle, &#39;.cursor&#39;)

  // If user has preference and nothing exists, use preference
  if (!hasRulesFile &amp;&amp; !hasCursorDir &amp;&amp; preference) {
    return preference
  }

  // Use existing format
  if (hasRulesFile) return &#39;cursorrules-file&#39;
  if (hasCursorDir) return &#39;cursor-directory&#39;

  // Default to .cursor/rules for new projects
  return &#39;cursor-directory&#39;
}

/**
 * Check if there are existing Cursor rules in the project
 */
export async function hasCursorRules(
  dirHandle: FileSystemDirectoryHandle
): Promise&lt;boolean&gt; {
  try {
    // Check for .cursorrules file
    await dirHandle.getFileHandle(&#39;.cursorrules&#39;)
    return true
  } catch {
    try {
      // Check for .cursor directory
      await dirHandle.getDirectoryHandle(&#39;.cursor&#39;)
      return true
    } catch {
      return false
    }
  }
}

/**
 * Create example Cursor rules for new projects
 */
export function getExampleCursorRules(): CursorRules {
  return {
    rules: [
      &#39;# Project Coding Standards&#39;,
      &#39;&#39;,
      &#39;## General Guidelines&#39;,
      &#39;- Use TypeScript for all new code&#39;,
      &#39;- Follow existing code style and patterns&#39;,
      &#39;- Write meaningful commit messages&#39;,
      &#39;- Add comments for complex logic&#39;,
      &#39;&#39;,
      &#39;## React/Frontend&#39;,
      &#39;- Use functional components with hooks&#39;,
      &#39;- Prefer composition over inheritance&#39;,
      &#39;- Use Tailwind CSS for styling&#39;,
      &#39;- Follow accessible design principles&#39;,
      &#39;&#39;,
      &#39;## File Organization&#39;,
      &#39;- Use semantic file naming&#39;,
      &#39;- Group related files in directories&#39;,
      &#39;- Export from index files when appropriate&#39;,
      &#39;&#39;,
      &#39;## Testing&#39;,
      &#39;- Write tests for new features&#39;,
      &#39;- Test edge cases and error conditions&#39;,
      &#39;- Keep tests focused and readable&#39;,
    ],
    patterns: [],
    preferences: {},
    source: &#39;created-new&#39;,
  }
}
</content>
    </document>

    <document>
      <source>src/utils/file-state.ts</source>
      <tags>business-logic,file-operations</tags>
      <metadata>
        <size>18863</size>
        <lastModified>2025-05-27T01:22:50.035Z</lastModified>
        <extension>ts</extension>
        <directory>src/utils</directory>
      </metadata>
      <content>// src/utils/file-state.ts - ENHANCED VERSION with bulletproof tag preservation
import { BundleManifest, WatchedFile, WatchState } from &#39;@/types/types&#39;
import { shouldIgnorePath } from &#39;./file-utils&#39;

export const DEFAULT_STATE: WatchState = {
  lastAccessed: new Date().toISOString(),
  files: {},
  masterBundle: null,
}

// ENHANCED: loadState should ALWAYS preserve tags and never filter existing state
export async function loadState(
  cntxDir: FileSystemDirectoryHandle,
  ignorePatterns: string[], // Keep for compatibility but NEVER use for filtering existing data
  retries: number = 3,
  retryDelay: number = 100
): Promise&lt;WatchState&gt; {
  try {
    const stateDir = await cntxDir.getDirectoryHandle(&#39;state&#39;)
    const handle = await stateDir.getFileHandle(&#39;file.json&#39;)
    const file = await handle.getFile()
    const content = await file.text()

    try {
      const parsedState = JSON.parse(content)
      const sanitizedState: WatchState = {
        lastAccessed: parsedState.lastAccessed || new Date().toISOString(),
        files: {},
        masterBundle: parsedState.masterBundle || null,
      }

      // CRITICAL: Load ALL files from state UNCONDITIONALLY
      // Ignore patterns should NEVER affect existing state data
      if (parsedState.files &amp;&amp; typeof parsedState.files === &#39;object&#39;) {
        let taggedFilesCount = 0

        for (const [path, fileState] of Object.entries(parsedState.files)) {
          if (fileState &amp;&amp; typeof fileState === &#39;object&#39;) {
            const fileTags = Array.isArray((fileState as any).tags)
              ? (fileState as any).tags
              : []

            // Count files with tags for logging
            if (fileTags.length &gt; 0) {
              taggedFilesCount++
            }

            // PRESERVE ALL EXISTING DATA - especially tags
            sanitizedState.files[path] = {
              name: (fileState as any).name || path.split(&#39;/&#39;).pop() || &#39;&#39;,
              directory:
                (fileState as any).directory ||
                path.split(&#39;/&#39;).slice(0, -1).join(&#39;/&#39;) ||
                &#39;Root&#39;,
              lastModified:
                (fileState as any).lastModified || new Date().toISOString(),
              isChanged: Boolean((fileState as any).isChanged),
              isStaged: Boolean((fileState as any).isStaged),
              masterBundleId: (fileState as any).masterBundleId,
              // CRITICAL: Always preserve existing tags, never lose them
              tags: fileTags,
            }
          }
        }

        console.log(
          `✅ Loaded complete state with ${
            Object.keys(sanitizedState.files).length
          } files (${taggedFilesCount} with tags)`
        )

        // Log tagged files for debugging
        if (taggedFilesCount &gt; 0) {
          console.log(&#39;🏷️  Files with preserved tags:&#39;)
          Object.entries(sanitizedState.files).forEach(([path, state]) =&gt; {
            if (state.tags &amp;&amp; state.tags.length &gt; 0) {
              console.log(`  ${path}: [${state.tags.join(&#39;, &#39;)}]`)
            }
          })
        }
      }

      return sanitizedState
    } catch (parseError) {
      console.error(&#39;Invalid JSON content:&#39;)
      console.error(&#39;Parse error:&#39;, parseError)
      return { ...DEFAULT_STATE }
    }
  } catch (error) {
    if (error.name === &#39;NotReadableError&#39; &amp;&amp; retries &gt; 0) {
      await new Promise((resolve) =&gt; setTimeout(resolve, retryDelay))
      return loadState(cntxDir, ignorePatterns, retries - 1, retryDelay)
    }
    console.log(&#39;No existing state found, returning default state&#39;)
    return { ...DEFAULT_STATE }
  }
}

// ENHANCED: saveState with bulletproof tag preservation
export async function saveState(
  cntxDir: FileSystemDirectoryHandle,
  state: WatchState,
  ignorePatterns: string[]
): Promise&lt;void&gt; {
  try {
    const stateDir = await cntxDir.getDirectoryHandle(&#39;state&#39;)
    const handle = await stateDir.getFileHandle(&#39;file.json&#39;, { create: true })

    // CRITICAL: Preserve files with tags regardless of ignore patterns
    const preservedFiles = Object.fromEntries(
      Object.entries(state.files).map(([path, fileState]) =&gt; {
        // Always preserve files that have:
        // - Tags (MOST IMPORTANT)
        // - Are staged
        // - Have bundle associations
        // - Were manually modified
        const hasImportantData =
          (fileState.tags &amp;&amp; fileState.tags.length &gt; 0) ||
          fileState.isStaged ||
          fileState.masterBundleId ||
          fileState.isChanged

        // Log preservation of important files
        if (
          hasImportantData &amp;&amp;
          shouldIgnorePath(path, { ignore: ignorePatterns })
        ) {
          console.log(
            `🏷️  Preserving important file despite ignore pattern: ${path}`,
            {
              tags: fileState.tags || [],
              staged: fileState.isStaged,
              bundleId: fileState.masterBundleId,
              changed: fileState.isChanged,
            }
          )
        }

        // Sanitize and preserve all data
        return [
          path,
          {
            name: fileState.name,
            directory: fileState.directory,
            lastModified: fileState.lastModified || new Date().toISOString(),
            isChanged: Boolean(fileState.isChanged),
            isStaged: Boolean(fileState.isStaged),
            masterBundleId: fileState.masterBundleId,
            // CRITICAL: NEVER lose tags - always preserve them
            tags: Array.isArray(fileState.tags) ? [...fileState.tags] : [],
          },
        ]
      })
    )

    const sanitizedState = {
      lastAccessed: new Date().toISOString(),
      files: preservedFiles,
      masterBundle: state.masterBundle || null,
    }

    // Count tagged files for verification
    const taggedFilesCount = Object.values(preservedFiles).filter(
      (f) =&gt; f.tags &amp;&amp; f.tags.length &gt; 0
    ).length

    const writable = await handle.createWritable()
    const jsonContent = JSON.stringify(sanitizedState, null, 2)
    await writable.write(jsonContent)
    await writable.close()

    console.log(
      `✅ Saved state with ${
        Object.keys(preservedFiles).length
      } files (${taggedFilesCount} with tags)`
    )

    // Verify tags were preserved by sampling
    if (taggedFilesCount &gt; 0) {
      console.log(&#39;🏷️  Sample of preserved tagged files:&#39;)
      const taggedFiles = Object.entries(preservedFiles)
        .filter(([, state]) =&gt; state.tags &amp;&amp; state.tags.length &gt; 0)
        .slice(0, 5)

      taggedFiles.forEach(([path, state]) =&gt; {
        console.log(`  ${path}: [${state.tags.join(&#39;, &#39;)}]`)
      })

      if (Object.keys(preservedFiles).length &gt; taggedFiles.length) {
        console.log(
          `  ...and ${taggedFilesCount - taggedFiles.length} more tagged files`
        )
      }
    }
  } catch (error) {
    console.error(&#39;❌ Error saving state:&#39;, error)
    // Attempt to recover by recreating the state file
    try {
      const stateDir = await cntxDir.getDirectoryHandle(&#39;state&#39;)
      const handle = await stateDir.getFileHandle(&#39;file.json&#39;, { create: true })
      const writable = await handle.createWritable()
      await writable.write(JSON.stringify(DEFAULT_STATE, null, 2))
      await writable.close()
      console.log(&#39;🔄 Created new default state file after error&#39;)
    } catch (recoveryError) {
      console.error(&#39;💥 Failed to recover state file:&#39;, recoveryError)
    }
  }
}

// ENHANCED: Bundle manifest creation with tag preservation
export async function saveBundleManifest(
  bundlesDir: FileSystemDirectoryHandle,
  manifest: BundleManifest,
  isMaster: boolean = false
) {
  const dir = isMaster
    ? await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true })
    : bundlesDir

  const manifestHandle = await dir.getFileHandle(
    `${manifest.id}-manifest.json`,
    { create: true }
  )

  // Ensure manifest includes tags
  const enhancedManifest = {
    ...manifest,
    files: manifest.files.map((file) =&gt; ({
      ...file,
      tags: file.tags || [], // Ensure tags are always present
    })),
  }

  const manifestWritable = await manifestHandle.createWritable()
  await manifestWritable.write(JSON.stringify(enhancedManifest, null, 2))
  await manifestWritable.close()

  console.log(
    `📋 Saved manifest for ${manifest.id} with ${manifest.files.length} files`
  )
}

export function generateBundleId(): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, &#39;-&#39;)
  const random = Math.random().toString(36).substring(2, 7)
  return `bundle-${timestamp}-${random}`
}

// ENHANCED: Bundle creation with tag preservation
export async function createBundleFile(
  files: WatchedFile[],
  cntxDir: FileSystemDirectoryHandle
): Promise&lt;{ success: boolean; error?: string; bundleId?: string }&gt; {
  try {
    const bundleId = generateBundleId()
    const timestamp = new Date().toISOString()
    const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;)

    console.log(`📦 Creating bundle ${bundleId} with ${files.length} files`)

    // CRITICAL: Load existing state to get current tags
    const currentState = await loadState(cntxDir, []) // No filtering

    // Update files with current tags from state
    const filesWithCurrentTags = files.map((file) =&gt; {
      const stateFile = currentState.files[file.path]
      if (stateFile &amp;&amp; stateFile.tags &amp;&amp; stateFile.tags.length &gt; 0) {
        console.log(`🏷️  Including tags for ${file.path}:`, stateFile.tags)
        return {
          ...file,
          tags: stateFile.tags,
        }
      }
      return file
    })

    // Create bundle content with tags
    const bundleContent = await Promise.all(
      filesWithCurrentTags.map(async (file) =&gt; {
        const fileContent =
          (await file.handle?.getFile().then((f) =&gt; f.text())) || &#39;&#39;

        // Include tags in the document
        const tagsString =
          file.tags &amp;&amp; file.tags.length &gt; 0
            ? `&lt;tags&gt;${file.tags.join(&#39;,&#39;)}&lt;/tags&gt;`
            : &#39;&lt;tags&gt;&lt;/tags&gt;&#39;

        return `&lt;document&gt;
&lt;source&gt;${file.path}&lt;/source&gt;
${tagsString}
&lt;content&gt;${fileContent}&lt;/content&gt;
&lt;/document&gt;`
      })
    )

    const bundleHandle = await bundlesDir.getFileHandle(`${bundleId}.txt`, {
      create: true,
    })
    const writable = await bundleHandle.createWritable()
    await writable.write(bundleContent.join(&#39;\n\n&#39;))
    await writable.close()

    // Create manifest with tags
    const manifest: BundleManifest = {
      id: bundleId,
      created: timestamp,
      fileCount: files.length,
      files: filesWithCurrentTags.map((file) =&gt; ({
        path: file.path,
        lastModified: file.lastModified.toISOString(),
        tags: file.tags || [], // CRITICAL: Include tags in manifest
      })),
    }
    await saveBundleManifest(bundlesDir, manifest)

    // Update state while preserving tags
    filesWithCurrentTags.forEach((file) =&gt; {
      if (!currentState.files[file.path]) {
        currentState.files[file.path] = {
          name: file.name,
          directory: file.directory,
          lastModified: file.lastModified.toISOString(),
          isChanged: false,
          isStaged: false, // Unstage after bundling
          masterBundleId: undefined,
          tags: file.tags || [],
        }
      } else {
        // PRESERVE existing tags when updating state
        currentState.files[file.path] = {
          ...currentState.files[file.path],
          isStaged: false, // Unstage after bundling
          tags: currentState.files[file.path].tags || [], // Keep existing tags
        }
      }
    })

    // Save state with preserved tags
    await saveState(cntxDir, currentState, []) // No filtering to preserve all

    console.log(
      `✅ Bundle ${bundleId} created successfully with preserved tags`
    )
    return { success: true, bundleId }
  } catch (error) {
    console.error(&#39;❌ Error creating bundle:&#39;, error)
    return {
      success: false,
      error: error instanceof Error ? error.message : &#39;Failed to create bundle&#39;,
    }
  }
}

export async function createTagBundleFile(
  files: WatchedFile[],
  tagName: string,
  cntxDir: FileSystemDirectoryHandle,
  existingBundleId?: string // Add this parameter for updates
): Promise&lt;{ success: boolean; error?: string; bundleId?: string }&gt; {
  try {
    const bundleId =
      existingBundleId ||
      `tag-${tagName}-${new Date().toISOString().replace(/[:.]/g, &#39;-&#39;)}`
    const timestamp = new Date().toISOString()

    console.log(
      `📦 Creating tag bundle ${bundleId} for tag &quot;${tagName}&quot; with ${files.length} files`
    )

    // Get or create bundles directory structure
    const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;, {
      create: true,
    })
    const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;, {
      create: true,
    })
    const tagDir = await tagBundlesDir.getDirectoryHandle(tagName, {
      create: true,
    })

    // CRITICAL: Load existing state to get current tags
    const currentState = await loadState(cntxDir, []) // No filtering

    // Update files with current tags from state
    const filesWithCurrentTags = files.map((file) =&gt; {
      const stateFile = currentState.files[file.path]
      if (stateFile &amp;&amp; stateFile.tags &amp;&amp; stateFile.tags.length &gt; 0) {
        console.log(`🏷️  Including tags for ${file.path}:`, stateFile.tags)
        return {
          ...file,
          tags: stateFile.tags,
        }
      }
      return file
    })

    // Create enhanced bundle content with proper XML structure
    const bundleContent = await Promise.all(
      filesWithCurrentTags.map(async (file) =&gt; {
        try {
          const fileContent =
            (await file.handle?.getFile().then((f) =&gt; f.text())) || &#39;&#39;

          // Include tags in the document
          const tagsString =
            file.tags &amp;&amp; file.tags.length &gt; 0 ? file.tags.join(&#39;,&#39;) : &#39;&#39;

          return `    &lt;document&gt;
      &lt;source&gt;${escapeXML(file.path)}&lt;/source&gt;
      &lt;tags&gt;${escapeXML(tagsString)}&lt;/tags&gt;
      &lt;metadata&gt;
        &lt;size&gt;${fileContent.length}&lt;/size&gt;
        &lt;lastModified&gt;${file.lastModified.toISOString()}&lt;/lastModified&gt;
        &lt;extension&gt;${getFileExtension(file.path)}&lt;/extension&gt;
        &lt;directory&gt;${escapeXML(file.directory)}&lt;/directory&gt;
      &lt;/metadata&gt;
      &lt;content&gt;${escapeXML(fileContent)}&lt;/content&gt;
    &lt;/document&gt;`
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error)
          return `    &lt;document&gt;
      &lt;source&gt;${escapeXML(file.path)}&lt;/source&gt;
      &lt;tags&gt;${escapeXML(tagName)}&lt;/tags&gt;
      &lt;content&gt;&lt;!-- Error reading file: ${
        error instanceof Error ? error.message : &#39;unknown error&#39;
      } --&gt;&lt;/content&gt;
    &lt;/document&gt;`
        }
      })
    )

    // Create the complete bundle content with enhanced metadata
    const fullBundleContent = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bundle id=&quot;${bundleId}&quot; created=&quot;${timestamp}&quot; fileCount=&quot;${
      files.length
    }&quot; type=&quot;tag-derived&quot;&gt;
  
  &lt;metadata&gt;
    &lt;bundleType&gt;tag-derived&lt;/bundleType&gt;
    &lt;derivedFromTag&gt;${escapeXML(tagName)}&lt;/derivedFromTag&gt;
    &lt;description&gt;Auto-generated bundle for files tagged with &quot;${escapeXML(
      tagName
    )}&quot;&lt;/description&gt;
    &lt;totalFiles&gt;${files.length}&lt;/totalFiles&gt;
    &lt;createdAt&gt;${timestamp}&lt;/createdAt&gt;
  &lt;/metadata&gt;

  &lt;documents&gt;
    
${bundleContent.join(&#39;\n\n&#39;)}
    
  &lt;/documents&gt;

&lt;/bundle&gt;`

    console.log(
      `📝 Tag bundle content created (${fullBundleContent.length} bytes)`
    )

    // Write the bundle file
    try {
      const bundleHandle = await tagDir.getFileHandle(`${bundleId}.txt`, {
        create: true,
      })
      const writable = await bundleHandle.createWritable()
      await writable.write(fullBundleContent)
      await writable.close()
      console.log(`💾 Tag bundle file written: ${bundleId}.txt`)
    } catch (error) {
      console.error(&#39;❌ Error creating tag bundle:&#39;, error)
      return {
        success: false,
        error:
          error instanceof Error
            ? error.message
            : &#39;Failed to create tag bundle&#39;,
      }
    }

    // Create and save enhanced manifest
    const manifest: BundleManifest = {
      id: bundleId,
      created: timestamp,
      fileCount: files.length,
      type: &#39;tag-derived&#39;,
      derivedFromTag: tagName,
      description: `Files tagged with &quot;${tagName}&quot;`,
      files: filesWithCurrentTags.map((file) =&gt; ({
        path: file.path,
        lastModified: file.lastModified.toISOString(),
        tags: file.tags || [], // CRITICAL: Include tags in manifest
      })),
    }

    try {
      await saveTagBundleManifest(tagDir, manifest, tagName)
      console.log(&#39;📋 Tag bundle manifest saved with tags&#39;)
    } catch (error) {
      console.error(&#39;Error saving tag bundle manifest:&#39;, error)
      return {
        success: false,
        error: `Failed to save tag bundle manifest: ${
          error instanceof Error ? error.message : String(error)
        }`,
      }
    }

    // Update state while preserving ALL existing tags (don&#39;t modify file states for tag bundles)
    // Tag bundles are read-only snapshots, so we don&#39;t need to update file states

    console.log(`🎉 Tag bundle creation completed successfully: ${bundleId}`)
    return { success: true, bundleId }
  } catch (error) {
    console.error(&#39;❌ Error creating tag bundle:&#39;, error)
    return {
      success: false,
      error:
        error instanceof Error ? error.message : &#39;Failed to create tag bundle&#39;,
    }
  }
}

async function saveTagBundleManifest(
  tagDir: FileSystemDirectoryHandle,
  manifest: BundleManifest,
  tagName: string
) {
  const manifestHandle = await tagDir.getFileHandle(
    `${manifest.id}-manifest.json`,
    { create: true }
  )

  // Enhanced manifest with tag-specific metadata
  const enhancedManifest = {
    ...manifest,
    tagBundleMetadata: {
      tagName: tagName,
      autoGenerated: true,
      createdFrom: &#39;tag-derived-bundle-system&#39;,
      filesMatchingTag: manifest.files.length,
    },
    files: manifest.files.map((file) =&gt; ({
      ...file,
      tags: file.tags || [], // Ensure tags are always present
    })),
  }

  const manifestWritable = await manifestHandle.createWritable()
  await manifestWritable.write(JSON.stringify(enhancedManifest, null, 2))
  await manifestWritable.close()

  console.log(
    `📋 Saved tag bundle manifest for ${manifest.id} with ${manifest.files.length} files`
  )
}

/**
 * Helper function to get file extension
 */
function getFileExtension(filePath: string): string {
  const lastDot = filePath.lastIndexOf(&#39;.&#39;)
  return lastDot === -1 ? &#39;&#39; : filePath.substring(lastDot + 1)
}

/**
 * Escapes XML special characters
 */
function escapeXML(str: string): string {
  return str
    .replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;)
    .replace(/&#39;/g, &#39;&amp;#39;&#39;)
}
</content>
    </document>

    <document>
      <source>src/components/ui/alert-dialog.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>4419</size>
        <lastModified>2025-05-22T00:43:04.227Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as AlertDialogPrimitive from &quot;@radix-ui/react-alert-dialog&quot;

import { cn } from &quot;@/lib/utils&quot;
import { buttonVariants } from &quot;@/components/ui/button&quot;

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Overlay&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Overlay&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPrimitive.Overlay
    className={cn(
      &quot;fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0&quot;,
      className
    )}
    {...props}
    ref={ref}
  /&gt;
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Content&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPortal&gt;
    &lt;AlertDialogOverlay /&gt;
    &lt;AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        &quot;fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg&quot;,
        className
      )}
      {...props}
    /&gt;
  &lt;/AlertDialogPortal&gt;
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes&lt;HTMLDivElement&gt;) =&gt; (
  &lt;div
    className={cn(
      &quot;flex flex-col space-y-2 text-center sm:text-left&quot;,
      className
    )}
    {...props}
  /&gt;
)
AlertDialogHeader.displayName = &quot;AlertDialogHeader&quot;

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes&lt;HTMLDivElement&gt;) =&gt; (
  &lt;div
    className={cn(
      &quot;flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2&quot;,
      className
    )}
    {...props}
  /&gt;
)
AlertDialogFooter.displayName = &quot;AlertDialogFooter&quot;

const AlertDialogTitle = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Title&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Title&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPrimitive.Title
    ref={ref}
    className={cn(&quot;text-lg font-semibold&quot;, className)}
    {...props}
  /&gt;
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Description&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Description&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPrimitive.Description
    ref={ref}
    className={cn(&quot;text-sm text-muted-foreground&quot;, className)}
    {...props}
  /&gt;
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Action&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Action&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  /&gt;
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef&lt;
  React.ElementRef&lt;typeof AlertDialogPrimitive.Cancel&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AlertDialogPrimitive.Cancel&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: &quot;outline&quot; }),
      &quot;mt-2 sm:mt-0&quot;,
      className
    )}
    {...props}
  /&gt;
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</content>
    </document>

    <document>
      <source>src/components/ui/popover.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1342</size>
        <lastModified>2025-05-22T00:43:04.229Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as PopoverPrimitive from &quot;@radix-ui/react-popover&quot;

import { cn } from &quot;@/lib/utils&quot;

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof PopoverPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof PopoverPrimitive.Content&gt;
&gt;(({ className, align = &quot;center&quot;, sideOffset = 4, ...props }, ref) =&gt; (
  &lt;PopoverPrimitive.Portal&gt;
    &lt;PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        &quot;z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]&quot;,
        className
      )}
      {...props}
    /&gt;
  &lt;/PopoverPrimitive.Portal&gt;
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</content>
    </document>

    <document>
      <source>src/components/ui/card.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1828</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Card = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(
      &quot;rounded-xl border bg-card text-card-foreground shadow&quot;,
      className
    )}
    {...props}
  /&gt;
))
Card.displayName = &quot;Card&quot;

const CardHeader = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(&quot;flex flex-col space-y-1.5 p-6&quot;, className)}
    {...props}
  /&gt;
))
CardHeader.displayName = &quot;CardHeader&quot;

const CardTitle = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(&quot;font-semibold leading-none tracking-tight&quot;, className)}
    {...props}
  /&gt;
))
CardTitle.displayName = &quot;CardTitle&quot;

const CardDescription = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(&quot;text-sm text-muted-foreground&quot;, className)}
    {...props}
  /&gt;
))
CardDescription.displayName = &quot;CardDescription&quot;

const CardContent = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div ref={ref} className={cn(&quot;p-6 pt-0&quot;, className)} {...props} /&gt;
))
CardContent.displayName = &quot;CardContent&quot;

const CardFooter = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(&quot;flex items-center p-6 pt-0&quot;, className)}
    {...props}
  /&gt;
))
CardFooter.displayName = &quot;CardFooter&quot;

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</content>
    </document>

    <document>
      <source>src/components/ui/switch.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1148</size>
        <lastModified>2025-05-23T18:22:51.626Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as SwitchPrimitives from &quot;@radix-ui/react-switch&quot;

import { cn } from &quot;@/lib/utils&quot;

const Switch = React.forwardRef&lt;
  React.ElementRef&lt;typeof SwitchPrimitives.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SwitchPrimitives.Root&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;SwitchPrimitives.Root
    className={cn(
      &quot;peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input&quot;,
      className
    )}
    {...props}
    ref={ref}
  &gt;
    &lt;SwitchPrimitives.Thumb
      className={cn(
        &quot;pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0&quot;
      )}
    /&gt;
  &lt;/SwitchPrimitives.Root&gt;
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</content>
    </document>

    <document>
      <source>src/components/ui/avatar.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1405</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as AvatarPrimitive from &quot;@radix-ui/react-avatar&quot;

import { cn } from &quot;@/lib/utils&quot;

const Avatar = React.forwardRef&lt;
  React.ElementRef&lt;typeof AvatarPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AvatarPrimitive.Root&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AvatarPrimitive.Root
    ref={ref}
    className={cn(
      &quot;relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full&quot;,
      className
    )}
    {...props}
  /&gt;
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef&lt;
  React.ElementRef&lt;typeof AvatarPrimitive.Image&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AvatarPrimitive.Image&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AvatarPrimitive.Image
    ref={ref}
    className={cn(&quot;aspect-square h-full w-full&quot;, className)}
    {...props}
  /&gt;
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef&lt;
  React.ElementRef&lt;typeof AvatarPrimitive.Fallback&gt;,
  React.ComponentPropsWithoutRef&lt;typeof AvatarPrimitive.Fallback&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      &quot;flex h-full w-full items-center justify-center rounded-full bg-muted&quot;,
      className
    )}
    {...props}
  /&gt;
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</content>
    </document>

    <document>
      <source>src/components/ui/table.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>2859</size>
        <lastModified>2025-05-22T00:43:04.230Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Table = React.forwardRef&lt;
  HTMLTableElement,
  React.HTMLAttributes&lt;HTMLTableElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div className=&quot;relative w-full overflow-auto&quot;&gt;
    &lt;table
      ref={ref}
      className={cn(&quot;w-full caption-bottom text-sm&quot;, className)}
      {...props}
    /&gt;
  &lt;/div&gt;
))
Table.displayName = &quot;Table&quot;

const TableHeader = React.forwardRef&lt;
  HTMLTableSectionElement,
  React.HTMLAttributes&lt;HTMLTableSectionElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;thead ref={ref} className={cn(&quot;[&amp;_tr]:border-b&quot;, className)} {...props} /&gt;
))
TableHeader.displayName = &quot;TableHeader&quot;

const TableBody = React.forwardRef&lt;
  HTMLTableSectionElement,
  React.HTMLAttributes&lt;HTMLTableSectionElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;tbody
    ref={ref}
    className={cn(&quot;[&amp;_tr:last-child]:border-0&quot;, className)}
    {...props}
  /&gt;
))
TableBody.displayName = &quot;TableBody&quot;

const TableFooter = React.forwardRef&lt;
  HTMLTableSectionElement,
  React.HTMLAttributes&lt;HTMLTableSectionElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;tfoot
    ref={ref}
    className={cn(
      &quot;border-t bg-muted/50 font-medium [&amp;&gt;tr]:last:border-b-0&quot;,
      className
    )}
    {...props}
  /&gt;
))
TableFooter.displayName = &quot;TableFooter&quot;

const TableRow = React.forwardRef&lt;
  HTMLTableRowElement,
  React.HTMLAttributes&lt;HTMLTableRowElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;tr
    ref={ref}
    className={cn(
      &quot;border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted&quot;,
      className
    )}
    {...props}
  /&gt;
))
TableRow.displayName = &quot;TableRow&quot;

const TableHead = React.forwardRef&lt;
  HTMLTableCellElement,
  React.ThHTMLAttributes&lt;HTMLTableCellElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;th
    ref={ref}
    className={cn(
      &quot;h-10 px-2 text-left align-middle font-medium text-muted-foreground [&amp;:has([role=checkbox])]:pr-0 [&amp;&gt;[role=checkbox]]:translate-y-[2px]&quot;,
      className
    )}
    {...props}
  /&gt;
))
TableHead.displayName = &quot;TableHead&quot;

const TableCell = React.forwardRef&lt;
  HTMLTableCellElement,
  React.TdHTMLAttributes&lt;HTMLTableCellElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;td
    ref={ref}
    className={cn(
      &quot;p-2 align-middle [&amp;:has([role=checkbox])]:pr-0 [&amp;&gt;[role=checkbox]]:translate-y-[2px]&quot;,
      className
    )}
    {...props}
  /&gt;
))
TableCell.displayName = &quot;TableCell&quot;

const TableCaption = React.forwardRef&lt;
  HTMLTableCaptionElement,
  React.HTMLAttributes&lt;HTMLTableCaptionElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;caption
    ref={ref}
    className={cn(&quot;mt-4 text-sm text-muted-foreground&quot;, className)}
    {...props}
  /&gt;
))
TableCaption.displayName = &quot;TableCaption&quot;

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</content>
    </document>

    <document>
      <source>src/components/ui/separator.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>756</size>
        <lastModified>2025-05-23T22:47:54.986Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as SeparatorPrimitive from &quot;@radix-ui/react-separator&quot;

import { cn } from &quot;@/lib/utils&quot;

const Separator = React.forwardRef&lt;
  React.ElementRef&lt;typeof SeparatorPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SeparatorPrimitive.Root&gt;
&gt;(
  (
    { className, orientation = &quot;horizontal&quot;, decorative = true, ...props },
    ref
  ) =&gt; (
    &lt;SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        &quot;shrink-0 bg-border&quot;,
        orientation === &quot;horizontal&quot; ? &quot;h-[1px] w-full&quot; : &quot;h-full w-[1px]&quot;,
        className
      )}
      {...props}
    /&gt;
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</content>
    </document>

    <document>
      <source>src/components/ui/alert.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1598</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const alertVariants = cva(
  &quot;relative w-full rounded-lg border px-4 py-3 text-sm [&amp;&gt;svg+div]:translate-y-[-3px] [&amp;&gt;svg]:absolute [&amp;&gt;svg]:left-4 [&amp;&gt;svg]:top-4 [&amp;&gt;svg]:text-foreground [&amp;&gt;svg~*]:pl-7&quot;,
  {
    variants: {
      variant: {
        default: &quot;bg-background text-foreground&quot;,
        destructive:
          &quot;border-destructive/50 text-destructive dark:border-destructive [&amp;&gt;svg]:text-destructive&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
    },
  }
)

const Alert = React.forwardRef&lt;
  HTMLDivElement,
  React.HTMLAttributes&lt;HTMLDivElement&gt; &amp; VariantProps&lt;typeof alertVariants&gt;
&gt;(({ className, variant, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    role=&quot;alert&quot;
    className={cn(alertVariants({ variant }), className)}
    {...props}
  /&gt;
))
Alert.displayName = &quot;Alert&quot;

const AlertTitle = React.forwardRef&lt;
  HTMLParagraphElement,
  React.HTMLAttributes&lt;HTMLHeadingElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;h5
    ref={ref}
    className={cn(&quot;mb-1 font-medium leading-none tracking-tight&quot;, className)}
    {...props}
  /&gt;
))
AlertTitle.displayName = &quot;AlertTitle&quot;

const AlertDescription = React.forwardRef&lt;
  HTMLParagraphElement,
  React.HTMLAttributes&lt;HTMLParagraphElement&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;div
    ref={ref}
    className={cn(&quot;text-sm [&amp;_p]:leading-relaxed&quot;, className)}
    {...props}
  /&gt;
))
AlertDescription.displayName = &quot;AlertDescription&quot;

export { Alert, AlertTitle, AlertDescription }
</content>
    </document>

    <document>
      <source>src/components/ui/tooltip.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1203</size>
        <lastModified>2025-05-22T00:43:04.230Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TooltipPrimitive from &quot;@radix-ui/react-tooltip&quot;

import { cn } from &quot;@/lib/utils&quot;

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof TooltipPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof TooltipPrimitive.Content&gt;
&gt;(({ className, sideOffset = 4, ...props }, ref) =&gt; (
  &lt;TooltipPrimitive.Portal&gt;
    &lt;TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        &quot;z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,
        className
      )}
      {...props}
    /&gt;
  &lt;/TooltipPrimitive.Portal&gt;
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</content>
    </document>

    <document>
      <source>src/components/ui/dialog.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>3835</size>
        <lastModified>2025-05-22T00:43:04.229Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as DialogPrimitive from &quot;@radix-ui/react-dialog&quot;
import { X } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef&lt;
  React.ElementRef&lt;typeof DialogPrimitive.Overlay&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DialogPrimitive.Overlay&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      &quot;fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0&quot;,
      className
    )}
    {...props}
  /&gt;
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof DialogPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DialogPrimitive.Content&gt;
&gt;(({ className, children, ...props }, ref) =&gt; (
  &lt;DialogPortal&gt;
    &lt;DialogOverlay /&gt;
    &lt;DialogPrimitive.Content
      ref={ref}
      className={cn(
        &quot;fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg&quot;,
        className
      )}
      {...props}
    &gt;
      {children}
      &lt;DialogPrimitive.Close className=&quot;absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground&quot;&gt;
        &lt;X className=&quot;h-4 w-4&quot; /&gt;
        &lt;span className=&quot;sr-only&quot;&gt;Close&lt;/span&gt;
      &lt;/DialogPrimitive.Close&gt;
    &lt;/DialogPrimitive.Content&gt;
  &lt;/DialogPortal&gt;
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes&lt;HTMLDivElement&gt;) =&gt; (
  &lt;div
    className={cn(
      &quot;flex flex-col space-y-1.5 text-center sm:text-left&quot;,
      className
    )}
    {...props}
  /&gt;
)
DialogHeader.displayName = &quot;DialogHeader&quot;

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes&lt;HTMLDivElement&gt;) =&gt; (
  &lt;div
    className={cn(
      &quot;flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2&quot;,
      className
    )}
    {...props}
  /&gt;
)
DialogFooter.displayName = &quot;DialogFooter&quot;

const DialogTitle = React.forwardRef&lt;
  React.ElementRef&lt;typeof DialogPrimitive.Title&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DialogPrimitive.Title&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;DialogPrimitive.Title
    ref={ref}
    className={cn(
      &quot;text-lg font-semibold leading-none tracking-tight&quot;,
      className
    )}
    {...props}
  /&gt;
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef&lt;
  React.ElementRef&lt;typeof DialogPrimitive.Description&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DialogPrimitive.Description&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;DialogPrimitive.Description
    ref={ref}
    className={cn(&quot;text-sm text-muted-foreground&quot;, className)}
    {...props}
  /&gt;
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</content>
    </document>

    <document>
      <source>src/components/ui/label.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>710</size>
        <lastModified>2025-05-23T18:23:43.006Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as LabelPrimitive from &quot;@radix-ui/react-label&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const labelVariants = cva(
  &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70&quot;
)

const Label = React.forwardRef&lt;
  React.ElementRef&lt;typeof LabelPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof LabelPrimitive.Root&gt; &amp;
    VariantProps&lt;typeof labelVariants&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  /&gt;
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</content>
    </document>

    <document>
      <source>src/components/ui/button.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1902</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const buttonVariants = cva(
  &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;bg-primary text-primary-foreground shadow hover:bg-primary/90&quot;,
        destructive:
          &quot;bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90&quot;,
        outline:
          &quot;border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground&quot;,
        secondary:
          &quot;bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80&quot;,
        ghost: &quot;hover:bg-accent hover:text-accent-foreground&quot;,
        link: &quot;text-primary underline-offset-4 hover:underline&quot;,
      },
      size: {
        default: &quot;h-9 px-4 py-2&quot;,
        sm: &quot;h-8 rounded-md px-3 text-xs&quot;,
        lg: &quot;h-10 rounded-md px-8&quot;,
        icon: &quot;h-9 w-9&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
      size: &quot;default&quot;,
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt;,
    VariantProps&lt;typeof buttonVariants&gt; {
  asChild?: boolean
}

const Button = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;(
  ({ className, variant, size, asChild = false, ...props }, ref) =&gt; {
    const Comp = asChild ? Slot : &quot;button&quot;
    return (
      &lt;Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      /&gt;
    )
  }
)
Button.displayName = &quot;Button&quot;

export { Button, buttonVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/select.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>5618</size>
        <lastModified>2025-05-22T00:43:04.230Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as SelectPrimitive from &quot;@radix-ui/react-select&quot;
import { Check, ChevronDown, ChevronUp } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.Trigger&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Trigger&gt;
&gt;(({ className, children, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      &quot;flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&amp;&gt;span]:line-clamp-1&quot;,
      className
    )}
    {...props}
  &gt;
    {children}
    &lt;SelectPrimitive.Icon asChild&gt;
      &lt;ChevronDown className=&quot;h-4 w-4 opacity-50&quot; /&gt;
    &lt;/SelectPrimitive.Icon&gt;
  &lt;/SelectPrimitive.Trigger&gt;
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.ScrollUpButton&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.ScrollUpButton&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      &quot;flex cursor-default items-center justify-center py-1&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;ChevronUp className=&quot;h-4 w-4&quot; /&gt;
  &lt;/SelectPrimitive.ScrollUpButton&gt;
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.ScrollDownButton&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.ScrollDownButton&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      &quot;flex cursor-default items-center justify-center py-1&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;ChevronDown className=&quot;h-4 w-4&quot; /&gt;
  &lt;/SelectPrimitive.ScrollDownButton&gt;
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Content&gt;
&gt;(({ className, children, position = &quot;popper&quot;, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.Portal&gt;
    &lt;SelectPrimitive.Content
      ref={ref}
      className={cn(
        &quot;relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,
        position === &quot;popper&quot; &amp;&amp;
          &quot;data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1&quot;,
        className
      )}
      position={position}
      {...props}
    &gt;
      &lt;SelectScrollUpButton /&gt;
      &lt;SelectPrimitive.Viewport
        className={cn(
          &quot;p-1&quot;,
          position === &quot;popper&quot; &amp;&amp;
            &quot;h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]&quot;
        )}
      &gt;
        {children}
      &lt;/SelectPrimitive.Viewport&gt;
      &lt;SelectScrollDownButton /&gt;
    &lt;/SelectPrimitive.Content&gt;
  &lt;/SelectPrimitive.Portal&gt;
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.Label&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Label&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.Label
    ref={ref}
    className={cn(&quot;px-2 py-1.5 text-sm font-semibold&quot;, className)}
    {...props}
  /&gt;
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.Item&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Item&gt;
&gt;(({ className, children, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.Item
    ref={ref}
    className={cn(
      &quot;relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;span className=&quot;absolute right-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;
      &lt;SelectPrimitive.ItemIndicator&gt;
        &lt;Check className=&quot;h-4 w-4&quot; /&gt;
      &lt;/SelectPrimitive.ItemIndicator&gt;
    &lt;/span&gt;
    &lt;SelectPrimitive.ItemText&gt;{children}&lt;/SelectPrimitive.ItemText&gt;
  &lt;/SelectPrimitive.Item&gt;
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef&lt;
  React.ElementRef&lt;typeof SelectPrimitive.Separator&gt;,
  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Separator&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;SelectPrimitive.Separator
    ref={ref}
    className={cn(&quot;-mx-1 my-1 h-px bg-muted&quot;, className)}
    {...props}
  /&gt;
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</content>
    </document>

    <document>
      <source>src/components/ui/progress.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>778</size>
        <lastModified>2025-05-22T00:43:04.229Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as ProgressPrimitive from &quot;@radix-ui/react-progress&quot;

import { cn } from &quot;@/lib/utils&quot;

const Progress = React.forwardRef&lt;
  React.ElementRef&lt;typeof ProgressPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof ProgressPrimitive.Root&gt;
&gt;(({ className, value, ...props }, ref) =&gt; (
  &lt;ProgressPrimitive.Root
    ref={ref}
    className={cn(
      &quot;relative h-2 w-full overflow-hidden rounded-full bg-primary/20&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;ProgressPrimitive.Indicator
      className=&quot;h-full w-full flex-1 bg-primary transition-all&quot;
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    /&gt;
  &lt;/ProgressPrimitive.Root&gt;
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</content>
    </document>

    <document>
      <source>src/components/ui/input.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>768</size>
        <lastModified>2025-05-22T00:43:04.229Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Input = React.forwardRef&lt;HTMLInputElement, React.ComponentProps&lt;&quot;input&quot;&gt;&gt;(
  ({ className, type, ...props }, ref) =&gt; {
    return (
      &lt;input
        type={type}
        className={cn(
          &quot;flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm&quot;,
          className
        )}
        ref={ref}
        {...props}
      /&gt;
    )
  }
)
Input.displayName = &quot;Input&quot;

export { Input }
</content>
    </document>

    <document>
      <source>src/components/ui/dropdown-menu.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>7402</size>
        <lastModified>2025-05-22T00:43:04.229Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as DropdownMenuPrimitive from &quot;@radix-ui/react-dropdown-menu&quot;
import { Check, ChevronRight, Circle } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.SubTrigger&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.SubTrigger&gt; &amp; {
    inset?: boolean
  }
&gt;(({ className, inset, children, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      &quot;flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0&quot;,
      inset &amp;&amp; &quot;pl-8&quot;,
      className
    )}
    {...props}
  &gt;
    {children}
    &lt;ChevronRight className=&quot;ml-auto&quot; /&gt;
  &lt;/DropdownMenuPrimitive.SubTrigger&gt;
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.SubContent&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.SubContent&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      &quot;z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,
      className
    )}
    {...props}
  /&gt;
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Content&gt;
&gt;(({ className, sideOffset = 4, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.Portal&gt;
    &lt;DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        &quot;z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md&quot;,
        &quot;data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,
        className
      )}
      {...props}
    /&gt;
  &lt;/DropdownMenuPrimitive.Portal&gt;
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.Item&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Item&gt; &amp; {
    inset?: boolean
  }
&gt;(({ className, inset, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      &quot;relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0&quot;,
      inset &amp;&amp; &quot;pl-8&quot;,
      className
    )}
    {...props}
  /&gt;
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;
&gt;(({ className, children, checked, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      &quot;relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,
      className
    )}
    checked={checked}
    {...props}
  &gt;
    &lt;span className=&quot;absolute left-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;
      &lt;DropdownMenuPrimitive.ItemIndicator&gt;
        &lt;Check className=&quot;h-4 w-4&quot; /&gt;
      &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
    &lt;/span&gt;
    {children}
  &lt;/DropdownMenuPrimitive.CheckboxItem&gt;
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.RadioItem&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.RadioItem&gt;
&gt;(({ className, children, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      &quot;relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;span className=&quot;absolute left-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;
      &lt;DropdownMenuPrimitive.ItemIndicator&gt;
        &lt;Circle className=&quot;h-2 w-2 fill-current&quot; /&gt;
      &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
    &lt;/span&gt;
    {children}
  &lt;/DropdownMenuPrimitive.RadioItem&gt;
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.Label&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Label&gt; &amp; {
    inset?: boolean
  }
&gt;(({ className, inset, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      &quot;px-2 py-1.5 text-sm font-semibold&quot;,
      inset &amp;&amp; &quot;pl-8&quot;,
      className
    )}
    {...props}
  /&gt;
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef&lt;
  React.ElementRef&lt;typeof DropdownMenuPrimitive.Separator&gt;,
  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Separator&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn(&quot;-mx-1 my-1 h-px bg-muted&quot;, className)}
    {...props}
  /&gt;
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes&lt;HTMLSpanElement&gt;) =&gt; {
  return (
    &lt;span
      className={cn(&quot;ml-auto text-xs tracking-widest opacity-60&quot;, className)}
      {...props}
    /&gt;
  )
}
DropdownMenuShortcut.displayName = &quot;DropdownMenuShortcut&quot;

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</content>
    </document>

    <document>
      <source>src/components/ui/badge.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1140</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const badgeVariants = cva(
  &quot;inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80&quot;,
        secondary:
          &quot;border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80&quot;,
        destructive:
          &quot;border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80&quot;,
        outline: &quot;text-foreground&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes&lt;HTMLDivElement&gt;,
    VariantProps&lt;typeof badgeVariants&gt; {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    &lt;div className={cn(badgeVariants({ variant }), className)} {...props} /&gt;
  )
}

export { Badge, badgeVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/scroll-area.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1642</size>
        <lastModified>2025-05-22T00:43:04.230Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as ScrollAreaPrimitive from &quot;@radix-ui/react-scroll-area&quot;

import { cn } from &quot;@/lib/utils&quot;

const ScrollArea = React.forwardRef&lt;
  React.ElementRef&lt;typeof ScrollAreaPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof ScrollAreaPrimitive.Root&gt;
&gt;(({ className, children, ...props }, ref) =&gt; (
  &lt;ScrollAreaPrimitive.Root
    ref={ref}
    className={cn(&quot;relative overflow-hidden&quot;, className)}
    {...props}
  &gt;
    &lt;ScrollAreaPrimitive.Viewport className=&quot;h-full w-full rounded-[inherit]&quot;&gt;
      {children}
    &lt;/ScrollAreaPrimitive.Viewport&gt;
    &lt;ScrollBar /&gt;
    &lt;ScrollAreaPrimitive.Corner /&gt;
  &lt;/ScrollAreaPrimitive.Root&gt;
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef&lt;
  React.ElementRef&lt;typeof ScrollAreaPrimitive.ScrollAreaScrollbar&gt;,
  React.ComponentPropsWithoutRef&lt;typeof ScrollAreaPrimitive.ScrollAreaScrollbar&gt;
&gt;(({ className, orientation = &quot;vertical&quot;, ...props }, ref) =&gt; (
  &lt;ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      &quot;flex touch-none select-none transition-colors&quot;,
      orientation === &quot;vertical&quot; &amp;&amp;
        &quot;h-full w-2.5 border-l border-l-transparent p-[1px]&quot;,
      orientation === &quot;horizontal&quot; &amp;&amp;
        &quot;h-2.5 flex-col border-t border-t-transparent p-[1px]&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;ScrollAreaPrimitive.ScrollAreaThumb className=&quot;relative flex-1 rounded-full bg-border&quot; /&gt;
  &lt;/ScrollAreaPrimitive.ScrollAreaScrollbar&gt;
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</content>
    </document>

    <document>
      <source>src/components/ui/textarea.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>649</size>
        <lastModified>2025-05-23T22:47:27.005Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Textarea = React.forwardRef&lt;
  HTMLTextAreaElement,
  React.ComponentProps&lt;&quot;textarea&quot;&gt;
&gt;(({ className, ...props }, ref) =&gt; {
  return (
    &lt;textarea
      className={cn(
        &quot;flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm&quot;,
        className
      )}
      ref={ref}
      {...props}
    /&gt;
  )
})
Textarea.displayName = &quot;Textarea&quot;

export { Textarea }
</content>
    </document>

    <document>
      <source>src/components/ui/checkbox.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1012</size>
        <lastModified>2025-05-22T00:43:04.228Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as CheckboxPrimitive from &quot;@radix-ui/react-checkbox&quot;
import { Check } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

const Checkbox = React.forwardRef&lt;
  React.ElementRef&lt;typeof CheckboxPrimitive.Root&gt;,
  React.ComponentPropsWithoutRef&lt;typeof CheckboxPrimitive.Root&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      &quot;peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground&quot;,
      className
    )}
    {...props}
  &gt;
    &lt;CheckboxPrimitive.Indicator
      className={cn(&quot;flex items-center justify-center text-current&quot;)}
    &gt;
      &lt;Check className=&quot;h-4 w-4&quot; /&gt;
    &lt;/CheckboxPrimitive.Indicator&gt;
  &lt;/CheckboxPrimitive.Root&gt;
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</content>
    </document>

    <document>
      <source>src/components/ui/tabs.tsx</source>
      <tags>ui-primitives</tags>
      <metadata>
        <size>1877</size>
        <lastModified>2025-05-22T00:43:04.230Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TabsPrimitive from &quot;@radix-ui/react-tabs&quot;

import { cn } from &quot;@/lib/utils&quot;

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef&lt;
  React.ElementRef&lt;typeof TabsPrimitive.List&gt;,
  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.List&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;TabsPrimitive.List
    ref={ref}
    className={cn(
      &quot;inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground&quot;,
      className
    )}
    {...props}
  /&gt;
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef&lt;
  React.ElementRef&lt;typeof TabsPrimitive.Trigger&gt;,
  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.Trigger&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      &quot;inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow&quot;,
      className
    )}
    {...props}
  /&gt;
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef&lt;
  React.ElementRef&lt;typeof TabsPrimitive.Content&gt;,
  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.Content&gt;
&gt;(({ className, ...props }, ref) =&gt; (
  &lt;TabsPrimitive.Content
    ref={ref}
    className={cn(
      &quot;mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2&quot;,
      className
    )}
    {...props}
  /&gt;
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</content>
    </document>

    <document>
      <source>src/components/theme/theme-provider.tsx</source>
      <tags>theming-styles,ui-components</tags>
      <metadata>
        <size>1615</size>
        <lastModified>2025-05-22T00:43:04.227Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/theme</directory>
      </metadata>
      <content>// src/components/theme-provider.tsx
import { createContext, useContext, useEffect, useState } from &quot;react&quot;

type Theme = &quot;dark&quot; | &quot;light&quot; | &quot;system&quot;

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) =&gt; void
}

const initialState: ThemeProviderState = {
  theme: &quot;system&quot;,
  setTheme: () =&gt; null,
}

const ThemeProviderContext = createContext&lt;ThemeProviderState&gt;(initialState)

export function ThemeProvider({
  children,
  defaultTheme = &quot;system&quot;,
  storageKey = &quot;vite-ui-theme&quot;,
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState&lt;Theme&gt;(
    () =&gt; (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() =&gt; {
    const root = window.document.documentElement

    root.classList.remove(&quot;light&quot;, &quot;dark&quot;)

    if (theme === &quot;system&quot;) {
      const systemTheme = window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;)
        .matches
        ? &quot;dark&quot;
        : &quot;light&quot;

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) =&gt; {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    &lt;ThemeProviderContext.Provider {...props} value={value}&gt;
      {children}
    &lt;/ThemeProviderContext.Provider&gt;
  )
}

export const useTheme = () =&gt; {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error(&quot;useTheme must be used within a ThemeProvider&quot;)

  return context
}
</content>
    </document>

    <document>
      <source>src/components/theme/mode-toggle.tsx</source>
      <tags>theming-styles,ui-components</tags>
      <metadata>
        <size>1213</size>
        <lastModified>2025-05-22T00:43:04.227Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/theme</directory>
      </metadata>
      <content>import { Moon, Sun } from &quot;lucide-react&quot;

import { Button } from &quot;@/components/ui/button&quot;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from &quot;@/components/ui/dropdown-menu&quot;
import { useTheme } from &quot;@/components/theme/theme-provider&quot;

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    &lt;DropdownMenu&gt;
      &lt;DropdownMenuTrigger asChild&gt;
        &lt;Button variant=&quot;outline&quot; size=&quot;icon&quot;&gt;
          &lt;Sun className=&quot;h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0&quot; /&gt;
          &lt;Moon className=&quot;absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100&quot; /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Toggle theme&lt;/span&gt;
        &lt;/Button&gt;
      &lt;/DropdownMenuTrigger&gt;
      &lt;DropdownMenuContent align=&quot;end&quot;&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;light&quot;)}&gt;
          Light
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;dark&quot;)}&gt;
          Dark
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;system&quot;)}&gt;
          System
        &lt;/DropdownMenuItem&gt;
      &lt;/DropdownMenuContent&gt;
    &lt;/DropdownMenu&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/MainContainer.tsx</source>
      <tags>ui-components,app-core</tags>
      <metadata>
        <size>2132</size>
        <lastModified>2025-05-24T19:56:48.720Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// In src/components/MainContainer.tsx
import { useState } from &#39;react&#39;;
import { Tabs, TabsList, TabsTrigger, TabsContent } from &quot;@/components/ui/tabs&quot;;
import { LayoutDashboard, Archive, Tags, Settings } from &quot;lucide-react&quot;;
import { Dashboard } from &#39;./Dashboard&#39;;
import { BundleMainViewer } from &#39;./BundleMainViewer&#39;;
import { TagsMainViewer } from &#39;./TagsMainViewer&#39;;
import { ConfigPanel } from &#39;./ConfigPanel&#39;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;

export function MainContainer() {
  const [activeTab, setActiveTab] = useState(&#39;dashboard&#39;);
  const { isWatching } = useDirectory();
  const { isProjectInitialized } = useProjectConfig();

  // Don&#39;t show tabs until project is initialized and watching
  if (!isWatching || !isProjectInitialized) {
    return null; // Let Dashboard handle the setup flow
  }

  return (
    &lt;div className=&quot;p-4&quot;&gt;
      &lt;Tabs defaultValue=&quot;dashboard&quot; onValueChange={setActiveTab} value={activeTab}&gt;
        &lt;TabsList className=&quot;mb-4&quot;&gt;
          &lt;TabsTrigger value=&quot;dashboard&quot; className=&quot;flex items-center&quot;&gt;
            &lt;LayoutDashboard className=&quot;mr-2 h-4 w-4&quot; /&gt;
            Dashboard
          &lt;/TabsTrigger&gt;
          &lt;TabsTrigger value=&quot;bundles&quot; className=&quot;flex items-center&quot;&gt;
            &lt;Archive className=&quot;mr-2 h-4 w-4&quot; /&gt;
            Bundles
          &lt;/TabsTrigger&gt;
          &lt;TabsTrigger value=&quot;tags&quot; className=&quot;flex items-center&quot;&gt;
            &lt;Tags className=&quot;mr-2 h-4 w-4&quot; /&gt;
            Tags
          &lt;/TabsTrigger&gt;
          &lt;TabsTrigger value=&quot;config&quot; className=&quot;flex items-center&quot;&gt;
            &lt;Settings className=&quot;mr-2 h-4 w-4&quot; /&gt;
            Config
          &lt;/TabsTrigger&gt;
        &lt;/TabsList&gt;

        &lt;TabsContent value=&quot;dashboard&quot;&gt;
          &lt;Dashboard /&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value=&quot;bundles&quot;&gt;
          &lt;BundleMainViewer /&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value=&quot;tags&quot;&gt;
          &lt;TagsMainViewer /&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value=&quot;config&quot;&gt;
          &lt;ConfigPanel /&gt;
        &lt;/TabsContent&gt;
      &lt;/Tabs&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/ConfigPanel.tsx</source>
      <tags>ui-components,configuration</tags>
      <metadata>
        <size>9863</size>
        <lastModified>2025-05-26T20:46:58.098Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// Updated src/components/ConfigPanel.tsx
import { useState, useEffect } from &#39;react&#39;;
import { Button } from &quot;@/components/ui/button&quot;;
import { Card, CardHeader, CardTitle, CardContent } from &quot;@/components/ui/card&quot;;
import { Settings, Plus, X, FolderOpen, FileText, Zap } from &quot;lucide-react&quot;;
import { Input } from &quot;@/components/ui/input&quot;;
import { Label } from &quot;@/components/ui/label&quot;;
import { Textarea } from &quot;@/components/ui/textarea&quot;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;
import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
import { Separator } from &quot;@/components/ui/separator&quot;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { Tabs, TabsContent, TabsList, TabsTrigger } from &quot;@/components/ui/tabs&quot;;
import { CursorRulesPanel } from &#39;./CursorRulesPanel&#39;;

export function ConfigPanel() {
  const { ignorePatterns, updateIgnorePatterns, projectMetadata, updateProjectMetadata } = useProjectConfig();
  const { currentDirectory } = useDirectory();

  const [patterns, setPatterns] = useState&lt;string[]&gt;([]);
  const [newPattern, setNewPattern] = useState(&#39;&#39;);

  // Project metadata state
  const [projectName, setProjectName] = useState(&#39;&#39;);
  const [projectDescription, setProjectDescription] = useState(&#39;&#39;);
  const [projectVersion, setProjectVersion] = useState(&#39;&#39;);
  const [projectAuthor, setProjectAuthor] = useState(&#39;&#39;);

  useEffect(() =&gt; {
    setPatterns(ignorePatterns);
  }, [ignorePatterns]);

  useEffect(() =&gt; {
    if (projectMetadata) {
      setProjectName(projectMetadata.name || &#39;&#39;);
      setProjectDescription(projectMetadata.description || &#39;&#39;);
      setProjectVersion(projectMetadata.version || &#39;1.0.0&#39;);
      setProjectAuthor(projectMetadata.author || &#39;&#39;);
    }
  }, [projectMetadata]);

  const handleAddPattern = async () =&gt; {
    if (newPattern.trim()) {
      const updatedPatterns = [...patterns, newPattern.trim()];
      setPatterns(updatedPatterns);
      await updateIgnorePatterns(updatedPatterns);
      setNewPattern(&#39;&#39;);
    }
  };

  const handleRemovePattern = async (index: number) =&gt; {
    const updatedPatterns = patterns.filter((_, i) =&gt; i !== index);
    setPatterns(updatedPatterns);
    await updateIgnorePatterns(updatedPatterns);
  };

  const handleUpdateProjectMetadata = async () =&gt; {
    const metadata = {
      name: projectName.trim() || currentDirectory || &#39;Untitled Project&#39;,
      description: projectDescription.trim() || &#39;&#39;,
      version: projectVersion.trim() || &#39;1.0.0&#39;,
      author: projectAuthor.trim() || &#39;&#39;,
      lastUpdated: new Date().toISOString(),
    };

    await updateProjectMetadata(metadata);
  };

  return (
    &lt;div className=&quot;space-y-6&quot;&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;
          &lt;CardTitle className=&quot;flex items-center gap-2&quot;&gt;
            &lt;Settings className=&quot;h-5 w-5&quot; /&gt;
            Project Configuration
          &lt;/CardTitle&gt;
        &lt;/CardHeader&gt;
        &lt;CardContent&gt;
          &lt;Tabs defaultValue=&quot;project&quot; className=&quot;space-y-6&quot;&gt;
            &lt;TabsList className=&quot;grid w-full grid-cols-3&quot;&gt;
              &lt;TabsTrigger value=&quot;project&quot; className=&quot;flex items-center gap-2&quot;&gt;
                &lt;FolderOpen className=&quot;h-4 w-4&quot; /&gt;
                Project Info
              &lt;/TabsTrigger&gt;
              &lt;TabsTrigger value=&quot;ignore&quot; className=&quot;flex items-center gap-2&quot;&gt;
                &lt;X className=&quot;h-4 w-4&quot; /&gt;
                Ignore Patterns
              &lt;/TabsTrigger&gt;
              &lt;TabsTrigger value=&quot;cursor&quot; className=&quot;flex items-center gap-2&quot;&gt;
                &lt;Zap className=&quot;h-4 w-4&quot; /&gt;
                Cursor Rules
              &lt;/TabsTrigger&gt;
            &lt;/TabsList&gt;

            {/* Project Information Tab */}
            &lt;TabsContent value=&quot;project&quot; className=&quot;space-y-6&quot;&gt;
              &lt;div&gt;
                &lt;h3 className=&quot;text-sm font-medium mb-4&quot;&gt;Project Information&lt;/h3&gt;

                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;
                  &lt;div className=&quot;space-y-2&quot;&gt;
                    &lt;Label htmlFor=&quot;project-name&quot;&gt;Project Name&lt;/Label&gt;
                    &lt;Input
                      id=&quot;project-name&quot;
                      value={projectName}
                      onChange={(e) =&gt; setProjectName(e.target.value)}
                      placeholder={currentDirectory || &quot;Enter project name&quot;}
                    /&gt;
                  &lt;/div&gt;

                  &lt;div className=&quot;space-y-2&quot;&gt;
                    &lt;Label htmlFor=&quot;project-version&quot;&gt;Version&lt;/Label&gt;
                    &lt;Input
                      id=&quot;project-version&quot;
                      value={projectVersion}
                      onChange={(e) =&gt; setProjectVersion(e.target.value)}
                      placeholder=&quot;1.0.0&quot;
                    /&gt;
                  &lt;/div&gt;

                  &lt;div className=&quot;space-y-2&quot;&gt;
                    &lt;Label htmlFor=&quot;project-author&quot;&gt;Author&lt;/Label&gt;
                    &lt;Input
                      id=&quot;project-author&quot;
                      value={projectAuthor}
                      onChange={(e) =&gt; setProjectAuthor(e.target.value)}
                      placeholder=&quot;Your name or organization&quot;
                    /&gt;
                  &lt;/div&gt;

                  &lt;div className=&quot;space-y-2 md:col-span-2&quot;&gt;
                    &lt;Label htmlFor=&quot;project-description&quot;&gt;Description&lt;/Label&gt;
                    &lt;Textarea
                      id=&quot;project-description&quot;
                      value={projectDescription}
                      onChange={(e) =&gt; setProjectDescription(e.target.value)}
                      placeholder=&quot;Brief description of your project&quot;
                      className=&quot;min-h-[80px]&quot;
                    /&gt;
                  &lt;/div&gt;
                &lt;/div&gt;

                &lt;div className=&quot;mt-4&quot;&gt;
                  &lt;Button onClick={handleUpdateProjectMetadata}&gt;
                    &lt;FileText className=&quot;mr-2 h-4 w-4&quot; /&gt;
                    Update Project Info
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/TabsContent&gt;

            {/* Ignore Patterns Tab */}
            &lt;TabsContent value=&quot;ignore&quot; className=&quot;space-y-6&quot;&gt;
              &lt;div&gt;
                &lt;h3 className=&quot;text-sm font-medium mb-4&quot;&gt;Ignore Patterns&lt;/h3&gt;
                &lt;p className=&quot;text-xs text-muted-foreground mb-4&quot;&gt;
                  Files and directories matching these patterns will be excluded from bundles and file tracking.
                &lt;/p&gt;

                &lt;div className=&quot;flex gap-2 mb-4&quot;&gt;
                  &lt;Input
                    value={newPattern}
                    onChange={(e) =&gt; setNewPattern(e.target.value)}
                    placeholder=&quot;Add new pattern (e.g., *.log, node_modules)&quot;
                    onKeyDown={(e) =&gt; {
                      if (e.key === &#39;Enter&#39;) {
                        handleAddPattern();
                      }
                    }}
                  /&gt;
                  &lt;Button onClick={handleAddPattern} disabled={!newPattern.trim()}&gt;
                    &lt;Plus className=&quot;h-4 w-4&quot; /&gt;
                  &lt;/Button&gt;
                &lt;/div&gt;

                &lt;ScrollArea className=&quot;h-[300px] pr-4&quot;&gt;
                  &lt;div className=&quot;space-y-2&quot;&gt;
                    {patterns.length === 0 ? (
                      &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
                        &lt;X className=&quot;h-8 w-8 mx-auto mb-2 opacity-50&quot; /&gt;
                        &lt;p&gt;No ignore patterns configured&lt;/p&gt;
                        &lt;p className=&quot;text-xs&quot;&gt;Add patterns to exclude files from bundles&lt;/p&gt;
                      &lt;/div&gt;
                    ) : (
                      patterns.map((pattern, index) =&gt; (
                        &lt;div
                          key={index}
                          className=&quot;flex items-center justify-between px-3 py-2 rounded-md border bg-muted/40 hover:bg-muted/60 transition-colors&quot;
                        &gt;
                          &lt;code className=&quot;text-xs font-mono&quot;&gt;{pattern}&lt;/code&gt;
                          &lt;Button
                            variant=&quot;ghost&quot;
                            size=&quot;sm&quot;
                            onClick={() =&gt; handleRemovePattern(index)}
                            className=&quot;h-8 w-8 p-0 hover:bg-destructive/10 hover:text-destructive&quot;
                          &gt;
                            &lt;X className=&quot;h-4 w-4&quot; /&gt;
                          &lt;/Button&gt;
                        &lt;/div&gt;
                      ))
                    )}
                  &lt;/div&gt;
                &lt;/ScrollArea&gt;
              &lt;/div&gt;
            &lt;/TabsContent&gt;

            {/* Cursor Rules Tab - SIMPLIFIED */}
            &lt;TabsContent value=&quot;cursor&quot;&gt;
              &lt;CursorRulesPanel /&gt;
            &lt;/TabsContent&gt;
          &lt;/Tabs&gt;

          {/* Summary */}
          &lt;Separator className=&quot;my-6&quot; /&gt;
          &lt;div className=&quot;bg-muted/30 rounded-lg p-4&quot;&gt;
            &lt;h4 className=&quot;text-sm font-medium mb-2&quot;&gt;Configuration Summary&lt;/h4&gt;
            &lt;div className=&quot;grid grid-cols-2 gap-4 text-xs&quot;&gt;
              &lt;div&gt;
                &lt;span className=&quot;text-muted-foreground&quot;&gt;Project:&lt;/span&gt;
                &lt;span className=&quot;ml-2 font-medium&quot;&gt;
                  {projectName || currentDirectory || &#39;Untitled&#39;}
                &lt;/span&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;span className=&quot;text-muted-foreground&quot;&gt;Ignore Patterns:&lt;/span&gt;
                &lt;span className=&quot;ml-2 font-medium&quot;&gt;{patterns.length}&lt;/span&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;span className=&quot;text-muted-foreground&quot;&gt;Version:&lt;/span&gt;
                &lt;span className=&quot;ml-2 font-medium&quot;&gt;{projectVersion || &#39;1.0.0&#39;}&lt;/span&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;span className=&quot;text-muted-foreground&quot;&gt;Author:&lt;/span&gt;
                &lt;span className=&quot;ml-2 font-medium&quot;&gt;{projectAuthor || &#39;Not set&#39;}&lt;/span&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/BundleView.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>29007</size>
        <lastModified>2025-05-27T01:52:28.567Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/BundleView.tsx - Fixed to handle all bundle types
import { useState, useEffect } from &#39;react&#39;;
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
  CardFooter
} from &quot;@/components/ui/card&quot;;
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from &quot;@/components/ui/table&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
import { Badge } from &quot;@/components/ui/badge&quot;;
import {
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent
} from &quot;@/components/ui/tabs&quot;;
import { Progress } from &quot;@/components/ui/progress&quot;;
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from &quot;@/components/ui/select&quot;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { Bundle, BundleManifest, BundleType } from &#39;@/types/types&#39;;
import {
  analyzeBundleHealth,
  getStalenessColor,
  getSortedTags
} from &#39;@/utils/bundle-utils&#39;;
import {
  Copy,
  Download,
  FileText,
  Tag,
  AlertCircle,
  RefreshCw,
  ListFilter,
  ChevronDown,
  AlertTriangle,
  FileCheck,
  FileEdit
} from &quot;lucide-react&quot;;

interface BundleViewProps {
  bundle: Bundle;
  onClose?: () =&gt; void;
}

export function BundleView({ bundle, onClose }: BundleViewProps) {
  const { directoryHandle } = useDirectory();
  const { watchedFiles } = useFiles();
  const { tags: allTags } = useTags();

  const [content, setContent] = useState&lt;string | null&gt;(null);
  const [manifest, setManifest] = useState&lt;BundleManifest | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [activeTab, setActiveTab] = useState(&#39;content&#39;);
  const [showFilter, setShowFilter] = useState(false);
  const [filePathFilter, setFilePathFilter] = useState(&#39;&#39;);
  const [tagFilter, setTagFilter] = useState&lt;string | null&gt;(null);

  // Staleness metrics
  const [staleFiles, setStaleFiles] = useState&lt;string[]&gt;([]);
  const [freshFiles, setFreshFiles] = useState&lt;string[]&gt;([]);
  const [missingFiles, setMissingFiles] = useState&lt;string[]&gt;([]);
  const [staleness, setStaleness] = useState(0);
  const [tagCounts, setTagCounts] = useState&lt;Record&lt;string, number&gt;&gt;({});

  // FIXED: Safe bundle file access that handles all bundle types
  const getBundleFileHandle = async (bundle: Bundle): Promise&lt;FileSystemFileHandle | null&gt; =&gt; {
    if (!directoryHandle) return null;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);

      // Determine bundle type with fallbacks for existing bundles
      let bundleType: BundleType = bundle.type;
      if (!bundleType) {
        if (bundle.name.startsWith(&#39;master-&#39;)) {
          bundleType = &#39;master&#39;;
        } else if (bundle.derivedFromTag) {
          bundleType = &#39;tag-derived&#39;;
        } else {
          bundleType = &#39;custom&#39;;
        }
      }

      console.log(`🔍 Accessing bundle: ${bundle.name}, type: ${bundleType}`);

      // Handle different bundle types with proper path resolution
      switch (bundleType) {
        case &#39;master&#39;: {
          console.log(&#39;📁 Loading master bundle...&#39;);
          const masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true });
          return await masterDir.getFileHandle(bundle.name);
        }
        case &#39;tag-derived&#39;: {
          const tagName = bundle.derivedFromTag;
          if (!tagName) {
            console.error(&#39;Tag-derived bundle missing derivedFromTag:&#39;, bundle);
            throw new Error(&#39;Tag-derived bundle is missing tag information&#39;);
          }
          console.log(`🏷️  Loading tag-derived bundle from tag: ${tagName}`);
          const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;);
          const tagDir = await tagBundlesDir.getDirectoryHandle(tagName);
          return await tagDir.getFileHandle(bundle.name);
        }
        case &#39;custom&#39;:
        default: {
          console.log(&#39;📦 Loading custom bundle...&#39;);
          return await bundlesDir.getFileHandle(bundle.name);
        }
      }
    } catch (error) {
      console.error(`❌ Failed to get file handle for bundle ${bundle.name}:`, error);
      throw error;
    }
  };

  // FIXED: Safe manifest loading that handles all bundle types
  const loadBundleManifestSafe = async (bundle: Bundle): Promise&lt;BundleManifest | null&gt; =&gt; {
    if (!directoryHandle) return null;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);

      // Determine bundle type and manifest location
      let bundleType: BundleType = bundle.type;
      if (!bundleType) {
        if (bundle.name.startsWith(&#39;master-&#39;)) {
          bundleType = &#39;master&#39;;
        } else if (bundle.derivedFromTag) {
          bundleType = &#39;tag-derived&#39;;
        } else {
          bundleType = &#39;custom&#39;;
        }
      }

      const bundleId = bundle.name.replace(/\.txt$/, &#39;&#39;);
      const manifestName = `${bundleId}-manifest.json`;

      console.log(`📋 Loading manifest: ${manifestName} for ${bundleType} bundle`);

      let manifestDir: FileSystemDirectoryHandle;
      switch (bundleType) {
        case &#39;master&#39;:
          manifestDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true });
          break;
        case &#39;tag-derived&#39;:
          const tagName = bundle.derivedFromTag;
          if (!tagName) {
            console.error(&#39;Tag-derived bundle missing derivedFromTag:&#39;, bundle);
            return null;
          }
          const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;);
          manifestDir = await tagBundlesDir.getDirectoryHandle(tagName);
          break;
        case &#39;custom&#39;:
        default:
          manifestDir = bundlesDir;
          break;
      }

      const manifestFile = await manifestDir.getFileHandle(manifestName);
      const manifestContent = await manifestFile.getFile().then(f =&gt; f.text());
      const manifest = JSON.parse(manifestContent);

      console.log(`✅ Successfully loaded manifest for ${bundle.name}`);
      return manifest;
    } catch (error) {
      console.error(`❌ Error loading manifest for ${bundle.name}:`, error);
      return null;
    }
  };

  // Load bundle content and analyze it
  useEffect(() =&gt; {
    async function loadBundle() {
      if (!directoryHandle || !bundle) {
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        console.log(`🔄 Loading bundle: ${bundle.name}`);

        // Load bundle content using safe method
        const bundleHandle = await getBundleFileHandle(bundle);
        if (!bundleHandle) {
          throw new Error(&#39;Could not access bundle file&#39;);
        }

        const file = await bundleHandle.getFile();
        const content = await file.text();
        setContent(content);
        console.log(`✅ Bundle content loaded: ${content.length} characters`);

        // Load manifest using safe method
        const loadedManifest = await loadBundleManifestSafe(bundle);
        setManifest(loadedManifest);

        // Analyze bundle health if manifest is available
        if (loadedManifest) {
          console.log(&#39;🔍 Analyzing bundle health...&#39;);
          const analysis = await analyzeBundleHealth(bundle, loadedManifest, watchedFiles);
          setStaleFiles(analysis.staleFiles);
          setFreshFiles(analysis.freshFiles);
          setMissingFiles(analysis.missingFiles);
          setStaleness(analysis.staleness);
          setTagCounts(analysis.tags);
          console.log(`📊 Analysis complete: ${analysis.staleness}% stale`);
        }
      } catch (error) {
        console.error(&#39;❌ Error loading bundle:&#39;, error);
        setError(`Failed to load bundle: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        setLoading(false);
      }
    }

    loadBundle();
  }, [bundle, directoryHandle, watchedFiles]);

  // Extract all files from the content
  const extractFiles = () =&gt; {
    if (!content) return [];

    // Handle both old format (without tags) and new format (with tags)
    const newFormatRegex = /&lt;document&gt;\s*&lt;source&gt;(.*?)&lt;\/source&gt;\s*&lt;tags&gt;(.*?)&lt;\/tags&gt;/g;
    const oldFormatRegex = /&lt;document&gt;\s*&lt;source&gt;(.*?)&lt;\/source&gt;/g;

    // Try new format first
    const newMatches = Array.from(content.matchAll(newFormatRegex));
    if (newMatches.length &gt; 0) {
      return newMatches.map(match =&gt; ({
        path: match[1],
        tags: match[2] ? match[2].split(&#39;,&#39;).filter(t =&gt; t.trim()) : []
      }));
    }

    // Fall back to old format
    const oldMatches = Array.from(content.matchAll(oldFormatRegex));
    return oldMatches.map(match =&gt; ({
      path: match[1],
      tags: []
    }));
  };

  const allFiles = extractFiles();

  // Filter files
  const filteredFiles = allFiles.filter(file =&gt; {
    const pathMatches = file.path.toLowerCase().includes(filePathFilter.toLowerCase());
    const tagMatches = !tagFilter || file.tags.includes(tagFilter);
    return pathMatches &amp;&amp; tagMatches;
  });

  // Copy content to clipboard
  const copyContent = async () =&gt; {
    if (!content) return;

    try {
      await navigator.clipboard.writeText(content);
      console.log(&#39;✅ Bundle content copied to clipboard&#39;);
    } catch (error) {
      console.error(&#39;❌ Failed to copy content:&#39;, error);
    }
  };

  // Download bundle as a file
  const downloadBundle = () =&gt; {
    if (!content || !bundle) return;

    const blob = new Blob([content], { type: &#39;text/plain&#39; });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(&#39;a&#39;);
    a.href = url;
    a.download = bundle.name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log(`✅ Bundle downloaded: ${bundle.name}`);
  };

  // Get a readable creation date
  const creationDate = bundle.timestamp.toLocaleString();

  // Get the staleness color and label
  const stalenessColor = getStalenessColor(staleness);
  const stalenessLabel =
    staleness === 0 ? &#39;Fresh&#39; :
      staleness &lt; 25 ? &#39;Mostly Fresh&#39; :
        staleness &lt; 50 ? &#39;Somewhat Stale&#39; :
          staleness &lt; 75 ? &#39;Stale&#39; :
            &#39;Very Stale&#39;;

  // Loading state
  if (loading) {
    return (
      &lt;Card&gt;
        &lt;CardContent className=&quot;p-6&quot;&gt;
          &lt;div className=&quot;flex items-center justify-center py-12&quot;&gt;
            &lt;RefreshCw className=&quot;h-6 w-6 animate-spin mr-2&quot; /&gt;
            &lt;span&gt;Loading bundle...&lt;/span&gt;
          &lt;/div&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;
    );
  }

  // Error state
  if (error) {
    return (
      &lt;Card&gt;
        &lt;CardHeader&gt;
          &lt;CardTitle className=&quot;flex items-center text-red-500&quot;&gt;
            &lt;AlertCircle className=&quot;mr-2 h-5 w-5&quot; /&gt;
            Error Loading Bundle
          &lt;/CardTitle&gt;
        &lt;/CardHeader&gt;
        &lt;CardContent&gt;
          &lt;div className=&quot;space-y-4&quot;&gt;
            &lt;p className=&quot;text-sm&quot;&gt;{error}&lt;/p&gt;
            &lt;div className=&quot;text-xs text-muted-foreground bg-muted p-3 rounded&quot;&gt;
              &lt;strong&gt;Bundle Details:&lt;/strong&gt;&lt;br /&gt;
              • Name: {bundle.name}&lt;br /&gt;
              • Type: {bundle.type || &#39;unknown&#39;}&lt;br /&gt;
              • Derived from tag: {bundle.derivedFromTag || &#39;none&#39;}&lt;br /&gt;
              • ID: {bundle.id}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/CardContent&gt;
        &lt;CardFooter&gt;
          &lt;Button onClick={onClose}&gt;Close&lt;/Button&gt;
        &lt;/CardFooter&gt;
      &lt;/Card&gt;
    );
  }

  // Extract ASCII tree from bundle content
  const extractASCIITree = () =&gt; {
    if (!content) return null;
    const asciiMatch = content.match(/&lt;asciiTree&gt;([\s\S]*?)&lt;\/asciiTree&gt;/);
    return asciiMatch ? asciiMatch[1].trim() : null;
  };

  // Extract metadata from bundle content
  const extractMetadata = () =&gt; {
    if (!content) return null;

    const metadataMatch = content.match(/&lt;metadata&gt;([\s\S]*?)&lt;\/metadata&gt;/);
    if (!metadataMatch) return null;

    const metadataContent = metadataMatch[1];

    // Extract individual fields
    const projectNameMatch = metadataContent.match(/&lt;projectName&gt;(.*?)&lt;\/projectName&gt;/);
    const totalFilesMatch = metadataContent.match(/&lt;totalFiles&gt;(.*?)&lt;\/totalFiles&gt;/);
    const bundleTypeMatch = metadataContent.match(/&lt;bundleType&gt;(.*?)&lt;\/bundleType&gt;/);

    // Extract ignore patterns
    const ignorePatternsMatch = metadataContent.match(/&lt;ignorePatterns&gt;([\s\S]*?)&lt;\/ignorePatterns&gt;/);
    const ignorePatterns: string[] = [];

    if (ignorePatternsMatch) {
      const patternMatches = ignorePatternsMatch[1].matchAll(/&lt;pattern&gt;(.*?)&lt;\/pattern&gt;/g);
      for (const match of patternMatches) {
        ignorePatterns.push(match[1]);
      }
    }

    return {
      projectName: projectNameMatch?.[1] || &#39;Unknown&#39;,
      totalFiles: parseInt(totalFilesMatch?.[1] || &#39;0&#39;),
      bundleType: bundleTypeMatch?.[1] || &#39;unknown&#39;,
      ignorePatterns
    };
  };

  const asciiTree = extractASCIITree();
  const bundleMetadata = extractMetadata();

  return (
    &lt;Card className=&quot;w-full&quot;&gt;
      &lt;CardHeader&gt;
        &lt;div className=&quot;flex justify-between items-start&quot;&gt;
          &lt;div&gt;
            &lt;CardTitle&gt;{bundle.name}&lt;/CardTitle&gt;
            &lt;CardDescription&gt;
              Created on {creationDate} • {bundle.fileCount} files
              {manifest &amp;&amp; ` • ${100 - staleness}% fresh`}
              {bundle.description &amp;&amp; (
                &lt;span className=&quot;block text-xs mt-1 opacity-75&quot;&gt;
                  {bundle.description}
                &lt;/span&gt;
              )}
            &lt;/CardDescription&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex space-x-2&quot;&gt;
            {manifest &amp;&amp; (
              &lt;Badge
                className={`bg-${stalenessColor}-500 hover:bg-${stalenessColor}-600`}
                style={{ backgroundColor: stalenessColor }}
              &gt;
                {stalenessLabel}
              &lt;/Badge&gt;
            )}
            {bundle.type &amp;&amp; (
              &lt;Badge variant=&quot;outline&quot;&gt;
                {bundle.type === &#39;tag-derived&#39; &amp;&amp; bundle.derivedFromTag ? (
                  &lt;&gt;
                    &lt;Tag className=&quot;h-3 w-3 mr-1&quot; /&gt;
                    {bundle.derivedFromTag}
                  &lt;/&gt;
                ) : (
                  bundle.type
                )}
              &lt;/Badge&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;Tabs value={activeTab} onValueChange={setActiveTab}&gt;
          &lt;TabsList className=&quot;mb-4&quot;&gt;
            &lt;TabsTrigger value=&quot;content&quot; className=&quot;flex items-center gap-1&quot;&gt;
              &lt;FileText className=&quot;h-4 w-4&quot; /&gt;
              Files ({allFiles.length})
            &lt;/TabsTrigger&gt;
            {manifest &amp;&amp; (
              &lt;TabsTrigger value=&quot;analysis&quot; className=&quot;flex items-center gap-1&quot;&gt;
                &lt;FileEdit className=&quot;h-4 w-4&quot; /&gt;
                Analysis
              &lt;/TabsTrigger&gt;
            )}
            &lt;TabsTrigger value=&quot;tags&quot; className=&quot;flex items-center gap-1&quot;&gt;
              &lt;Tag className=&quot;h-4 w-4&quot; /&gt;
              Tags ({Object.keys(tagCounts).length})
            &lt;/TabsTrigger&gt;
            &lt;TabsTrigger value=&quot;raw&quot; className=&quot;flex items-center gap-1&quot;&gt;
              &lt;FileText className=&quot;h-4 w-4&quot; /&gt;
              Raw Content
            &lt;/TabsTrigger&gt;
          &lt;/TabsList&gt;

          {/* Files Tab */}
          &lt;TabsContent value=&quot;content&quot;&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
              &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                &lt;div className=&quot;flex items-center&quot;&gt;
                  &lt;Button
                    variant=&quot;outline&quot;
                    size=&quot;sm&quot;
                    onClick={() =&gt; setShowFilter(!showFilter)}
                    className=&quot;mr-2&quot;
                  &gt;
                    &lt;ListFilter className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Filter
                    &lt;ChevronDown className=&quot;h-4 w-4 ml-1&quot; /&gt;
                  &lt;/Button&gt;

                  {showFilter &amp;&amp; (
                    &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                      &lt;input
                        type=&quot;text&quot;
                        value={filePathFilter}
                        onChange={(e) =&gt; setFilePathFilter(e.target.value)}
                        placeholder=&quot;Filter by path...&quot;
                        className=&quot;ml-2 px-2 py-1 text-sm border rounded&quot;
                      /&gt;

                      &lt;Select
                        value={tagFilter || &quot;all&quot;}
                        onValueChange={(value) =&gt; setTagFilter(value === &quot;all&quot; ? null : value)}
                      &gt;
                        &lt;SelectTrigger className=&quot;w-[180px]&quot;&gt;
                          &lt;SelectValue placeholder=&quot;Filter by tag&quot; /&gt;
                        &lt;/SelectTrigger&gt;
                        &lt;SelectContent&gt;
                          &lt;SelectItem value=&quot;all&quot;&gt;All tags&lt;/SelectItem&gt;
                          {Object.keys(allTags).map(tag =&gt; (
                            &lt;SelectItem key={tag} value={tag}&gt;
                              &lt;div className=&quot;flex items-center&quot;&gt;
                                &lt;div
                                  className=&quot;w-2 h-2 rounded-full mr-2&quot;
                                  style={{ backgroundColor: allTags[tag]?.color || &#39;#888&#39; }}
                                /&gt;
                                {tag}
                              &lt;/div&gt;
                            &lt;/SelectItem&gt;
                          ))}
                        &lt;/SelectContent&gt;
                      &lt;/Select&gt;
                    &lt;/div&gt;
                  )}
                &lt;/div&gt;

                &lt;div className=&quot;flex space-x-2&quot;&gt;
                  &lt;Button
                    variant=&quot;outline&quot;
                    size=&quot;sm&quot;
                    onClick={copyContent}
                  &gt;
                    &lt;Copy className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Copy
                  &lt;/Button&gt;

                  &lt;Button
                    variant=&quot;outline&quot;
                    size=&quot;sm&quot;
                    onClick={downloadBundle}
                  &gt;
                    &lt;Download className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Download
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;

              &lt;ScrollArea className=&quot;h-[400px] w-full rounded-md border&quot;&gt;
                &lt;Table&gt;
                  &lt;TableHeader&gt;
                    &lt;TableRow&gt;
                      &lt;TableHead className=&quot;w-4/5&quot;&gt;Path&lt;/TableHead&gt;
                      &lt;TableHead&gt;Status&lt;/TableHead&gt;
                    &lt;/TableRow&gt;
                  &lt;/TableHeader&gt;
                  &lt;TableBody&gt;
                    {filteredFiles.length === 0 ? (
                      &lt;TableRow&gt;
                        &lt;TableCell colSpan={2} className=&quot;text-center text-muted-foreground&quot;&gt;
                          No files found
                        &lt;/TableCell&gt;
                      &lt;/TableRow&gt;
                    ) : (
                      filteredFiles.map((fileInfo) =&gt; {
                        let status = &#39;Unknown&#39;;
                        let icon = null;

                        if (staleFiles.includes(fileInfo.path)) {
                          status = &#39;Stale&#39;;
                          icon = &lt;FileEdit className=&quot;h-4 w-4 text-amber-500&quot; /&gt;;
                        } else if (freshFiles.includes(fileInfo.path)) {
                          status = &#39;Fresh&#39;;
                          icon = &lt;FileCheck className=&quot;h-4 w-4 text-green-500&quot; /&gt;;
                        } else if (missingFiles.includes(fileInfo.path)) {
                          status = &#39;Missing&#39;;
                          icon = &lt;AlertTriangle className=&quot;h-4 w-4 text-red-500&quot; /&gt;;
                        }

                        // Get tags from the extracted file info
                        const fileTags = fileInfo.tags || [];

                        return (
                          &lt;TableRow key={fileInfo.path}&gt;
                            &lt;TableCell className=&quot;font-mono text-xs&quot;&gt;
                              &lt;div className=&quot;flex items-center&quot;&gt;
                                &lt;FileText className=&quot;h-4 w-4 mr-2 text-muted-foreground&quot; /&gt;
                                &lt;span className=&quot;truncate&quot;&gt;{fileInfo.path}&lt;/span&gt;
                              &lt;/div&gt;
                              {fileTags.length &gt; 0 &amp;&amp; (
                                &lt;div className=&quot;flex flex-wrap gap-1 mt-1 ml-6&quot;&gt;
                                  {fileTags.map(tag =&gt; (
                                    &lt;Badge
                                      key={tag}
                                      variant=&quot;outline&quot;
                                      className=&quot;text-xs&quot;
                                      style={{
                                        borderColor: allTags[tag]?.color || &#39;#888&#39;,
                                        backgroundColor: `${allTags[tag]?.color}11` || &#39;transparent&#39;
                                      }}
                                    &gt;
                                      {tag}
                                    &lt;/Badge&gt;
                                  ))}
                                &lt;/div&gt;
                              )}
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              &lt;div className=&quot;flex items-center&quot;&gt;
                                {icon}
                                &lt;span className=&quot;ml-1&quot;&gt;{status}&lt;/span&gt;
                              &lt;/div&gt;
                            &lt;/TableCell&gt;
                          &lt;/TableRow&gt;
                        );
                      })
                    )}
                  &lt;/TableBody&gt;
                &lt;/Table&gt;
              &lt;/ScrollArea&gt;
            &lt;/div&gt;
          &lt;/TabsContent&gt;

          {/* Analysis Tab - only show if manifest exists */}
          {manifest &amp;&amp; (
            &lt;TabsContent value=&quot;analysis&quot;&gt;
              &lt;div className=&quot;space-y-6&quot;&gt;
                {/* Staleness indicator */}
                &lt;div className=&quot;space-y-2&quot;&gt;
                  &lt;div className=&quot;flex justify-between text-sm&quot;&gt;
                    &lt;span&gt;Bundle Freshness&lt;/span&gt;
                    &lt;span&gt;{100 - staleness}%&lt;/span&gt;
                  &lt;/div&gt;
                  &lt;Progress
                    value={100 - staleness}
                    className=&quot;h-2&quot;
                  /&gt;
                  &lt;div className=&quot;flex justify-between text-xs text-muted-foreground&quot;&gt;
                    &lt;span&gt;
                      {freshFiles.length} fresh, {staleFiles.length} stale
                      {missingFiles.length &gt; 0 &amp;&amp; `, ${missingFiles.length} missing`}
                    &lt;/span&gt;
                    &lt;span&gt;
                      Created {bundle.timestamp.toLocaleDateString()},
                      {bundle.timestamp.toLocaleTimeString()}
                    &lt;/span&gt;
                  &lt;/div&gt;
                &lt;/div&gt;

                {/* File statistics */}
                &lt;div className=&quot;grid grid-cols-3 gap-4&quot;&gt;
                  &lt;Card&gt;
                    &lt;CardHeader className=&quot;py-3&quot;&gt;
                      &lt;CardTitle className=&quot;text-sm flex items-center&quot;&gt;
                        &lt;FileCheck className=&quot;h-4 w-4 mr-2 text-green-500&quot; /&gt;
                        Fresh Files
                      &lt;/CardTitle&gt;
                    &lt;/CardHeader&gt;
                    &lt;CardContent className=&quot;py-2&quot;&gt;
                      &lt;div className=&quot;text-2xl font-bold&quot;&gt;{freshFiles.length}&lt;/div&gt;
                    &lt;/CardContent&gt;
                  &lt;/Card&gt;

                  &lt;Card&gt;
                    &lt;CardHeader className=&quot;py-3&quot;&gt;
                      &lt;CardTitle className=&quot;text-sm flex items-center&quot;&gt;
                        &lt;FileEdit className=&quot;h-4 w-4 mr-2 text-amber-500&quot; /&gt;
                        Stale Files
                      &lt;/CardTitle&gt;
                    &lt;/CardHeader&gt;
                    &lt;CardContent className=&quot;py-2&quot;&gt;
                      &lt;div className=&quot;text-2xl font-bold&quot;&gt;{staleFiles.length}&lt;/div&gt;
                    &lt;/CardContent&gt;
                  &lt;/Card&gt;

                  &lt;Card&gt;
                    &lt;CardHeader className=&quot;py-3&quot;&gt;
                      &lt;CardTitle className=&quot;text-sm flex items-center&quot;&gt;
                        &lt;AlertTriangle className=&quot;h-4 w-4 mr-2 text-red-500&quot; /&gt;
                        Missing Files
                      &lt;/CardTitle&gt;
                    &lt;/CardHeader&gt;
                    &lt;CardContent className=&quot;py-2&quot;&gt;
                      &lt;div className=&quot;text-2xl font-bold&quot;&gt;{missingFiles.length}&lt;/div&gt;
                    &lt;/CardContent&gt;
                  &lt;/Card&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/TabsContent&gt;
          )}

          {/* Tags Tab */}
          &lt;TabsContent value=&quot;tags&quot;&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
              {Object.keys(tagCounts).length &gt; 0 ? (
                &lt;&gt;
                  &lt;h3 className=&quot;text-sm font-medium&quot;&gt;Tags in Bundle&lt;/h3&gt;
                  &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;
                    {getSortedTags(tagCounts).map(([tagName, count]) =&gt; (
                      &lt;Card key={tagName}&gt;
                        &lt;CardHeader className=&quot;py-3&quot;&gt;
                          &lt;CardTitle className=&quot;text-sm flex items-center&quot;&gt;
                            &lt;div
                              className=&quot;w-3 h-3 rounded-full mr-2&quot;
                              style={{ backgroundColor: allTags[tagName]?.color || &#39;#888&#39; }}
                            /&gt;
                            {tagName}
                          &lt;/CardTitle&gt;
                          &lt;CardDescription&gt;
                            {allTags[tagName]?.description || &#39;No description&#39;}
                          &lt;/CardDescription&gt;
                        &lt;/CardHeader&gt;
                        &lt;CardContent className=&quot;py-2&quot;&gt;
                          &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                            &lt;div className=&quot;text-2xl font-bold&quot;&gt;{count}&lt;/div&gt;
                            &lt;div className=&quot;text-sm&quot;&gt;
                              {Math.round((count / bundle.fileCount) * 100)}% of bundle
                            &lt;/div&gt;
                          &lt;/div&gt;

                          &lt;div className=&quot;mt-2&quot;&gt;
                            &lt;Progress
                              value={(count / bundle.fileCount) * 100}
                              className=&quot;h-1&quot;
                            /&gt;
                          &lt;/div&gt;
                        &lt;/CardContent&gt;
                      &lt;/Card&gt;
                    ))}
                  &lt;/div&gt;
                &lt;/&gt;
              ) : (
                &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
                  &lt;Tag className=&quot;h-8 w-8 mx-auto mb-2&quot; /&gt;
                  &lt;p&gt;No tags found in this bundle.&lt;/p&gt;
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          &lt;/TabsContent&gt;

          {/* Raw Content Tab */}
          &lt;TabsContent value=&quot;raw&quot;&gt;
            &lt;div className=&quot;space-y-4&quot;&gt;
              &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                &lt;h3 className=&quot;text-sm font-medium&quot;&gt;Bundle Raw Content&lt;/h3&gt;
                &lt;div className=&quot;flex space-x-2&quot;&gt;
                  &lt;Button
                    variant=&quot;outline&quot;
                    size=&quot;sm&quot;
                    onClick={copyContent}
                  &gt;
                    &lt;Copy className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Copy
                  &lt;/Button&gt;
                  &lt;Button
                    variant=&quot;outline&quot;
                    size=&quot;sm&quot;
                    onClick={downloadBundle}
                  &gt;
                    &lt;Download className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Download
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;

              {content ? (
                &lt;Card&gt;
                  &lt;CardContent className=&quot;p-0&quot;&gt;
                    &lt;ScrollArea className=&quot;h-[600px] w-full&quot;&gt;
                      &lt;pre className=&quot;text-xs font-mono whitespace-pre-wrap p-4 leading-relaxed&quot;&gt;
                        {content}
                      &lt;/pre&gt;
                    &lt;/ScrollArea&gt;
                  &lt;/CardContent&gt;
                &lt;/Card&gt;
              ) : (
                &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
                  &lt;FileText className=&quot;h-8 w-8 mx-auto mb-2&quot; /&gt;
                  &lt;p&gt;No content available&lt;/p&gt;
                &lt;/div&gt;
              )}

              &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                Content length: {content?.length.toLocaleString() || 0} characters
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/TabsContent&gt;
        &lt;/Tabs&gt;
      &lt;/CardContent&gt;
      &lt;CardFooter&gt;
        &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
          {bundle.fileCount} files • {content?.length.toLocaleString() || 0} bytes
          {bundle.type &amp;&amp; ` • ${bundle.type} bundle`}
        &lt;/div&gt;
      &lt;/CardFooter&gt;
    &lt;/Card&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/FileTagsDisplay.tsx</source>
      <tags>ui-components,business-logic</tags>
      <metadata>
        <size>3459</size>
        <lastModified>2025-05-26T22:06:10.781Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/FileTagsDisplay.tsx
import { Button } from &#39;@/components/ui/button&#39;;
import { Paintbrush, X } from &#39;lucide-react&#39;;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger
} from &#39;@/components/ui/dropdown-menu&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;

interface FileTagsDisplayProps {
  filePath: string;
  className?: string;
}

export function FileTagsDisplay({ filePath, className = &#39;&#39; }: FileTagsDisplayProps) {
  const { tags, addTagToFiles, removeTagFromFiles } = useTags();
  const { watchedFiles, refreshFiles } = useFiles();

  // Get the file&#39;s current tags from watchedFiles
  const currentFile = watchedFiles.find(file =&gt; file.path === filePath);
  const fileTags = currentFile?.tags || [];

  const handleAddTag = async (tagName: string) =&gt; {
    try {
      await addTagToFiles(tagName, [filePath]);
      // Force a refresh of the files to update the UI
      await refreshFiles();
    } catch (error) {
      console.error(&#39;Error adding tag:&#39;, error);
    }
  };

  const handleRemoveTag = async (tagName: string) =&gt; {
    try {
      await removeTagFromFiles(tagName, [filePath]);
      // Force a refresh of the files to update the UI
      await refreshFiles();
    } catch (error) {
      console.error(&#39;Error removing tag:&#39;, error);
    }
  };

  return (
    &lt;div className={`flex items-center gap-2 ${className}`}&gt;
      {fileTags.map(tagName =&gt; {
        const tagConfig = tags[tagName];
        return (
          &lt;div
            key={tagName}
            className=&quot;h-1 w-1 rounded-full&quot;
            style={{ backgroundColor: tagConfig?.color || &#39;#94a3b8&#39; }}
            title={tagName}
          /&gt;
        );
      })}

      &lt;DropdownMenu&gt;
        &lt;DropdownMenuTrigger asChild&gt;
          &lt;Button
            variant=&quot;outline&quot;
            size=&quot;icon&quot;
            className=&quot;h-6 w-6 text-muted-foreground hover:text-foreground&quot;
          &gt;
            &lt;Paintbrush className=&quot;h-4 w-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/DropdownMenuTrigger&gt;
        &lt;DropdownMenuContent&gt;
          &lt;div className=&quot;p-2 space-y-1&quot;&gt;
            {Object.entries(tags).length === 0 &amp;&amp; (
              &lt;div className=&quot;text-sm text-muted-foreground p-2&quot;&gt;No available tags&lt;/div&gt;
            )}
            {Object.entries(tags).map(([tagName, config]) =&gt; {
              const isTagged = fileTags.includes(tagName);

              return (
                &lt;DropdownMenuItem
                  key={tagName}
                  className=&quot;flex items-center gap-2&quot;
                  onClick={() =&gt; !isTagged &amp;&amp; handleAddTag(tagName)}
                &gt;
                  &lt;div
                    className=&quot;h-3 w-3 rounded-full&quot;
                    style={{ backgroundColor: config.color }}
                  /&gt;
                  {tagName}
                  {isTagged &amp;&amp; (
                    &lt;Button
                      size=&quot;icon&quot;
                      variant=&quot;ghost&quot;
                      onClick={(e) =&gt; {
                        e.stopPropagation();
                        handleRemoveTag(tagName);
                      }}
                      className=&quot;ml-auto&quot;
                    &gt;
                      &lt;X className=&quot;h-4 w-4&quot; /&gt;
                    &lt;/Button&gt;
                  )}
                &lt;/DropdownMenuItem&gt;
              );
            })}
          &lt;/div&gt;
        &lt;/DropdownMenuContent&gt;
      &lt;/DropdownMenu&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/BundleAnalysisBadge.tsx</source>
      <tags>ui-components,business-logic</tags>
      <metadata>
        <size>9244</size>
        <lastModified>2025-05-27T00:51:18.714Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/BundleAnalysisBadge.tsx
// FIXED VERSION - Properly handles bundle content parsing and staleness calculation

import { useEffect, useState } from &#39;react&#39;;
import { Badge } from &quot;@/components/ui/badge&quot;;
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from &quot;@/components/ui/tooltip&quot;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import type { Bundle, BundleType } from &#39;@/types/types&#39;;
import { FileEdit, FileCheck, Loader2, AlertCircle } from &quot;lucide-react&quot;;

type BundleAnalysisBadgeProps = {
  bundle: Bundle;
};

export function BundleAnalysisBadge({ bundle }: BundleAnalysisBadgeProps) {
  const { directoryHandle } = useDirectory();
  const { watchedFiles } = useFiles();
  const [loading, setLoading] = useState(true);
  const [label, setLabel] = useState(&quot;Loading...&quot;);
  const [color, setColor] = useState(&quot;#888&quot;);
  const [tooltipText, setTooltipText] = useState(&quot;&quot;);
  const [Icon, setIcon] = useState(FileCheck);

  // FIXED: Safe bundle file access that handles all bundle types
  const getBundleFileHandle = async (bundle: Bundle): Promise&lt;FileSystemFileHandle | null&gt; =&gt; {
    if (!directoryHandle) return null;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);

      // Determine bundle type with fallbacks for existing bundles
      let bundleType: BundleType = bundle.type;
      if (!bundleType) {
        if (bundle.name.startsWith(&#39;master-&#39;)) {
          bundleType = &#39;master&#39;;
        } else if (bundle.derivedFromTag) {
          bundleType = &#39;tag-derived&#39;;
        } else {
          bundleType = &#39;custom&#39;;
        }
      }

      // Handle different bundle types with proper path resolution
      switch (bundleType) {
        case &#39;master&#39;: {
          const masterDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;, { create: true });
          return await masterDir.getFileHandle(bundle.name);
        }
        case &#39;tag-derived&#39;: {
          const tagName = bundle.derivedFromTag;
          if (!tagName) {
            console.error(&#39;Tag-derived bundle missing derivedFromTag:&#39;, bundle);
            throw new Error(&#39;Tag-derived bundle is missing tag information&#39;);
          }
          const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;);
          const tagDir = await tagBundlesDir.getDirectoryHandle(tagName);
          return await tagDir.getFileHandle(bundle.name);
        }
        case &#39;custom&#39;:
        default: {
          return await bundlesDir.getFileHandle(bundle.name);
        }
      }
    } catch (error) {
      console.error(`Failed to get file handle for bundle ${bundle.name}:`, error);
      throw error;
    }
  };

  // FIXED: Improved bundle content parsing
  const extractFilePaths = (content: string): string[] =&gt; {
    const filePaths: string[] = [];

    // Try multiple formats to handle different bundle structures

    // 1. Try new XML format with &lt;document&gt;&lt;source&gt; tags
    const documentRegex = /&lt;document[^&gt;]*&gt;[\s\S]*?&lt;source&gt;(.*?)&lt;\/source&gt;[\s\S]*?&lt;\/document&gt;/g;
    let match;
    while ((match = documentRegex.exec(content)) !== null) {
      if (match[1] &amp;&amp; match[1].trim()) {
        filePaths.push(match[1].trim());
      }
    }

    // 2. If no documents found, try simpler &lt;source&gt; tag format
    if (filePaths.length === 0) {
      const sourceRegex = /&lt;source&gt;(.*?)&lt;\/source&gt;/g;
      while ((match = sourceRegex.exec(content)) !== null) {
        if (match[1] &amp;&amp; match[1].trim()) {
          filePaths.push(match[1].trim());
        }
      }
    }

    // 3. Debug logging
    console.log(`Bundle ${bundle.name}: Found ${filePaths.length} file paths`);
    if (filePaths.length &gt; 0) {
      console.log(`Sample paths:`, filePaths.slice(0, 3));
    }

    return filePaths;
  };

  useEffect(() =&gt; {
    let isMounted = true;

    async function analyzeBundleStaleness() {
      if (!directoryHandle || !bundle || !isMounted) {
        setLoading(false);
        return;
      }

      setLoading(true);

      try {
        console.log(`🔍 Analyzing bundle: ${bundle.name} (type: ${bundle.type || &#39;unknown&#39;})`);

        // Get bundle file handle using the same logic as BundleView
        const bundleHandle = await getBundleFileHandle(bundle);
        if (!bundleHandle) {
          throw new Error(&#39;Could not access bundle file&#39;);
        }

        // Read bundle content
        const file = await bundleHandle.getFile();
        const content = await file.text();
        console.log(`📄 Bundle content loaded: ${content.length} characters`);

        // Extract file paths from bundle content
        const bundleFilePaths = extractFilePaths(content);
        console.log(`📋 Extracted ${bundleFilePaths.length} file paths from bundle`);

        if (bundleFilePaths.length === 0) {
          console.warn(`⚠️ No file paths found in bundle ${bundle.name}`);
          setLabel(&quot;No Files&quot;);
          setColor(&quot;#94a3b8&quot;);
          setTooltipText(&quot;Bundle contains no traceable files&quot;);
          setIcon(AlertCircle);
          return;
        }

        // Calculate staleness by comparing with current watched files
        let staleCount = 0;
        let freshCount = 0;
        let missingCount = 0;

        bundleFilePaths.forEach(bundlePath =&gt; {
          const currentFile = watchedFiles.find(f =&gt; f.path === bundlePath);

          if (!currentFile) {
            // File in bundle but not in current watched files (might be deleted or filtered out)
            missingCount++;
          } else if (currentFile.isChanged) {
            // File exists and has been modified since last bundle
            staleCount++;
          } else {
            // File exists and hasn&#39;t been modified
            freshCount++;
          }
        });

        const totalTrackedFiles = staleCount + freshCount;
        const stalenessPercentage = totalTrackedFiles &gt; 0 ? Math.round((staleCount / totalTrackedFiles) * 100) : 0;

        console.log(`📊 Bundle analysis: ${freshCount} fresh, ${staleCount} stale, ${missingCount} missing`);
        console.log(`📈 Staleness: ${stalenessPercentage}%`);

        // Determine display based on staleness
        if (totalTrackedFiles === 0) {
          setLabel(&quot;Unknown&quot;);
          setIcon(AlertCircle);
          setColor(&quot;#94a3b8&quot;);
          setTooltipText(`Cannot determine staleness (${missingCount} files not tracked)`);
        } else if (stalenessPercentage === 0) {
          setLabel(&quot;Fresh&quot;);
          setIcon(FileCheck);
          setColor(&quot;#22c55e&quot;);
          setTooltipText(`100% fresh - ${freshCount} files unchanged`);
        } else if (stalenessPercentage &lt;= 25) {
          setLabel(&quot;Mostly Fresh&quot;);
          setIcon(FileCheck);
          setColor(&quot;#22c55e&quot;);
          setTooltipText(`${100 - stalenessPercentage}% fresh - ${staleCount} of ${totalTrackedFiles} files changed`);
        } else if (stalenessPercentage &lt;= 50) {
          setLabel(&quot;Some Stale&quot;);
          setIcon(FileEdit);
          setColor(&quot;#f59e0b&quot;);
          setTooltipText(`${stalenessPercentage}% stale - ${staleCount} of ${totalTrackedFiles} files changed`);
        } else if (stalenessPercentage &lt;= 75) {
          setLabel(&quot;Stale&quot;);
          setIcon(FileEdit);
          setColor(&quot;#f97316&quot;);
          setTooltipText(`${stalenessPercentage}% stale - ${staleCount} of ${totalTrackedFiles} files changed`);
        } else {
          setLabel(&quot;Very Stale&quot;);
          setIcon(AlertCircle);
          setColor(&quot;#ef4444&quot;);
          setTooltipText(`${stalenessPercentage}% stale - ${staleCount} of ${totalTrackedFiles} files changed`);
        }

        // Add missing files info to tooltip if relevant
        if (missingCount &gt; 0) {
          setTooltipText(prev =&gt; `${prev} (${missingCount} files not tracked)`);
        }

      } catch (error) {
        console.error(`❌ Error analyzing bundle ${bundle.name}:`, error);
        setLabel(&quot;Error&quot;);
        setColor(&quot;#ef4444&quot;);
        setTooltipText(`Analysis failed: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}`);
        setIcon(AlertCircle);
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }

    analyzeBundleStaleness();

    return () =&gt; {
      isMounted = false;
    };
  }, [bundle, directoryHandle, watchedFiles]);

  if (loading) {
    return &lt;Loader2 className=&quot;h-4 w-4 animate-spin text-muted-foreground&quot; /&gt;;
  }

  return (
    &lt;TooltipProvider&gt;
      &lt;Tooltip&gt;
        &lt;TooltipTrigger asChild&gt;
          &lt;Badge
            variant=&quot;outline&quot;
            className=&quot;flex items-center gap-1 cursor-default&quot;
            style={{
              borderColor: color,
              backgroundColor: `${color}15`,
              color: color
            }}
          &gt;
            &lt;Icon className=&quot;h-3 w-3&quot; /&gt;
            &lt;span&gt;{label}&lt;/span&gt;
          &lt;/Badge&gt;
        &lt;/TooltipTrigger&gt;
        &lt;TooltipContent&gt;
          &lt;div className=&quot;text-xs max-w-xs&quot;&gt;
            &lt;div className=&quot;font-medium&quot;&gt;{bundle.name}&lt;/div&gt;
            &lt;div className=&quot;mt-1&quot;&gt;{tooltipText}&lt;/div&gt;
          &lt;/div&gt;
        &lt;/TooltipContent&gt;
      &lt;/Tooltip&gt;
    &lt;/TooltipProvider&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/BatchTagButton.tsx</source>
      <tags>ui-components,business-logic</tags>
      <metadata>
        <size>12557</size>
        <lastModified>2025-05-23T20:54:02.995Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/BatchTagButton.tsx - New component for batch file tagging
import React, { useState } from &#39;react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import { Checkbox } from &#39;@/components/ui/checkbox&#39;;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from &#39;@/components/ui/dropdown-menu&#39;;
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from &#39;@/components/ui/dialog&#39;;
import { ScrollArea } from &#39;@/components/ui/scroll-area&#39;;
import { Paintbrush, Tags, Plus, Check } from &#39;lucide-react&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import type { WatchedFile } from &#39;@/types/types&#39;;

interface BatchTagButtonProps {
  selectedFiles: WatchedFile[];
  onTagsApplied?: () =&gt; void;
}

export function BatchTagButton({ selectedFiles, onTagsApplied }: BatchTagButtonProps) {
  const { tags, addTagToFiles } = useTags();
  const { refreshFiles } = useFiles();
  const [showAdvancedDialog, setShowAdvancedDialog] = useState(false);
  const [selectedTagsForBatch, setSelectedTagsForBatch] = useState&lt;string[]&gt;([]);
  const [isApplying, setIsApplying] = useState(false);

  const fileCount = selectedFiles.length;
  const filePaths = selectedFiles.map(f =&gt; f.path);

  // Debug: Log the tags to see what we&#39;re getting
  console.log(&#39;🏷️  BatchTagButton - Available tags:&#39;, Object.keys(tags));
  console.log(&#39;🏷️  BatchTagButton - Tag count:&#39;, Object.keys(tags).length);

  // Quick tag application (single tag)
  const handleQuickTag = async (tagName: string) =&gt; {
    try {
      setIsApplying(true);
      console.log(`🏷️  Applying tag &quot;${tagName}&quot; to ${fileCount} files...`);

      await addTagToFiles(tagName, filePaths);
      await refreshFiles(); // Refresh to show updated tags

      console.log(`✅ Successfully applied tag &quot;${tagName}&quot; to ${fileCount} files`);
      onTagsApplied?.();
    } catch (error) {
      console.error(&#39;Error applying tag:&#39;, error);
    } finally {
      setIsApplying(false);
    }
  };

  // Advanced batch tagging (multiple tags)
  const handleAdvancedTagging = () =&gt; {
    setSelectedTagsForBatch([]);
    setShowAdvancedDialog(true);
  };

  const handleBatchTagApplication = async () =&gt; {
    if (selectedTagsForBatch.length === 0) return;

    try {
      setIsApplying(true);
      console.log(`🏷️  Applying ${selectedTagsForBatch.length} tags to ${fileCount} files...`);

      // Apply each selected tag to all files
      for (const tagName of selectedTagsForBatch) {
        await addTagToFiles(tagName, filePaths);
      }

      await refreshFiles(); // Refresh to show updated tags

      console.log(`✅ Successfully applied ${selectedTagsForBatch.length} tags to ${fileCount} files`);
      setShowAdvancedDialog(false);
      setSelectedTagsForBatch([]);
      onTagsApplied?.();
    } catch (error) {
      console.error(&#39;Error applying batch tags:&#39;, error);
    } finally {
      setIsApplying(false);
    }
  };

  const toggleTagSelection = (tagName: string) =&gt; {
    setSelectedTagsForBatch(prev =&gt;
      prev.includes(tagName)
        ? prev.filter(t =&gt; t !== tagName)
        : [...prev, tagName]
    );
  };

  // Get current tags on selected files for display
  const getCurrentTags = () =&gt; {
    const tagCounts = new Map&lt;string, number&gt;();
    selectedFiles.forEach(file =&gt; {
      file.tags?.forEach(tag =&gt; {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });
    return tagCounts;
  };

  const currentTags = getCurrentTags();
  const availableTags = Object.entries(tags);

  // Add safety check for empty tags - this might indicate loading issue
  if (availableTags.length === 0) {
    console.warn(&#39;⚠️  BatchTagButton: No tags available - tags might not be loaded yet&#39;);
  }

  if (fileCount === 0) {
    return (
      &lt;Button
        variant=&quot;outline&quot;
        size=&quot;sm&quot;
        disabled={true}
        title=&quot;Select files to tag them&quot;
      &gt;
        &lt;Paintbrush className=&quot;h-4 w-4&quot; /&gt;
      &lt;/Button&gt;
    );
  }

  return (
    &lt;&gt;
      &lt;DropdownMenu&gt;
        &lt;DropdownMenuTrigger asChild&gt;
          &lt;Button
            variant=&quot;outline&quot;
            size=&quot;sm&quot;
            disabled={isApplying}
            title={`Tag ${fileCount} selected file${fileCount &gt; 1 ? &#39;s&#39; : &#39;&#39;}`}
          &gt;
            &lt;Paintbrush className=&quot;h-4 w-4&quot; /&gt;
            {fileCount &gt; 1 &amp;&amp; (
              &lt;Badge variant=&quot;secondary&quot; className=&quot;ml-1 h-4 px-1 text-xs&quot;&gt;
                {fileCount}
              &lt;/Badge&gt;
            )}
          &lt;/Button&gt;
        &lt;/DropdownMenuTrigger&gt;
        &lt;DropdownMenuContent align=&quot;end&quot; className=&quot;w-64&quot;&gt;
          &lt;div className=&quot;px-2 py-1.5 text-sm font-medium&quot;&gt;
            Tag {fileCount} selected file{fileCount &gt; 1 ? &#39;s&#39; : &#39;&#39;}
          &lt;/div&gt;

          {currentTags.size &gt; 0 &amp;&amp; (
            &lt;&gt;
              &lt;div className=&quot;px-2 py-1 text-xs text-muted-foreground&quot;&gt;
                Current tags:
              &lt;/div&gt;
              &lt;div className=&quot;px-2 pb-2 flex flex-wrap gap-1&quot;&gt;
                {Array.from(currentTags.entries()).map(([tag, count]) =&gt; (
                  &lt;Badge
                    key={tag}
                    variant=&quot;outline&quot;
                    className=&quot;text-xs&quot;
                    style={{
                      borderColor: tags[tag]?.color || &#39;#888&#39;,
                      backgroundColor: `${tags[tag]?.color}22` || &#39;transparent&#39;
                    }}
                  &gt;
                    {tag}
                    {count &lt; fileCount &amp;&amp; (
                      &lt;span className=&quot;ml-1 opacity-60&quot;&gt;({count})&lt;/span&gt;
                    )}
                    {count === fileCount &amp;&amp; (
                      &lt;Check className=&quot;ml-1 h-3 w-3&quot; /&gt;
                    )}
                  &lt;/Badge&gt;
                ))}
              &lt;/div&gt;
              &lt;DropdownMenuSeparator /&gt;
            &lt;/&gt;
          )}

          &lt;div className=&quot;px-2 py-1 text-xs text-muted-foreground&quot;&gt;
            Quick add tag:
          &lt;/div&gt;

          &lt;ScrollArea className=&quot;max-h-48&quot;&gt;
            {availableTags.length === 0 ? (
              &lt;div className=&quot;px-2 py-4 text-sm text-muted-foreground text-center&quot;&gt;
                No tags available
              &lt;/div&gt;
            ) : (
              availableTags.map(([tagName, config]) =&gt; {
                const isAlreadyOnAllFiles = currentTags.get(tagName) === fileCount;

                return (
                  &lt;DropdownMenuItem
                    key={tagName}
                    className=&quot;flex items-center gap-2&quot;
                    onClick={() =&gt; !isAlreadyOnAllFiles &amp;&amp; handleQuickTag(tagName)}
                    disabled={isAlreadyOnAllFiles || isApplying}
                  &gt;
                    &lt;div
                      className=&quot;w-3 h-3 rounded-full&quot;
                      style={{ backgroundColor: config.color }}
                    /&gt;
                    &lt;span className=&quot;flex-1&quot;&gt;{tagName}&lt;/span&gt;
                    {isAlreadyOnAllFiles &amp;&amp; (
                      &lt;Check className=&quot;h-4 w-4 text-green-500&quot; /&gt;
                    )}
                  &lt;/DropdownMenuItem&gt;
                );
              })
            )}
          &lt;/ScrollArea&gt;

          &lt;DropdownMenuSeparator /&gt;

          &lt;DropdownMenuItem
            onClick={handleAdvancedTagging}
            className=&quot;flex items-center gap-2&quot;
          &gt;
            &lt;Tags className=&quot;h-4 w-4&quot; /&gt;
            Advanced tagging...
          &lt;/DropdownMenuItem&gt;
        &lt;/DropdownMenuContent&gt;
      &lt;/DropdownMenu&gt;

      {/* Advanced Batch Tagging Dialog */}
      &lt;Dialog open={showAdvancedDialog} onOpenChange={setShowAdvancedDialog}&gt;
        &lt;DialogContent className=&quot;max-w-md&quot;&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;Batch Tag Files&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              Select multiple tags to apply to {fileCount} selected file{fileCount &gt; 1 ? &#39;s&#39; : &#39;&#39;}
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;

          &lt;div className=&quot;space-y-4&quot;&gt;
            {/* Current tags display */}
            {currentTags.size &gt; 0 &amp;&amp; (
              &lt;div&gt;
                &lt;div className=&quot;text-sm font-medium mb-2&quot;&gt;Current tags:&lt;/div&gt;
                &lt;div className=&quot;flex flex-wrap gap-1&quot;&gt;
                  {Array.from(currentTags.entries()).map(([tag, count]) =&gt; (
                    &lt;Badge
                      key={tag}
                      variant=&quot;outline&quot;
                      className=&quot;text-xs&quot;
                      style={{
                        borderColor: tags[tag]?.color || &#39;#888&#39;,
                        backgroundColor: `${tags[tag]?.color}22` || &#39;transparent&#39;
                      }}
                    &gt;
                      {tag}
                      {count &lt; fileCount &amp;&amp; (
                        &lt;span className=&quot;ml-1 opacity-60&quot;&gt;({count}/{fileCount})&lt;/span&gt;
                      )}
                    &lt;/Badge&gt;
                  ))}
                &lt;/div&gt;
              &lt;/div&gt;
            )}

            {/* Tag selection */}
            &lt;div&gt;
              &lt;div className=&quot;text-sm font-medium mb-2&quot;&gt;Add tags:&lt;/div&gt;
              &lt;ScrollArea className=&quot;max-h-48 border rounded-md p-2&quot;&gt;
                {availableTags.length === 0 ? (
                  &lt;div className=&quot;text-sm text-muted-foreground text-center py-4&quot;&gt;
                    No tags available
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;space-y-2&quot;&gt;
                    {availableTags.map(([tagName, config]) =&gt; {
                      const isSelected = selectedTagsForBatch.includes(tagName);
                      const isAlreadyOnAllFiles = currentTags.get(tagName) === fileCount;

                      return (
                        &lt;div
                          key={tagName}
                          className=&quot;flex items-center space-x-2 p-1 rounded hover:bg-muted&quot;
                        &gt;
                          &lt;Checkbox
                            id={`tag-${tagName}`}
                            checked={isSelected}
                            disabled={isAlreadyOnAllFiles}
                            onCheckedChange={() =&gt; toggleTagSelection(tagName)}
                          /&gt;
                          &lt;div
                            className=&quot;w-3 h-3 rounded-full&quot;
                            style={{ backgroundColor: config.color }}
                          /&gt;
                          &lt;label
                            htmlFor={`tag-${tagName}`}
                            className=&quot;flex-1 text-sm cursor-pointer&quot;
                          &gt;
                            {tagName}
                            {isAlreadyOnAllFiles &amp;&amp; (
                              &lt;span className=&quot;ml-2 text-xs text-green-600&quot;&gt;
                                (already applied)
                              &lt;/span&gt;
                            )}
                          &lt;/label&gt;
                        &lt;/div&gt;
                      );
                    })}
                  &lt;/div&gt;
                )}
              &lt;/ScrollArea&gt;
            &lt;/div&gt;

            {/* Selected files preview */}
            &lt;div&gt;
              &lt;div className=&quot;text-sm font-medium mb-2&quot;&gt;Selected files:&lt;/div&gt;
              &lt;ScrollArea className=&quot;max-h-32 text-xs text-muted-foreground bg-muted rounded p-2&quot;&gt;
                {selectedFiles.map((file, index) =&gt; (
                  &lt;div key={file.path}&gt;
                    {index + 1}. {file.name}
                  &lt;/div&gt;
                ))}
              &lt;/ScrollArea&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;DialogFooter&gt;
            &lt;Button
              variant=&quot;outline&quot;
              onClick={() =&gt; setShowAdvancedDialog(false)}
              disabled={isApplying}
            &gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button
              onClick={handleBatchTagApplication}
              disabled={selectedTagsForBatch.length === 0 || isApplying}
            &gt;
              {isApplying ? (
                &lt;&gt;
                  &lt;div className=&quot;animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2&quot; /&gt;
                  Applying...
                &lt;/&gt;
              ) : (
                &lt;&gt;
                  &lt;Plus className=&quot;h-4 w-4 mr-2&quot; /&gt;
                  Apply {selectedTagsForBatch.length} tag{selectedTagsForBatch.length &gt; 1 ? &#39;s&#39; : &#39;&#39;}
                &lt;/&gt;
              )}
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;
    &lt;/&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/DirectoryTree.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>11291</size>
        <lastModified>2025-05-24T02:36:43.535Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/DirectoryTree.tsx
import { useState, useEffect, useCallback, useMemo } from &#39;react&#39;;
import { ChevronRight, ChevronDown, Folder, FolderOpen, FileIcon, SquareDot } from &#39;lucide-react&#39;;
import { Button } from &quot;./ui/button&quot;;
import { Checkbox } from &quot;./ui/checkbox&quot;;
import type { WatchedFile } from &#39;@/types/types&#39;;
import { getAllDirectories } from &#39;../utils/file-utils&#39;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { BundleManifest } from &#39;@/types/types&#39;;
import { FileTagsDisplay } from &#39;./FileTagsDisplay&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;

import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
// import { useTags } from &#39;@/contexts/TagContext&#39;;
type DirectoryTreeProps = {
  files: WatchedFile[];
  onToggleStage: (paths: string[]) =&gt; void;
};

// Build a flat index of files in display order
function buildFileIndex(
  files: WatchedFile[],
  expandedDirs: Set&lt;string&gt;
): WatchedFile[] {
  const result: WatchedFile[] = [];
  const directories = getAllDirectories(files.map(f =&gt; f.path))
    .filter(dir =&gt; dir !== &#39;Root&#39;);

  function processDirectory(currentDir: string = &#39;Root&#39;) {
    // Add files in current directory
    const dirFiles = files
      .filter(f =&gt; f.directory === currentDir)
      .sort((a, b) =&gt; a.name.localeCompare(b.name));

    result.push(...dirFiles);

    // Process subdirectories if expanded
    const childDirs = directories
      .filter(dir =&gt; {
        const parts = dir.split(&#39;/&#39;);
        const parentParts = currentDir === &#39;Root&#39; ? [] : currentDir.split(&#39;/&#39;);
        return parts.length === parentParts.length + 1 &amp;&amp;
          dir.startsWith(currentDir === &#39;Root&#39; ? &#39;&#39; : currentDir + &#39;/&#39;);
      })
      .sort((a, b) =&gt; a.localeCompare(b));

    childDirs.forEach(dir =&gt; {
      if (expandedDirs.has(dir)) {
        processDirectory(dir);
      }
    });
  }

  processDirectory();
  return result;
}

function FileRow({
  file,
  onCheckboxClick,
  depth = 0,
  isSelected,
}: {
  file: WatchedFile;
  onCheckboxClick: (event: React.MouseEvent) =&gt; void;
  depth?: number;
  isSelected?: boolean;
}) {
  // const { tags } = useTags(); // Add this import at the top: import { useTags } from &#39;@/contexts/TagContext&#39;;

  return (
    &lt;div className=&quot;space-y-1&quot;&gt;
      &lt;div
        className={`flex items-center space-x-2 py-1 px-2 hover:bg-muted/50 rounded-md ${isSelected ? &#39;bg-muted/50&#39; : &#39;&#39;
          }`}
        style={{ paddingLeft: `${(depth + 1) * 12}px` }}
      &gt;
        &lt;Checkbox
          checked={file.isStaged}
          onCheckedChange={() =&gt; { }}
          onClick={onCheckboxClick}
          className=&quot;cursor-pointer&quot;
        /&gt;
        &lt;FileIcon className=&quot;h-4 w-4 text-muted-foreground&quot; /&gt;
        &lt;span className=&quot;flex-1 truncate text-sm&quot;&gt;
          {file.name}
        &lt;/span&gt;

        {/* Enhanced tag display with colors */}
        {/* {file.tags &amp;&amp; file.tags.length &gt; 0 &amp;&amp; (
          &lt;div className=&quot;flex items-center gap-1&quot;&gt;
            {file.tags.slice(0, 3).map(tagName =&gt; (
              &lt;div
                key={tagName}
                className=&quot;w-2 h-2 rounded-full&quot;
                style={{
                  backgroundColor: tags[tagName]?.color || &#39;#94a3b8&#39;,
                }}
                title={`Tag: ${tagName}`}
              /&gt;
            ))}
            {file.tags.length &gt; 3 &amp;&amp; (
              &lt;span className=&quot;text-xs text-muted-foreground&quot;&gt;
                +{file.tags.length - 3}
              &lt;/span&gt;
            )}
          &lt;/div&gt;
        )} */}

        {file.isChanged &amp;&amp; (
          &lt;SquareDot
            className=&quot;text-red-400&quot;
            size={16}
            strokeWidth={1.5}
          /&gt;
        )}

        &lt;FileTagsDisplay filePath={file.path} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export function DirectoryTree({ files, onToggleStage }: DirectoryTreeProps) {
  const [expandedDirs, setExpandedDirs] = useState&lt;Set&lt;string&gt;&gt;(new Set([&#39;Root&#39;]));
  const [lastSelectedPath, setLastSelectedPath] = useState&lt;string | null&gt;(null);
  const [selectedItems, setSelectedItems] = useState&lt;Set&lt;string&gt;&gt;(new Set());
  const [manifest, setManifest] = useState&lt;BundleManifest | null&gt;(null);
  const [rangeSelectionState, setRangeSelectionState] = useState&lt;boolean | null&gt;(null);

  const { directoryHandle } = useDirectory();
  const { masterBundle } = useBundles();
  const { isProjectInitialized } = useProjectConfig();

  // Load manifest when masterBundle changes
  useEffect(() =&gt; {
    const loadManifest = async () =&gt; {
      if (!directoryHandle || !masterBundle || !isProjectInitialized) return;

      try {
        const bundlesDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;)
          .then(dir =&gt; dir.getDirectoryHandle(&#39;bundles&#39;))
          .then(dir =&gt; dir.getDirectoryHandle(&#39;master&#39;));

        for await (const entry of bundlesDir.values()) {
          if (entry.kind === &#39;file&#39; &amp;&amp;
            entry.name === `${masterBundle.name}-manifest.json`) {
            const manifestFile = await entry.getFile();
            const manifestContent = await manifestFile.text();
            setManifest(JSON.parse(manifestContent));
            break;
          }
        }
      } catch (error) {
        console.error(&#39;Error loading master bundle manifest:&#39;, error);
        setManifest(null);
      }
    };

    loadManifest();
  }, [directoryHandle, masterBundle, isProjectInitialized]);

  // Get all directories once for the component
  const directories = useMemo(() =&gt;
    getAllDirectories(files.map(f =&gt; f.path))
      .filter(dir =&gt; dir !== &#39;Root&#39;)
    , [files]);

  // Build and memoize the flat file index based on current expanded state
  const flatFileIndex = useMemo(() =&gt;
    buildFileIndex(files, expandedDirs),
    [files, expandedDirs]
  );

  const toggleDirectory = useCallback((dir: string) =&gt; {
    setExpandedDirs(prev =&gt; {
      const next = new Set(prev);
      if (next.has(dir)) {
        next.delete(dir);
      } else {
        next.add(dir);
      }
      return next;
    });
  }, []);

  const expandAll = useCallback(() =&gt; {
    const allDirs = getAllDirectories(files.map(f =&gt; f.path));
    setExpandedDirs(new Set(allDirs));
  }, [files]);

  const collapseAll = useCallback(() =&gt; {
    setExpandedDirs(new Set([&#39;Root&#39;]));
  }, []);

  const handleCheckboxClick = useCallback((path: string, event: React.MouseEvent) =&gt; {
    event.stopPropagation();

    const currentFile = files.find(f =&gt; f.path === path);
    if (!currentFile) return;

    if (event.shiftKey &amp;&amp; lastSelectedPath) {
      const currentIndex = flatFileIndex.findIndex(f =&gt; f.path === path);
      const lastIndex = flatFileIndex.findIndex(f =&gt; f.path === lastSelectedPath);

      if (currentIndex !== -1 &amp;&amp; lastIndex !== -1) {
        const start = Math.min(currentIndex, lastIndex);
        const end = Math.max(currentIndex, lastIndex);

        // Get paths in range based on flat index
        const pathsToToggle = flatFileIndex
          .slice(start, end + 1)
          .map(f =&gt; f.path);

        setSelectedItems(new Set(pathsToToggle));

        // Use the stored range selection state
        if (rangeSelectionState !== null) {
          const filesToToggle = pathsToToggle.filter(p =&gt; {
            const f = files.find(file =&gt; file.path === p);
            return f &amp;&amp; f.isStaged !== rangeSelectionState;
          });
          if (filesToToggle.length &gt; 0) {
            onToggleStage(filesToToggle);
          }
        }
      }
    } else {
      // Single selection - store the target state for future range selections
      setRangeSelectionState(!currentFile.isStaged);
      setSelectedItems(new Set([path]));
      onToggleStage([path]);
    }

    setLastSelectedPath(path);
  }, [lastSelectedPath, onToggleStage, flatFileIndex, files, rangeSelectionState]);

  const renderTreeItems = useCallback((parentDir: string = &#39;Root&#39;, depth: number = 0): JSX.Element[] =&gt; {
    const allItems: JSX.Element[] = [];

    // Add files for current directory
    const dirFiles = files
      .filter(f =&gt; f.directory === parentDir)
      .sort((a, b) =&gt; a.name.localeCompare(b.name));

    dirFiles.forEach((file) =&gt; {
      allItems.push(
        &lt;FileRow
          key={file.path}
          file={file}
          onCheckboxClick={(event) =&gt; handleCheckboxClick(file.path, event)}
          depth={depth}
          isSelected={selectedItems.has(file.path)}
          manifest={manifest}
        /&gt;
      );
    });

    // Get immediate child directories only
    const childDirs = directories
      .filter(dir =&gt; {
        if (parentDir === &#39;Root&#39;) {
          return !dir.includes(&#39;/&#39;); // Top-level dirs have no slashes
        }
        const parentParts = parentDir.split(&#39;/&#39;);
        const dirParts = dir.split(&#39;/&#39;);
        return dirParts.length === parentParts.length + 1 &amp;&amp;
          dir.startsWith(parentDir + &#39;/&#39;);
      })
      .sort((a, b) =&gt; a.localeCompare(b));

    // Add directories
    childDirs.forEach((dir) =&gt; {
      const dirName = dir.split(&#39;/&#39;).pop() || dir;
      const filesInDir = files.filter(f =&gt; f.directory === dir);
      const isExpanded = expandedDirs.has(dir);

      allItems.push(
        &lt;div key={dir}&gt;
          &lt;Button
            variant=&quot;ghost&quot;
            size=&quot;sm&quot;
            className=&quot;w-full justify-start px-2 py-1 h-8&quot;
            onClick={() =&gt; toggleDirectory(dir)}
            style={{ paddingLeft: `${depth * 12}px` }}
          &gt;
            &lt;span className=&quot;flex items-center space-x-2&quot;&gt;
              {isExpanded ? (
                &lt;ChevronDown className=&quot;h-4 w-4&quot; /&gt;
              ) : (
                &lt;ChevronRight className=&quot;h-4 w-4&quot; /&gt;
              )}
              {isExpanded ? (
                &lt;FolderOpen className=&quot;h-4 w-4 text-zinc-500&quot; /&gt;
              ) : (
                &lt;Folder className=&quot;h-4 w-4 text-zinc-500&quot; /&gt;
              )}
              &lt;span className=&quot;text-sm&quot;&gt;{dirName}&lt;/span&gt;
              &lt;span className=&quot;text-xs text-muted-foreground&quot;&gt;
                ({filesInDir.length})
              &lt;/span&gt;
            &lt;/span&gt;
          &lt;/Button&gt;
          {isExpanded &amp;&amp; renderTreeItems(dir, depth + 1)}
        &lt;/div&gt;
      );
    });

    return allItems;
  }, [files, expandedDirs, handleCheckboxClick, selectedItems, toggleDirectory, manifest, directories]);

  return (
    &lt;div className=&quot;flex flex-col space-y-2 h-full&quot;&gt;
      {isProjectInitialized ? (
        &lt;&gt;
          &lt;div className=&quot;flex justify-between items-center&quot;&gt;
            &lt;Button
              variant=&quot;ghost&quot;
              size=&quot;sm&quot;
              className=&quot;px-2 py-1 h-8&quot;
              onClick={expandAll}
            &gt;
              Expand All
            &lt;/Button&gt;
            &lt;Button
              variant=&quot;ghost&quot;
              size=&quot;sm&quot;
              className=&quot;px-2 py-1 h-8&quot;
              onClick={collapseAll}
            &gt;
              Collapse All
            &lt;/Button&gt;
          &lt;/div&gt;
          &lt;div className=&quot;h-screen&quot;&gt;
            &lt;ScrollArea className=&quot;h-3/5 w-full&quot;&gt;
              {renderTreeItems()}
            &lt;/ScrollArea&gt;
          &lt;/div&gt;
        &lt;/&gt;
      ) : (
        &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
          Project not initialized. Please initialize project first.
        &lt;/div&gt;
      )}
    &lt;/div&gt;

  );
}
</content>
    </document>

    <document>
      <source>src/components/CursorRulesPanel.tsx</source>
      <tags>ui-components,external-apis</tags>
      <metadata>
        <size>10413</size>
        <lastModified>2025-05-26T20:46:09.564Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/CursorRulesPanel.tsx
import { useEffect, useState } from &#39;react&#39;;
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from &#39;@/components/ui/card&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { Textarea } from &#39;@/components/ui/textarea&#39;;
import { Alert, AlertDescription, AlertTitle } from &#39;@/components/ui/alert&#39;;
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from &#39;@/components/ui/dialog&#39;;
import {
  FileText,
  Save,
  RefreshCw,
  CheckCircle,
  AlertCircle,
  Plus,
  FolderOpen
} from &#39;lucide-react&#39;;
import { useCursorRules } from &#39;@/contexts/CursorRulesContext&#39;;
import { getExampleCursorRules } from &#39;@/utils/cursor-rules&#39;;

export function CursorRulesPanel() {
  const {
    rulesContent,
    rulesLocation,
    filePath,
    hasExistingRules,
    isLoading,
    error,
    saveRules,
    createNewRules,
    clearError
  } = useCursorRules();

  const [editableContent, setEditableContent] = useState&lt;string&gt;(&#39;&#39;);
  const [hasChanges, setHasChanges] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [showLocationChoice, setShowLocationChoice] = useState(false);

  // Initialize editable content when rules load
  useEffect(() =&gt; {
    setEditableContent(rulesContent);
    setHasChanges(false);
  }, [rulesContent]);

  const handleContentChange = (value: string) =&gt; {
    setEditableContent(value);
    setHasChanges(value !== rulesContent);
    clearError();
  };

  const handleSave = async () =&gt; {
    try {
      await saveRules(editableContent);
      setHasChanges(false);
      setSaveSuccess(true);
      setTimeout(() =&gt; setSaveSuccess(false), 3000);
    } catch (err) {
      console.error(&#39;Error saving rules:&#39;, err);
    }
  };

  const handleCreateNew = async (location: &#39;cursorrules-file&#39; | &#39;cursor-directory&#39;) =&gt; {
    try {
      await createNewRules(editableContent, location);
      setHasChanges(false);
      setSaveSuccess(true);
      setShowLocationChoice(false);
      setTimeout(() =&gt; setSaveSuccess(false), 3000);
    } catch (err) {
      console.error(&#39;Error creating rules:&#39;, err);
    }
  };

  const handleLoadExample = () =&gt; {
    const exampleRules = getExampleCursorRules();
    setEditableContent(exampleRules.rules.join(&#39;\n&#39;));
    setHasChanges(true);
  };

  const getLocationDisplayName = (location: string) =&gt; {
    switch (location) {
      case &#39;cursorrules-file&#39;:
        return &#39;.cursorrules file&#39;;
      case &#39;cursor-directory&#39;:
        return &#39;.cursor directory&#39;;
      default:
        return &#39;Unknown location&#39;;
    }
  };

  return (
    &lt;div className=&quot;space-y-6&quot;&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;
          &lt;CardTitle className=&quot;flex items-center gap-2&quot;&gt;
            &lt;FileText className=&quot;h-5 w-5&quot; /&gt;
            Cursor Rules
          &lt;/CardTitle&gt;
          &lt;CardDescription&gt;
            Manage your Cursor AI rules directly. Changes are saved to your actual Cursor configuration files.
          &lt;/CardDescription&gt;
        &lt;/CardHeader&gt;
        &lt;CardContent&gt;

          {/* Error Display */}
          {error &amp;&amp; (
            &lt;Alert variant=&quot;destructive&quot; className=&quot;mb-4&quot;&gt;
              &lt;AlertCircle className=&quot;h-4 w-4&quot; /&gt;
              &lt;AlertTitle&gt;Error&lt;/AlertTitle&gt;
              &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
            &lt;/Alert&gt;
          )}

          {/* Success Alert */}
          {saveSuccess &amp;&amp; (
            &lt;Alert className=&quot;border-green-600 bg-green-50 dark:bg-green-950/20 mb-4&quot;&gt;
              &lt;CheckCircle className=&quot;h-4 w-4 text-green-600&quot; /&gt;
              &lt;AlertDescription className=&quot;text-green-700 dark:text-green-300&quot;&gt;
                Cursor rules saved successfully to {filePath}
              &lt;/AlertDescription&gt;
            &lt;/Alert&gt;
          )}

          {/* Status Section */}
          &lt;div className=&quot;flex items-center justify-between p-4 border rounded-lg bg-muted/30 mb-4&quot;&gt;
            &lt;div className=&quot;flex items-center gap-2&quot;&gt;
              {hasExistingRules ? (
                &lt;&gt;
                  &lt;CheckCircle className=&quot;h-5 w-5 text-green-500&quot; /&gt;
                  &lt;div&gt;
                    &lt;span className=&quot;font-medium&quot;&gt;Cursor rules found&lt;/span&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground mt-1&quot;&gt;
                      &lt;span&gt;Location: &lt;/span&gt;
                      &lt;code className=&quot;bg-muted px-1 rounded text-xs&quot;&gt;{filePath}&lt;/code&gt;
                      &lt;span className=&quot;ml-2 text-xs opacity-75&quot;&gt;
                        ({getLocationDisplayName(rulesLocation)})
                      &lt;/span&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/&gt;
              ) : (
                &lt;&gt;
                  &lt;AlertCircle className=&quot;h-5 w-5 text-amber-500&quot; /&gt;
                  &lt;div&gt;
                    &lt;span className=&quot;font-medium&quot;&gt;No Cursor rules found&lt;/span&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground mt-1&quot;&gt;
                      Create new rules to get started
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;

          {/* Rules Editor */}
          &lt;div className=&quot;space-y-4&quot;&gt;
            &lt;div className=&quot;flex items-center justify-between&quot;&gt;
              &lt;label className=&quot;text-sm font-medium&quot;&gt;
                {hasExistingRules ? `Edit ${filePath}` : &#39;Create Cursor Rules&#39;}
              &lt;/label&gt;

              {!hasExistingRules &amp;&amp; (
                &lt;Button
                  variant=&quot;outline&quot;
                  size=&quot;sm&quot;
                  onClick={handleLoadExample}
                  className=&quot;text-xs&quot;
                  disabled={isLoading}
                &gt;
                  &lt;Plus className=&quot;h-3 w-3 mr-1&quot; /&gt;
                  Load Example
                &lt;/Button&gt;
              )}
            &lt;/div&gt;

            &lt;Textarea
              value={editableContent}
              onChange={(e) =&gt; handleContentChange(e.target.value)}
              placeholder={hasExistingRules
                ? &quot;Loading your Cursor rules...&quot;
                : &quot;Enter your Cursor rules here, or click &#39;Load Example&#39; to get started...&quot;
              }
              className=&quot;min-h-[400px] font-mono text-sm&quot;
              disabled={isLoading}
            /&gt;

            &lt;div className=&quot;flex items-center justify-between&quot;&gt;
              &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                {hasExistingRules ? (
                  &lt;Button
                    onClick={handleSave}
                    disabled={!hasChanges || !editableContent.trim() || isLoading}
                    className=&quot;flex items-center gap-2&quot;
                  &gt;
                    {isLoading ? (
                      &lt;RefreshCw className=&quot;h-4 w-4 animate-spin&quot; /&gt;
                    ) : (
                      &lt;Save className=&quot;h-4 w-4&quot; /&gt;
                    )}
                    Save Changes
                  &lt;/Button&gt;
                ) : (
                  &lt;Button
                    onClick={() =&gt; setShowLocationChoice(true)}
                    disabled={!editableContent.trim() || isLoading}
                    className=&quot;flex items-center gap-2&quot;
                  &gt;
                    {isLoading ? (
                      &lt;RefreshCw className=&quot;h-4 w-4 animate-spin&quot; /&gt;
                    ) : (
                      &lt;Plus className=&quot;h-4 w-4&quot; /&gt;
                    )}
                    Create Rules
                  &lt;/Button&gt;
                )}
              &lt;/div&gt;

              {hasChanges &amp;&amp; (
                &lt;div className=&quot;text-sm text-amber-600 flex items-center gap-1&quot;&gt;
                  &lt;AlertCircle className=&quot;h-3 w-3&quot; /&gt;
                  Unsaved changes
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;

          {/* Info Section */}
          &lt;div className=&quot;bg-muted/30 rounded-lg p-4 mt-6&quot;&gt;
            &lt;h4 className=&quot;text-sm font-medium mb-2&quot;&gt;Direct Management&lt;/h4&gt;
            &lt;div className=&quot;text-xs text-muted-foreground space-y-1&quot;&gt;
              &lt;p&gt;• Cntx edits your actual Cursor configuration files&lt;/p&gt;
              &lt;p&gt;• Changes immediately affect both Cursor and cntx&lt;/p&gt;
              &lt;p&gt;• No import/export needed - just direct editing&lt;/p&gt;
              &lt;p&gt;• Supports both .cursorrules and .cursor/rules formats&lt;/p&gt;
              &lt;p&gt;• Files are saved exactly where Cursor expects them&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;

      {/* Location Choice Dialog for New Rules */}
      &lt;Dialog open={showLocationChoice} onOpenChange={setShowLocationChoice}&gt;
        &lt;DialogContent className=&quot;max-w-md&quot;&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;Choose Rules Location&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              Where would you like to store your Cursor rules?
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;

          &lt;div className=&quot;space-y-3&quot;&gt;
            &lt;Button
              onClick={() =&gt; handleCreateNew(&#39;cursorrules-file&#39;)}
              className=&quot;w-full justify-start h-auto p-4&quot;
              variant=&quot;outline&quot;
              disabled={isLoading}
            &gt;
              &lt;FileText className=&quot;h-5 w-5 mr-3 flex-shrink-0&quot; /&gt;
              &lt;div className=&quot;text-left flex-1&quot;&gt;
                &lt;div className=&quot;font-medium&quot;&gt;.cursorrules&lt;/div&gt;
                &lt;div className=&quot;text-xs text-muted-foreground mt-1&quot;&gt;
                  Single file in project root (most common)
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/Button&gt;

            &lt;Button
              onClick={() =&gt; handleCreateNew(&#39;cursor-directory&#39;)}
              className=&quot;w-full justify-start h-auto p-4&quot;
              variant=&quot;outline&quot;
              disabled={isLoading}
            &gt;
              &lt;FolderOpen className=&quot;h-5 w-5 mr-3 flex-shrink-0&quot; /&gt;
              &lt;div className=&quot;text-left flex-1&quot;&gt;
                &lt;div className=&quot;font-medium&quot;&gt;.cursor/rules&lt;/div&gt;
                &lt;div className=&quot;text-xs text-muted-foreground mt-1&quot;&gt;
                  File in .cursor directory (allows multiple config files)
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/Button&gt;
          &lt;/div&gt;

          &lt;DialogFooter&gt;
            &lt;Button
              variant=&quot;outline&quot;
              onClick={() =&gt; setShowLocationChoice(false)}
              disabled={isLoading}
            &gt;
              Cancel
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/TagBundleCreator.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>7425</size>
        <lastModified>2025-05-24T03:33:41.692Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/TagBundleCreator.tsx - Component to create tag-derived bundles
import { useState } from &#39;react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogDescription,
  DialogFooter,
} from &#39;@/components/ui/dialog&#39;;
import { ScrollArea } from &#39;@/components/ui/scroll-area&#39;;
import { Tag, Plus, Loader2, FileText, AlertCircle } from &#39;lucide-react&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { Alert, AlertDescription } from &#39;@/components/ui/alert&#39;;

export function TagBundleCreator() {
  const { tags, getFilesWithTag } = useTags();
  const { createTagBundle } = useBundles(); // This function needs to be added to BundleContext
  const [isCreating, setIsCreating] = useState&lt;string | null&gt;(null);
  const [isOpen, setIsOpen] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [success, setSuccess] = useState&lt;string | null&gt;(null);

  const handleCreateTagBundle = async (tagName: string) =&gt; {
    setIsCreating(tagName);
    setError(null);
    setSuccess(null);

    try {
      console.log(`Creating tag bundle for &quot;${tagName}&quot;...`);
      const bundleId = await createTagBundle(tagName);
      setSuccess(`Tag bundle created successfully: ${bundleId}`);

      // Auto-close after success
      setTimeout(() =&gt; {
        setIsOpen(false);
        setSuccess(null);
      }, 2000);
    } catch (error) {
      console.error(&#39;Failed to create tag bundle:&#39;, error);
      setError(error instanceof Error ? error.message : &#39;Failed to create tag bundle&#39;);
    } finally {
      setIsCreating(null);
    }
  };

  // Get available tags that have files
  const availableTags = Object.entries(tags).filter(([tagName]) =&gt; {
    const filesWithTag = getFilesWithTag(tagName);
    return filesWithTag.length &gt; 0;
  });

  const handleOpenChange = (open: boolean) =&gt; {
    if (!isCreating) {
      setIsOpen(open);
      if (!open) {
        setError(null);
        setSuccess(null);
      }
    }
  };

  return (
    &lt;Dialog open={isOpen} onOpenChange={handleOpenChange}&gt;
      &lt;DialogTrigger asChild&gt;
        &lt;Button variant=&quot;outline&quot; className=&quot;flex items-center&quot;&gt;
          &lt;Tag className=&quot;mr-2 h-4 w-4&quot; /&gt;
          Create Tag Bundle
        &lt;/Button&gt;
      &lt;/DialogTrigger&gt;
      &lt;DialogContent className=&quot;max-w-md&quot;&gt;
        &lt;DialogHeader&gt;
          &lt;DialogTitle className=&quot;flex items-center gap-2&quot;&gt;
            &lt;Tag className=&quot;h-5 w-5 text-green-600&quot; /&gt;
            Create Tag-Derived Bundle
          &lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Select a tag to create a bundle containing all files with that tag.
            This creates an auto-updating bundle based on your file tagging.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;

        &lt;div className=&quot;space-y-4&quot;&gt;
          {error &amp;&amp; (
            &lt;Alert variant=&quot;destructive&quot;&gt;
              &lt;AlertCircle className=&quot;h-4 w-4&quot; /&gt;
              &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
            &lt;/Alert&gt;
          )}

          {success &amp;&amp; (
            &lt;Alert className=&quot;border-green-600 bg-green-50 dark:bg-green-950/20&quot;&gt;
              &lt;Tag className=&quot;h-4 w-4 text-green-600&quot; /&gt;
              &lt;AlertDescription className=&quot;text-green-700 dark:text-green-300&quot;&gt;
                {success}
              &lt;/AlertDescription&gt;
            &lt;/Alert&gt;
          )}

          {availableTags.length === 0 ? (
            &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
              &lt;Tag className=&quot;h-8 w-8 mx-auto mb-2 opacity-50&quot; /&gt;
              &lt;p className=&quot;font-medium&quot;&gt;No tagged files found&lt;/p&gt;
              &lt;p className=&quot;text-sm&quot;&gt;Tag some files first, then come back to create tag bundles.&lt;/p&gt;
            &lt;/div&gt;
          ) : (
            &lt;&gt;
              &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                Available tags with files ({availableTags.length}):
              &lt;/div&gt;

              &lt;ScrollArea className=&quot;max-h-64&quot;&gt;
                &lt;div className=&quot;space-y-2&quot;&gt;
                  {availableTags.map(([tagName, tagConfig]) =&gt; {
                    const filesWithTag = getFilesWithTag(tagName);
                    const fileCount = filesWithTag.length;
                    const isLoading = isCreating === tagName;

                    return (
                      &lt;div
                        key={tagName}
                        className=&quot;flex items-center justify-between p-3 border rounded-lg hover:bg-muted/50 transition-colors&quot;
                      &gt;
                        &lt;div className=&quot;flex items-center space-x-3&quot;&gt;
                          &lt;div
                            className=&quot;w-4 h-4 rounded-full border-2 border-white shadow-sm&quot;
                            style={{ backgroundColor: tagConfig.color }}
                            title={tagConfig.description || `Tag: ${tagName}`}
                          /&gt;
                          &lt;div&gt;
                            &lt;div className=&quot;font-medium&quot;&gt;{tagName}&lt;/div&gt;
                            {tagConfig.description &amp;&amp; (
                              &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                                {tagConfig.description}
                              &lt;/div&gt;
                            )}
                          &lt;/div&gt;
                        &lt;/div&gt;

                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                          &lt;Badge variant=&quot;outline&quot; className=&quot;flex items-center gap-1&quot;&gt;
                            &lt;FileText className=&quot;h-3 w-3&quot; /&gt;
                            {fileCount}
                          &lt;/Badge&gt;

                          &lt;Button
                            size=&quot;sm&quot;
                            onClick={() =&gt; handleCreateTagBundle(tagName)}
                            disabled={isLoading || isCreating !== null}
                            className=&quot;min-w-[80px]&quot;
                          &gt;
                            {isLoading ? (
                              &lt;&gt;
                                &lt;Loader2 className=&quot;h-4 w-4 animate-spin mr-1&quot; /&gt;
                                Creating...
                              &lt;/&gt;
                            ) : (
                              &lt;&gt;
                                &lt;Plus className=&quot;h-4 w-4 mr-1&quot; /&gt;
                                Create
                              &lt;/&gt;
                            )}
                          &lt;/Button&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    );
                  })}
                &lt;/div&gt;
              &lt;/ScrollArea&gt;

              &lt;div className=&quot;text-xs text-muted-foreground bg-muted/30 p-3 rounded-lg&quot;&gt;
                &lt;strong&gt;Tip:&lt;/strong&gt; Tag-derived bundles automatically include all files
                with the selected tag. If you add or remove the tag from files later,
                you can recreate the bundle to get the updated file list.
              &lt;/div&gt;
            &lt;/&gt;
          )}
        &lt;/div&gt;

        &lt;DialogFooter&gt;
          &lt;Button
            variant=&quot;outline&quot;
            onClick={() =&gt; setIsOpen(false)}
            disabled={isCreating !== null}
          &gt;
            {availableTags.length === 0 ? &#39;Close&#39; : &#39;Cancel&#39;}
          &lt;/Button&gt;
        &lt;/DialogFooter&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/MasterBundleButton.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>5737</size>
        <lastModified>2025-05-22T00:43:04.226Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/MasterBundleButton.tsx
import { useState } from &#39;react&#39;;
import { Button } from &quot;@/components/ui/button&quot;;
import { Package } from &quot;lucide-react&quot;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;; // Added for ignore patterns
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from &quot;@/components/ui/dialog&quot;;
import { Alert, AlertDescription, AlertTitle } from &quot;@/components/ui/alert&quot;;
import { Info, AlertCircle, Loader2 } from &quot;lucide-react&quot;;

export function MasterBundleButton() {
  const { createMasterBundle, masterBundle } = useBundles();
  const { watchedFiles } = useFiles();
  const { ignorePatterns } = useProjectConfig(); // Get ignore patterns
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [success, setSuccess] = useState(false);

  // Calculate how many files will be included in the bundle after applying ignore patterns
  const includedFileCount = watchedFiles.filter(file =&gt; {
    // Check if file path matches any ignore pattern
    return !ignorePatterns.some(pattern =&gt; {
      // Handle wildcard extension patterns (e.g., *.js)
      if (pattern.startsWith(&#39;*.&#39;)) {
        const extension = pattern.slice(1); // Include the dot
        return file.path.toLowerCase().endsWith(extension.toLowerCase());
      }

      // Handle directory/exact matches
      const normalizedPath = file.path.toLowerCase();
      const normalizedPattern = pattern.toLowerCase();

      return normalizedPath === normalizedPattern ||
        normalizedPath.includes(`/${normalizedPattern}/`) ||
        normalizedPath.endsWith(`/${normalizedPattern}`) ||
        normalizedPath.startsWith(`${normalizedPattern}/`);
    });
  }).length;

  const handleCreateMasterBundle = async () =&gt; {
    setIsCreating(true);
    setError(null);
    setSuccess(false);

    try {
      await createMasterBundle();
      setSuccess(true);
      // Close dialog after success
      setTimeout(() =&gt; {
        setIsDialogOpen(false);
        setSuccess(false);
      }, 2000);
    } catch (err) {
      console.error(&#39;Error creating master bundle:&#39;, err);
      setError(err instanceof Error ? err.message : &#39;Failed to create master bundle&#39;);
    } finally {
      setIsCreating(false);
    }
  };

  return (
    &lt;&gt;
      &lt;Button
        variant=&quot;outline&quot;
        onClick={() =&gt; setIsDialogOpen(true)}
        className=&quot;flex items-center gap-2&quot;
      &gt;
        &lt;Package className=&quot;h-4 w-4&quot; /&gt;
        {masterBundle ? &quot;Update Master Bundle&quot; : &quot;Create Master Bundle&quot;}
      &lt;/Button&gt;

      &lt;Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}&gt;
        &lt;DialogContent&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;{masterBundle ? &quot;Update Master Bundle&quot; : &quot;Create Master Bundle&quot;}&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              {masterBundle
                ? &quot;Creating a new master bundle will update the reference point for tracking changes.&quot;
                : &quot;A master bundle creates a snapshot of all files in your project and helps track changes.&quot;}
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;

          &lt;div className=&quot;py-4 space-y-4&quot;&gt;
            &lt;Alert&gt;
              &lt;Info className=&quot;h-4 w-4&quot; /&gt;
              &lt;AlertDescription&gt;
                This will create a bundle with {includedFileCount} files after applying your ignore patterns.
                {watchedFiles.length - includedFileCount &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;block mt-1 text-sm&quot;&gt;
                    {watchedFiles.length - includedFileCount} files will be excluded based on your current ignore patterns.
                  &lt;/span&gt;
                )}
              &lt;/AlertDescription&gt;
            &lt;/Alert&gt;

            {ignorePatterns.length &gt; 0 &amp;&amp; (
              &lt;Alert variant=&quot;default&quot; className=&quot;border-blue-200 bg-blue-50 dark:bg-blue-900/20 dark:border-blue-800&quot;&gt;
                &lt;AlertTitle className=&quot;text-sm font-medium&quot;&gt;Active Ignore Patterns&lt;/AlertTitle&gt;
                &lt;AlertDescription&gt;
                  &lt;div className=&quot;mt-2 text-xs font-mono max-h-24 overflow-y-auto&quot;&gt;
                    {ignorePatterns.map((pattern, i) =&gt; (
                      &lt;div key={i} className=&quot;py-0.5&quot;&gt;{pattern}&lt;/div&gt;
                    ))}
                  &lt;/div&gt;
                &lt;/AlertDescription&gt;
              &lt;/Alert&gt;
            )}

            {error &amp;&amp; (
              &lt;Alert variant=&quot;destructive&quot;&gt;
                &lt;AlertCircle className=&quot;h-4 w-4&quot; /&gt;
                &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
              &lt;/Alert&gt;
            )}

            {success &amp;&amp; (
              &lt;Alert className=&quot;border-green-600 bg-green-50 dark:bg-green-900/20&quot;&gt;
                &lt;Info className=&quot;h-4 w-4 text-green-600 dark:text-green-400&quot; /&gt;
                &lt;AlertDescription className=&quot;text-green-700 dark:text-green-300&quot;&gt;
                  Master bundle created successfully!
                &lt;/AlertDescription&gt;
              &lt;/Alert&gt;
            )}
          &lt;/div&gt;

          &lt;DialogFooter&gt;
            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; setIsDialogOpen(false)} disabled={isCreating}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button onClick={handleCreateMasterBundle} disabled={isCreating || success}&gt;
              {isCreating &amp;&amp; &lt;Loader2 className=&quot;mr-2 h-4 w-4 animate-spin&quot; /&gt;}
              {masterBundle ? &quot;Update Master Bundle&quot; : &quot;Create Master Bundle&quot;}
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;
    &lt;/&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/TagsMainViewer.tsx</source>
      <tags>ui-components,business-logic</tags>
      <metadata>
        <size>12879</size>
        <lastModified>2025-05-27T01:34:02.830Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/TagsMainViewer.tsx
import { useState } from &#39;react&#39;;
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle
} from &quot;@/components/ui/card&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { Input } from &quot;@/components/ui/input&quot;;
import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
import {
  Pencil,
  Plus,
  Search,
  Trash2,
  FileText
} from &quot;lucide-react&quot;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from &quot;@/components/ui/dialog&quot;;

export function TagsMainViewer() {
  const { tags, addTag, updateTag, deleteTag, getFilesWithTag } = useTags();
  const { watchedFiles } = useFiles();

  const [filter, setFilter] = useState(&#39;&#39;);
  const [selectedTag, setSelectedTag] = useState&lt;string | null&gt;(null);
  const [taggedFiles, setTaggedFiles] = useState&lt;string[]&gt;([]);

  const [isAddingTag, setIsAddingTag] = useState(false);
  const [newTagName, setNewTagName] = useState(&#39;&#39;);
  const [newTagColor, setNewTagColor] = useState(&#39;#6366f1&#39;);
  const [newTagDescription, setNewTagDescription] = useState(&#39;&#39;);

  const [isEditingTag, setIsEditingTag] = useState(false);
  const [editTagName, setEditTagName] = useState(&#39;&#39;);
  const [editTagColor, setEditTagColor] = useState(&#39;&#39;);
  const [editTagDescription, setEditTagDescription] = useState(&#39;&#39;);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  // Filter tags based on search input
  const filteredTags = Object.entries(tags)
    .filter(([name, config]) =&gt;
      name.toLowerCase().includes(filter.toLowerCase()) ||
      config.description?.toLowerCase().includes(filter.toLowerCase())
    )
    .sort((a, b) =&gt; a[0].localeCompare(b[0]));

  // Handle tag selection
  const handleSelectTag = (tagName: string) =&gt; {
    setSelectedTag(tagName);
    const files = getFilesWithTag(tagName);
    setTaggedFiles(files.map(file =&gt; file.path));
  };

  // Handle adding a new tag
  const handleAddTag = async () =&gt; {
    if (newTagName.trim()) {
      await addTag(newTagName.trim(), newTagColor, newTagDescription);
      setNewTagName(&#39;&#39;);
      setNewTagColor(&#39;#6366f1&#39;);
      setNewTagDescription(&#39;&#39;);
      setIsAddingTag(false);
    }
  };

  // Handle updating a tag
  const handleUpdateTag = async () =&gt; {
    if (selectedTag) {
      await updateTag(selectedTag, editTagColor, editTagDescription);
      setIsEditingTag(false);
    }
  };

  // Handle deleting a tag
  const handleDeleteTag = async () =&gt; {
    if (selectedTag) {
      await deleteTag(selectedTag);
      setSelectedTag(null);
      setTaggedFiles([]);
      setShowDeleteDialog(false);
    }
  };

  // Start editing a tag
  const startEditingTag = () =&gt; {
    if (selectedTag &amp;&amp; tags[selectedTag]) {
      setEditTagName(selectedTag);
      setEditTagColor(tags[selectedTag].color || &#39;#6366f1&#39;);
      setEditTagDescription(tags[selectedTag].description || &#39;&#39;);
      setIsEditingTag(true);
    }
  };

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;
          &lt;CardTitle className=&quot;flex items-center justify-between&quot;&gt;
            &lt;span&gt;Tag Manager&lt;/span&gt;
            &lt;div className=&quot;flex gap-2&quot;&gt;
              &lt;Button onClick={() =&gt; setIsAddingTag(true)}&gt;
                &lt;Plus className=&quot;mr-2 h-4 w-4&quot; /&gt;
                Add Tag
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/CardTitle&gt;
          &lt;CardDescription&gt;
            Manage file tags and view tagged files
          &lt;/CardDescription&gt;
        &lt;/CardHeader&gt;
        &lt;CardContent&gt;
          &lt;div className=&quot;flex items-center space-x-2 mb-4&quot;&gt;
            &lt;Search className=&quot;h-4 w-4 text-muted-foreground&quot; /&gt;
            &lt;Input
              placeholder=&quot;Filter tags...&quot;
              value={filter}
              onChange={(e) =&gt; setFilter(e.target.value)}
              className=&quot;max-w-sm&quot;
            /&gt;
          &lt;/div&gt;

          &lt;div className=&quot;grid grid-cols-[300px_1fr] gap-4&quot;&gt;
            &lt;div&gt;
              &lt;ScrollArea className=&quot;h-[500px] pr-3&quot;&gt;
                &lt;div className=&quot;space-y-2&quot;&gt;
                  {filteredTags.length === 0 ? (
                    &lt;div className=&quot;text-center p-4 text-muted-foreground&quot;&gt;
                      No tags found
                    &lt;/div&gt;
                  ) : (
                    filteredTags.map(([name, config]) =&gt; (
                      &lt;div
                        key={name}
                        className={`flex items-center justify-between p-2 rounded-md border cursor-pointer hover:bg-muted ${selectedTag === name ? &#39;bg-muted&#39; : &#39;&#39;
                          }`}
                        onClick={() =&gt; handleSelectTag(name)}
                      &gt;
                        &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                          &lt;div
                            className=&quot;w-3 h-3 rounded-full&quot;
                            style={{ backgroundColor: config.color }}
                          /&gt;
                          &lt;span&gt;{name}&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;Badge variant=&quot;outline&quot;&gt;
                          {getFilesWithTag(name).length}
                        &lt;/Badge&gt;
                      &lt;/div&gt;
                    ))
                  )}
                &lt;/div&gt;
              &lt;/ScrollArea&gt;
            &lt;/div&gt;

            &lt;div&gt;
              {selectedTag ? (
                &lt;Card&gt;
                  &lt;CardHeader&gt;
                    &lt;CardTitle className=&quot;flex items-center justify-between&quot;&gt;
                      &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                        &lt;div
                          className=&quot;w-4 h-4 rounded-full&quot;
                          style={{ backgroundColor: tags[selectedTag]?.color || &#39;#6366f1&#39; }}
                        /&gt;
                        &lt;span&gt;{selectedTag}&lt;/span&gt;
                      &lt;/div&gt;
                      &lt;div className=&quot;flex space-x-2&quot;&gt;
                        &lt;Button
                          variant=&quot;outline&quot;
                          size=&quot;sm&quot;
                          onClick={startEditingTag}
                        &gt;
                          &lt;Pencil className=&quot;h-4 w-4&quot; /&gt;
                        &lt;/Button&gt;
                        &lt;Button
                          variant=&quot;outline&quot;
                          size=&quot;sm&quot;
                          onClick={() =&gt; setShowDeleteDialog(true)}
                        &gt;
                          &lt;Trash2 className=&quot;h-4 w-4&quot; /&gt;
                        &lt;/Button&gt;
                      &lt;/div&gt;
                    &lt;/CardTitle&gt;
                    &lt;CardDescription&gt;
                      {tags[selectedTag]?.description || &#39;No description&#39;}
                    &lt;/CardDescription&gt;
                  &lt;/CardHeader&gt;
                  &lt;CardContent&gt;
                    &lt;div className=&quot;flex items-center space-x-2 mb-2&quot;&gt;
                      &lt;FileText className=&quot;h-4 w-4 text-muted-foreground&quot; /&gt;
                      &lt;span&gt;Files with this tag ({taggedFiles.length})&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;ScrollArea className=&quot;h-[350px] w-full rounded-md border&quot;&gt;
                      {taggedFiles.length === 0 ? (
                        &lt;div className=&quot;text-center p-4 text-muted-foreground&quot;&gt;
                          No files with this tag
                        &lt;/div&gt;
                      ) : (
                        &lt;div className=&quot;p-4&quot;&gt;
                          {taggedFiles.map((path) =&gt; (
                            &lt;div
                              key={path}
                              className=&quot;py-1 px-2 hover:bg-muted rounded&quot;
                            &gt;
                              {path}
                            &lt;/div&gt;
                          ))}
                        &lt;/div&gt;
                      )}
                    &lt;/ScrollArea&gt;
                  &lt;/CardContent&gt;
                &lt;/Card&gt;
              ) : (
                &lt;div className=&quot;flex h-full items-center justify-center text-muted-foreground&quot;&gt;
                  Select a tag to see details
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;

      {/* Add Tag Dialog */}
      &lt;Dialog open={isAddingTag} onOpenChange={setIsAddingTag}&gt;
        &lt;DialogContent&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;Add New Tag&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              Create a new tag to organize your files
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;
          &lt;div className=&quot;space-y-4 py-4&quot;&gt;
            &lt;div className=&quot;grid grid-cols-[100px_1fr] items-center gap-4&quot;&gt;
              &lt;label htmlFor=&quot;tag-name&quot;&gt;Name&lt;/label&gt;
              &lt;Input
                id=&quot;tag-name&quot;
                value={newTagName}
                onChange={(e) =&gt; setNewTagName(e.target.value)}
                placeholder=&quot;Tag name&quot;
              /&gt;
            &lt;/div&gt;
            &lt;div className=&quot;grid grid-cols-[100px_1fr] items-center gap-4&quot;&gt;
              &lt;label htmlFor=&quot;tag-color&quot;&gt;Color&lt;/label&gt;
              &lt;div className=&quot;flex space-x-2 items-center&quot;&gt;
                &lt;Input
                  id=&quot;tag-color&quot;
                  type=&quot;color&quot;
                  value={newTagColor}
                  onChange={(e) =&gt; setNewTagColor(e.target.value)}
                  className=&quot;w-12&quot;
                /&gt;
                &lt;div
                  className=&quot;w-6 h-6 rounded-full border&quot;
                  style={{ backgroundColor: newTagColor }}
                /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;grid grid-cols-[100px_1fr] items-center gap-4&quot;&gt;
              &lt;label htmlFor=&quot;tag-description&quot;&gt;Description&lt;/label&gt;
              &lt;Input
                id=&quot;tag-description&quot;
                value={newTagDescription}
                onChange={(e) =&gt; setNewTagDescription(e.target.value)}
                placeholder=&quot;Tag description&quot;
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;DialogFooter&gt;
            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; setIsAddingTag(false)}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button onClick={handleAddTag} disabled={!newTagName.trim()}&gt;
              Add Tag
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;

      {/* Edit Tag Dialog */}
      &lt;Dialog open={isEditingTag} onOpenChange={setIsEditingTag}&gt;
        &lt;DialogContent&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;Edit Tag: {editTagName}&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              Update the tag properties
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;
          &lt;div className=&quot;space-y-4 py-4&quot;&gt;
            &lt;div className=&quot;grid grid-cols-[100px_1fr] items-center gap-4&quot;&gt;
              &lt;label htmlFor=&quot;edit-color&quot;&gt;Color&lt;/label&gt;
              &lt;div className=&quot;flex space-x-2 items-center&quot;&gt;
                &lt;Input
                  id=&quot;edit-color&quot;
                  type=&quot;color&quot;
                  value={editTagColor}
                  onChange={(e) =&gt; setEditTagColor(e.target.value)}
                  className=&quot;w-12&quot;
                /&gt;
                &lt;div
                  className=&quot;w-6 h-6 rounded-full border&quot;
                  style={{ backgroundColor: editTagColor }}
                /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;grid grid-cols-[100px_1fr] items-center gap-4&quot;&gt;
              &lt;label htmlFor=&quot;edit-description&quot;&gt;Description&lt;/label&gt;
              &lt;Input
                id=&quot;edit-description&quot;
                value={editTagDescription}
                onChange={(e) =&gt; setEditTagDescription(e.target.value)}
                placeholder=&quot;Tag description&quot;
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;DialogFooter&gt;
            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; setIsEditingTag(false)}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button onClick={handleUpdateTag}&gt;
              Update Tag
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;

      {/* Delete Tag Confirmation Dialog */}
      &lt;Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}&gt;
        &lt;DialogContent&gt;
          &lt;DialogHeader&gt;
            &lt;DialogTitle&gt;Delete Tag&lt;/DialogTitle&gt;
            &lt;DialogDescription&gt;
              Are you sure you want to delete the tag &quot;{selectedTag}&quot;? This action cannot be undone.
            &lt;/DialogDescription&gt;
          &lt;/DialogHeader&gt;
          &lt;DialogFooter&gt;
            &lt;Button variant=&quot;outline&quot; onClick={() =&gt; setShowDeleteDialog(false)}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button variant=&quot;destructive&quot; onClick={handleDeleteTag}&gt;
              Delete
            &lt;/Button&gt;
          &lt;/DialogFooter&gt;
        &lt;/DialogContent&gt;
      &lt;/Dialog&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/ApplicationContainer.tsx</source>
      <tags>ui-components,app-core</tags>
      <metadata>
        <size>7914</size>
        <lastModified>2025-05-27T02:36:49.585Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/ApplicationContainer.tsx
import { DirectoryPanel } from &quot;./DirectoryPanel&quot;;
import { MainContainer } from &quot;./MainContainer&quot;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from &quot;@/components/ui/card&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { FolderOpen, Zap, CheckCircle, FileText, Tag, Archive } from &quot;lucide-react&quot;;

export const ApplicationContainer = () =&gt; {
  const { directoryHandle, selectDirectory } = useDirectory();
  const { isProjectInitialized } = useProjectConfig();

  // Show the main application if we have both a directory and it&#39;s initialized
  if (directoryHandle &amp;&amp; isProjectInitialized) {
    return (
      &lt;div className=&quot;grid grid-cols-[1fr,3fr] h-screen mx-auto gap-4&quot;&gt;
        {/* Left Column - Directory Panel */}
        &lt;div className=&quot;p-4 border-r&quot;&gt;
          &lt;DirectoryPanel /&gt;
        &lt;/div&gt;

        {/* Main Column - App Interface */}
        &lt;div className=&quot;flex flex-col h-full overflow-auto&quot;&gt;
          &lt;MainContainer /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  // Show the setup screen
  // Show the setup screen with big brain wojak
  return (
    &lt;div className=&quot;h-screen bg-gradient-to-br from-background to-muted/20 relative overflow-hidden&quot;&gt;
      {/* Big Brain Wojak Background */}
      &lt;div
        className=&quot;absolute left-0 top-1/2 -translate-y-1/2 w-96 h-96 opacity-50 bg-no-repeat bg-contain&quot;
        style={{
          backgroundImage: `url(&quot;/wojak.png&quot;)`

        }}
      /&gt;

      &lt;div className=&quot;relative z-10 h-full flex items-center justify-center px-4&quot;&gt;
        &lt;div className=&quot;w-full max-w-6xl grid lg:grid-cols-2 gap-8 items-center&quot;&gt;
          {/* Floating Demo Box - Top */}
          &lt;Card className=&quot;absolute top-20 right-4 w-80 bg-background/70 backdrop-blur border-2 transform rotate-2 shadow-xl opacity-60 hover:opacity-90 transition-opacity hidden lg:block&quot;&gt;
            &lt;CardHeader className=&quot;pb-3&quot;&gt;
              &lt;CardTitle className=&quot;text-sm flex items-center gap-2&quot;&gt;
                &lt;Archive className=&quot;w-4 h-4 text-purple-500&quot; /&gt;
                Bundle Manager
              &lt;/CardTitle&gt;
            &lt;/CardHeader&gt;
            &lt;CardContent className=&quot;space-y-2 text-xs&quot;&gt;
              &lt;div className=&quot;flex justify-between items-center p-2 bg-muted/50 rounded&quot;&gt;
                &lt;span className=&quot;font-mono&quot;&gt;master-2025-01-15.txt&lt;/span&gt;
                &lt;span className=&quot;text-green-600 text-xs&quot;&gt;Fresh&lt;/span&gt;
              &lt;/div&gt;
              &lt;div className=&quot;flex justify-between items-center p-2 bg-muted/50 rounded&quot;&gt;
                &lt;span className=&quot;font-mono&quot;&gt;ui-components-bundle.txt&lt;/span&gt;
                &lt;span className=&quot;text-amber-600 text-xs&quot;&gt;Stale&lt;/span&gt;
              &lt;/div&gt;
              &lt;div className=&quot;flex justify-between items-center p-2 bg-muted/50 rounded&quot;&gt;
                &lt;span className=&quot;font-mono&quot;&gt;core-logic-bundle.txt&lt;/span&gt;
                &lt;span className=&quot;text-green-600 text-xs&quot;&gt;Fresh&lt;/span&gt;
              &lt;/div&gt;
            &lt;/CardContent&gt;
          &lt;/Card&gt;

          {/* Floating Demo Box - Bottom */}
          &lt;Card className=&quot;absolute bottom-16 left-1/2 w-72 bg-background/70 backdrop-blur border-2 transform -rotate-1 translate-x-32 shadow-xl opacity-60 hover:opacity-90 transition-opacity hidden lg:block&quot;&gt;
            &lt;CardHeader className=&quot;pb-3&quot;&gt;
              &lt;CardTitle className=&quot;text-sm flex items-center gap-2&quot;&gt;
                &lt;Tag className=&quot;w-4 h-4 text-blue-500&quot; /&gt;
                File Tags
              &lt;/CardTitle&gt;
            &lt;/CardHeader&gt;
            &lt;CardContent className=&quot;space-y-2&quot;&gt;
              &lt;div className=&quot;flex flex-wrap gap-1&quot;&gt;
                &lt;div className=&quot;px-2 py-1 bg-red-100 text-red-800 rounded text-xs flex items-center gap-1&quot;&gt;
                  &lt;div className=&quot;w-2 h-2 bg-red-500 rounded-full&quot;&gt;&lt;/div&gt;
                  core
                &lt;/div&gt;
                &lt;div className=&quot;px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs flex items-center gap-1&quot;&gt;
                  &lt;div className=&quot;w-2 h-2 bg-blue-500 rounded-full&quot;&gt;&lt;/div&gt;
                  ui-components
                &lt;/div&gt;
                &lt;div className=&quot;px-2 py-1 bg-green-100 text-green-800 rounded text-xs flex items-center gap-1&quot;&gt;
                  &lt;div className=&quot;w-2 h-2 bg-green-500 rounded-full&quot;&gt;&lt;/div&gt;
                  utilities
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=&quot;text-xs text-muted-foreground mt-2&quot;&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;FileText className=&quot;w-3 h-3&quot; /&gt;
                  &lt;span&gt;src/App.tsx&lt;/span&gt;
                &lt;/div&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;FileText className=&quot;w-3 h-3&quot; /&gt;
                  &lt;span&gt;src/components/Button.tsx&lt;/span&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/CardContent&gt;
          &lt;/Card&gt;

          {/* Left side - overlaps with wojak */}
          &lt;div className=&quot;space-y-8 lg:pl-32 relative z-20&quot;&gt;
            &lt;div className=&quot;text-center lg:text-left&quot;&gt;
              &lt;h1 className=&quot;text-5xl lg:text-6xl font-bold mb-4 bg-gradient-to-r from-foreground to-muted-foreground bg-clip-text text-transparent&quot;&gt;
                cntx-ui
              &lt;/h1&gt;
              &lt;p className=&quot;text-lg text-muted-foreground&quot;&gt;
                File bundling and tagging tool for AI development workflows
              &lt;/p&gt;
            &lt;/div&gt;

            &lt;Card className=&quot;bg-background/80 backdrop-blur border-2 shadow-2xl&quot;&gt;
              &lt;CardHeader className=&quot;text-center lg:text-left pb-4&quot;&gt;
                &lt;CardTitle className=&quot;text-2xl&quot;&gt;Get Started&lt;/CardTitle&gt;
                &lt;CardDescription&gt;
                  Select a directory to begin. Previously initialized projects load instantly.
                &lt;/CardDescription&gt;
              &lt;/CardHeader&gt;

              &lt;CardContent className=&quot;space-y-6&quot;&gt;
                &lt;div className=&quot;grid gap-4&quot;&gt;
                  &lt;div className=&quot;flex items-start space-x-3 p-4 rounded-lg border bg-card/50 backdrop-blur&quot;&gt;
                    &lt;Zap className=&quot;w-5 h-5 text-blue-500 mt-0.5 flex-shrink-0&quot; /&gt;
                    &lt;div&gt;
                      &lt;h4 className=&quot;font-medium text-sm&quot;&gt;New Projects&lt;/h4&gt;
                      &lt;p className=&quot;text-xs text-muted-foreground mt-1&quot;&gt;
                        Initialize any directory to start tracking files and creating bundles
                      &lt;/p&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;

                  &lt;div className=&quot;flex items-start space-x-3 p-4 rounded-lg border bg-card/50 backdrop-blur&quot;&gt;
                    &lt;CheckCircle className=&quot;w-5 h-5 text-green-500 mt-0.5 flex-shrink-0&quot; /&gt;
                    &lt;div&gt;
                      &lt;h4 className=&quot;font-medium text-sm&quot;&gt;Existing Projects&lt;/h4&gt;
                      &lt;p className=&quot;text-xs text-muted-foreground mt-1&quot;&gt;
                        Projects with a &lt;code className=&quot;text-xs bg-muted px-1 rounded&quot;&gt;.cntx&lt;/code&gt; folder load instantly
                      &lt;/p&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;

                &lt;div className=&quot;pt-4 space-y-4&quot;&gt;
                  &lt;Button
                    onClick={selectDirectory}
                    size=&quot;lg&quot;
                    className=&quot;w-full text-lg py-6&quot;
                  &gt;
                    &lt;FolderOpen className=&quot;mr-3 h-6 w-6&quot; /&gt;
                    Select Directory
                  &lt;/Button&gt;
                  &lt;p className=&quot;text-sm text-muted-foreground text-center&quot;&gt;
                    Choose any directory to get started
                  &lt;/p&gt;
                &lt;/div&gt;
              &lt;/CardContent&gt;
            &lt;/Card&gt;
          &lt;/div&gt;

          {/* Right side - empty space for visual balance */}
          &lt;div className=&quot;hidden lg:block&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/DirectoryPanel.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>5364</size>
        <lastModified>2025-05-24T20:26:27.809Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/DirectoryPanel.tsx
import { useCallback } from &#39;react&#39;;
import { Filter, FolderOpen } from &quot;lucide-react&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { ModeToggle } from &#39;./theme/mode-toggle&#39;;
import { DirectoryTree } from &#39;./DirectoryTree&#39;;
import { BatchTagButton } from &#39;./BatchTagButton&#39;;

// Import all the necessary context hooks including ProjectConfigContext
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;

export function DirectoryPanel() {
  const {
    currentDirectory,
    selectDirectory,
    isWatching
  } = useDirectory();

  const {
    watchedFiles,
    stagedFiles,
    toggleStaged,
    refreshFiles
  } = useFiles();

  const {
    createBundle
  } = useBundles();

  const {
    ignorePatterns
  } = useProjectConfig();

  // Handle bundle creation
  const handleMakeBundle = useCallback(async () =&gt; {
    if (stagedFiles.length === 0) {
      console.log(&#39;No files staged for bundle&#39;);
      return;
    }

    try {
      const bundleId = await createBundle();
      console.log(&#39;📦 Bundle created successfully:&#39;, bundleId);

      // Refresh files after bundle creation
      await refreshFiles();
    } catch (error) {
      console.error(&#39;Error creating bundle:&#39;, error);
    }
  }, [stagedFiles.length, createBundle, refreshFiles]);

  // Handle clearing staged files
  const handleClearStaged = useCallback(() =&gt; {
    if (stagedFiles.length &gt; 0) {
      toggleStaged(stagedFiles.map(f =&gt; f.path));
    }
  }, [stagedFiles, toggleStaged]);

  // Handle successful tagging (refresh the tree to show new tags)
  const handleTagsApplied = useCallback(async () =&gt; {
    console.log(&#39;🏷️  Tags applied successfully, refreshing file tree...&#39;);
    await refreshFiles();
  }, [refreshFiles]);

  const handleFilterFiles = useCallback(() =&gt; {
    // Implementation for filtering files - could open a filter dialog
    console.log(&#39;🔍 Filter files clicked - implement filter dialog&#39;);
  }, []);

  // Log the current ignore patterns to verify they&#39;re loaded correctly
  // console.log(&quot;DirectoryPanel - Current ignore patterns:&quot;, ignorePatterns);

  return (
    &lt;div className=&quot;h-full flex flex-col&quot;&gt;
      &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
        &lt;Button
          onClick={selectDirectory}
          variant={isWatching ? &quot;outline&quot; : &quot;default&quot;}
          className=&quot;flex-grow mr-2&quot;
        &gt;
          &lt;FolderOpen className=&quot;mr-2 h-4 w-4&quot; /&gt;
          {currentDirectory || &#39;Select Directory&#39;}
        &lt;/Button&gt;
        &lt;ModeToggle /&gt;
      &lt;/div&gt;

      {/* File actions */}
      {isWatching &amp;&amp; (
        &lt;div className=&quot;flex flex-col gap-2 mb-4&quot;&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;Button
              onClick={handleMakeBundle}
              variant=&quot;outline&quot;
              size=&quot;sm&quot;
              disabled={stagedFiles.length === 0}
              className=&quot;flex-grow&quot;
            &gt;
              Bundle ({stagedFiles.length})
            &lt;/Button&gt;

            {/* NEW: Batch Tag Button */}
            &lt;BatchTagButton
              selectedFiles={stagedFiles}
              onTagsApplied={handleTagsApplied}
            /&gt;

            &lt;Button
              onClick={handleFilterFiles}
              variant=&quot;outline&quot;
              size=&quot;sm&quot;
              title=&quot;Filter files (coming soon)&quot;
            &gt;
              &lt;Filter className=&quot;h-4 w-4&quot; /&gt;
            &lt;/Button&gt;
          &lt;/div&gt;

          &lt;div className=&quot;flex gap-2&quot;&gt;
            &lt;Button
              onClick={handleClearStaged}
              variant=&quot;outline&quot;
              size=&quot;sm&quot;
              disabled={stagedFiles.length === 0}
              className=&quot;flex-grow&quot;
            &gt;
              Clear Selection
            &lt;/Button&gt;
          &lt;/div&gt;

          {/* Selection summary */}
          {stagedFiles.length &gt; 0 &amp;&amp; (
            &lt;div className=&quot;text-xs text-muted-foreground bg-muted rounded p-2&quot;&gt;
              &lt;div className=&quot;font-medium&quot;&gt;Selected files:&lt;/div&gt;
              &lt;div className=&quot;max-h-20 overflow-y-auto mt-1&quot;&gt;
                {stagedFiles.slice(0, 5).map((file, index) =&gt; (
                  &lt;div key={file.path} className=&quot;truncate&quot;&gt;
                    {index + 1}. {file.name}
                    {file.tags &amp;&amp; file.tags.length &gt; 0 &amp;&amp; (
                      &lt;span className=&quot;ml-2 text-xs opacity-70&quot;&gt;
                        [{file.tags.join(&#39;, &#39;)}]
                      &lt;/span&gt;
                    )}
                  &lt;/div&gt;
                ))}
                {stagedFiles.length &gt; 5 &amp;&amp; (
                  &lt;div className=&quot;text-xs opacity-70 mt-1&quot;&gt;
                    ... and {stagedFiles.length - 5} more
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
      )}

      {/* Directory Tree - ensure it gets the necessary configuration */}
      {watchedFiles.length &gt; 0 ? (
        &lt;DirectoryTree
          files={watchedFiles}
          onToggleStage={toggleStaged}
        /&gt;
      ) : (
        &lt;div className=&quot;text-center py-8 text-muted-foreground&quot;&gt;
          {isWatching ? &#39;No files found in selected directory&#39; : &#39;Select a directory to get started&#39;}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/InitializationModal.tsx</source>
      <tags>ui-components,configuration</tags>
      <metadata>
        <size>7112</size>
        <lastModified>2025-05-26T20:48:53.009Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/InitializationModal.tsx
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from &quot;@/components/ui/dialog&quot;
import { Button } from &quot;@/components/ui/button&quot;
import { Card, CardContent } from &quot;@/components/ui/card&quot;
import { useState, useEffect } from &quot;react&quot;
import { Loader2, AlertCircle, CheckCircle, Zap, Settings, FolderOpen } from &quot;lucide-react&quot;
import { Alert, AlertDescription, AlertTitle } from &quot;@/components/ui/alert&quot;
import type { FileSystemDirectoryHandle } from &quot;@/types/types&quot;
import { initializeProject } from &#39;../utils/project-utils&#39;

interface InitializationModalProps {
  isOpen: boolean;
  onComplete: () =&gt; void;
  dirHandle: FileSystemDirectoryHandle;
  forceAppUpdate: () =&gt; void;  // New prop to force parent update
}

type Status = &#39;idle&#39; | &#39;loading&#39; | &#39;error&#39; | &#39;success&#39; | &#39;loading-app&#39;;

export function InitializationModal({
  isOpen,
  onComplete,
  dirHandle,
  forceAppUpdate
}: InitializationModalProps) {
  const [status, setStatus] = useState&lt;Status&gt;(&#39;idle&#39;);
  const [error, setError] = useState&lt;string&gt;(&#39;&#39;);

  useEffect(() =&gt; {
    if (isOpen) {
      setStatus(&#39;idle&#39;);
      setError(&#39;&#39;);
    }
  }, [isOpen]);

  const handleInitConfig = async () =&gt; {
    setStatus(&#39;loading&#39;);
    setError(&#39;&#39;);

    try {
      await initializeProject(dirHandle);
      setStatus(&#39;success&#39;);
    } catch (error) {
      console.error(&#39;Failed to initialize project:&#39;, error);
      setError(error instanceof Error ? error.message : &#39;Failed to initialize project configuration.&#39;);
      setStatus(&#39;error&#39;);
    }
  };

  const handleComplete = async () =&gt; {
    try {
      setStatus(&#39;loading-app&#39;);

      // Force parent component to update
      forceAppUpdate();

      // Close modal
      onComplete();
    } catch (error) {
      console.error(&#39;Error completing initialization:&#39;, error);
      setError(&#39;Failed to complete initialization.&#39;);
      setStatus(&#39;error&#39;);
    }
  };

  return (
    &lt;Dialog open={isOpen}&gt;
      &lt;DialogContent className=&quot;max-w-2xl border-0 bg-transparent shadow-none p-0&quot;&gt;
        &lt;div className=&quot;bg-gradient-to-br from-background to-muted/20 rounded-lg p-8&quot;&gt;
          &lt;Card className=&quot;border-0 bg-background/95 backdrop-blur&quot;&gt;
            &lt;DialogHeader className=&quot;text-center pb-6 px-6 pt-6&quot;&gt;
              &lt;div className=&quot;w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center mx-auto mb-4&quot;&gt;
                {status === &#39;loading-app&#39; ? (
                  &lt;Loader2 className=&quot;w-8 h-8 text-primary animate-spin&quot; /&gt;
                ) : (
                  &lt;FolderOpen className=&quot;w-8 h-8 text-primary&quot; /&gt;
                )}
              &lt;/div&gt;
              &lt;DialogTitle className=&quot;text-2xl&quot;&gt;
                {status === &#39;loading-app&#39; ? &#39;Loading Application...&#39; : &#39;Project Initialization&#39;}
              &lt;/DialogTitle&gt;
              &lt;DialogDescription className=&quot;text-base&quot;&gt;
                {status === &#39;loading-app&#39;
                  ? &#39;Setting up your workspace and loading files...&#39;
                  : &#39;Initialize this directory with Cntx to track file changes, manage tags, and create bundles for AI consumption.&#39;}
              &lt;/DialogDescription&gt;
            &lt;/DialogHeader&gt;

            &lt;CardContent className=&quot;space-y-6 px-6 pb-6&quot;&gt;
              {error &amp;&amp; (
                &lt;Alert variant=&quot;destructive&quot;&gt;
                  &lt;AlertCircle className=&quot;h-4 w-4&quot; /&gt;
                  &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
                &lt;/Alert&gt;
              )}

              {status !== &#39;loading-app&#39; &amp;&amp; (
                &lt;&gt;
                  &lt;div className=&quot;space-y-4&quot;&gt;
                    &lt;div&gt;
                      &lt;h4 className=&quot;font-medium mb-4 text-center&quot;&gt;What This Will Do&lt;/h4&gt;
                      &lt;div className=&quot;grid gap-3&quot;&gt;
                        &lt;div className=&quot;flex items-center space-x-3 p-3 rounded-lg border bg-card/50&quot;&gt;
                          &lt;Settings className=&quot;w-5 h-5 text-blue-500 flex-shrink-0&quot; /&gt;
                          &lt;div&gt;
                            &lt;p className=&quot;text-sm font-medium&quot;&gt;Creates project structure&lt;/p&gt;
                            &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
                              Sets up a &lt;code className=&quot;bg-muted px-1 rounded&quot;&gt;.cntx&lt;/code&gt; directory with configuration and state tracking
                            &lt;/p&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;

                        &lt;div className=&quot;flex items-center space-x-3 p-3 rounded-lg border bg-card/50&quot;&gt;
                          &lt;Zap className=&quot;w-5 h-5 text-green-500 flex-shrink-0&quot; /&gt;
                          &lt;div&gt;
                            &lt;p className=&quot;text-sm font-medium&quot;&gt;Configures default settings&lt;/p&gt;
                            &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
                              Sets up file ignore patterns and initial tag system
                            &lt;/p&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;

                  {status === &#39;success&#39; ? (
                    &lt;div className=&quot;space-y-4&quot;&gt;
                      &lt;Alert className=&quot;border-green-600 bg-green-50 dark:bg-green-900/20&quot;&gt;
                        &lt;CheckCircle className=&quot;h-4 w-4 text-green-600 dark:text-green-400&quot; /&gt;
                        &lt;AlertTitle className=&quot;text-green-800 dark:text-green-200&quot;&gt;Initialization Complete&lt;/AlertTitle&gt;
                        &lt;AlertDescription className=&quot;text-green-700 dark:text-green-300&quot;&gt;
                          Project setup is complete. Remember to check the Config tab if you need to customize ignore patterns for your project.
                        &lt;/AlertDescription&gt;
                      &lt;/Alert&gt;
                      &lt;Button
                        onClick={handleComplete}
                        className=&quot;w-full&quot;
                        size=&quot;lg&quot;
                      &gt;
                        &lt;CheckCircle className=&quot;mr-2 h-5 w-5&quot; /&gt;
                        Begin Using Cntx
                      &lt;/Button&gt;
                    &lt;/div&gt;
                  ) : (
                    &lt;Button
                      onClick={handleInitConfig}
                      disabled={status === &#39;loading&#39;}
                      className=&quot;w-full&quot;
                      size=&quot;lg&quot;
                    &gt;
                      {status === &#39;loading&#39; &amp;&amp; (
                        &lt;Loader2 className=&quot;mr-2 h-5 w-5 animate-spin&quot; /&gt;
                      )}
                      {status === &#39;loading&#39; ? &#39;Initializing Project...&#39; : &#39;Initialize Project&#39;}
                    &lt;/Button&gt;
                  )}
                &lt;/&gt;
              )}

              {status === &#39;loading-app&#39; &amp;&amp; (
                &lt;div className=&quot;py-8 text-center&quot;&gt;
                  &lt;Loader2 className=&quot;w-8 h-8 mx-auto mb-4 animate-spin text-primary&quot; /&gt;
                  &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;Loading your workspace...&lt;/p&gt;
                &lt;/div&gt;
              )}
            &lt;/CardContent&gt;
          &lt;/Card&gt;
        &lt;/div&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/BundleMainViewer.tsx</source>
      <tags>ui-components,file-operations</tags>
      <metadata>
        <size>25396</size>
        <lastModified>2025-05-27T01:14:16.369Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/BundleMainViewer.tsx - Fixed bundle counting and update actions
import { useEffect, useState } from &#39;react&#39;;
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle
} from &quot;@/components/ui/card&quot;;
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from &quot;@/components/ui/table&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { Badge } from &quot;@/components/ui/badge&quot;;
import { Input } from &quot;@/components/ui/input&quot;;
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from &quot;@/components/ui/select&quot;;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from &quot;@/components/ui/dropdown-menu&quot;;
import {
  Copy,
  Download,
  Clock,
  FileText,
  ArrowUpDown,
  RefreshCw,
  Tag,
  ArrowLeft,
  Archive,
  Crown,
  Palette,
  MoreVertical,
  RotateCcw,
  Plus
} from &quot;lucide-react&quot;;
import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { Alert, AlertDescription } from &quot;@/components/ui/alert&quot;;
import { AlertCircle } from &quot;lucide-react&quot;;
import { BundleAnalysisBadge } from &#39;./BundleAnalysisBadge&#39;;
import { BundleView } from &#39;./BundleView&#39;;
import type { Bundle, BundleType } from &#39;@/types/types&#39;;

export function BundleMainViewer() {
  const { bundles, masterBundle, loadBundles, createMasterBundle, createTagBundle } = useBundles();
  const { directoryHandle } = useDirectory();
  const { tags: allTags } = useTags();
  const { stagedFiles } = useFiles();
  const [sortField, setSortField] = useState&lt;&#39;name&#39; | &#39;timestamp&#39; | &#39;fileCount&#39;&gt;(&#39;timestamp&#39;);
  const [sortDirection, setSortDirection] = useState&lt;&#39;asc&#39; | &#39;desc&#39;&gt;(&#39;desc&#39;);
  const [filter, setFilter] = useState(&#39;&#39;);
  const [typeFilter, setTypeFilter] = useState&lt;BundleType | &#39;all&#39;&gt;(&#39;all&#39;);
  const [selectedBundle, setSelectedBundle] = useState&lt;string | null&gt;(null);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [updatingBundles, setUpdatingBundles] = useState&lt;Set&lt;string&gt;&gt;(new Set());

  // FIXED: Better bundle type detection function
  const getBundleType = (bundle: Bundle): BundleType =&gt; {
    // Add validation to prevent invalid bundle objects
    if (!bundle || typeof bundle !== &#39;object&#39;) {
      console.error(&#39;Invalid bundle object:&#39;, bundle);
      return &#39;custom&#39;;
    }

    // First check the explicit type property
    if (bundle.type &amp;&amp; [&#39;master&#39;, &#39;tag-derived&#39;, &#39;custom&#39;].includes(bundle.type)) {
      return bundle.type;
    }

    // Fallback logic for older bundles without explicit type
    if (bundle.name &amp;&amp; bundle.name.startsWith(&#39;master-&#39;)) {
      return &#39;master&#39;;
    }

    if (bundle.derivedFromTag &amp;&amp; typeof bundle.derivedFromTag === &#39;string&#39;) {
      return &#39;tag-derived&#39;;
    }

    // Default to custom for anything else
    return &#39;custom&#39;;
  };

  // Bundle update handlers
  // 1. Fix Master Bundle Update - Replace instead of create new
  const handleUpdateMasterBundle = async () =&gt; {
    setUpdatingBundles(prev =&gt; new Set(prev).add(&#39;master&#39;));
    try {
      // Delete existing master bundle first
      if (masterBundle) {
        await deleteBundleFiles(masterBundle, &#39;master&#39;);
      }

      await createMasterBundle();
      await loadBundles();
      console.log(&#39;✅ Master bundle updated successfully&#39;);
    } catch (error) {
      console.error(&#39;❌ Error updating master bundle:&#39;, error);
      setError(`Failed to update master bundle: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}`);
    } finally {
      setUpdatingBundles(prev =&gt; {
        const newSet = new Set(prev);
        newSet.delete(&#39;master&#39;);
        return newSet;
      });
    }
  };

  // 2. Fix Tag Bundle Update - Replace instead of create new
  const handleUpdateTagBundle = async (bundle: Bundle) =&gt; {
    if (!bundle.derivedFromTag) return;

    setUpdatingBundles(prev =&gt; new Set(prev).add(bundle.name));
    try {
      // Delete existing tag bundle first
      await deleteBundleFiles(bundle, &#39;tag-derived&#39;);

      // Create new bundle with same tag
      await createTagBundle(bundle.derivedFromTag);
      await loadBundles();
      console.log(`✅ Tag bundle &quot;${bundle.derivedFromTag}&quot; updated successfully`);
    } catch (error) {
      console.error(&#39;❌ Error updating tag bundle:&#39;, error);
      setError(`Failed to update tag bundle: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}`);
    } finally {
      setUpdatingBundles(prev =&gt; {
        const newSet = new Set(prev);
        newSet.delete(bundle.name);
        return newSet;
      });
    }
  };

  // 3. Add helper function to delete bundle files
  const deleteBundleFiles = async (bundle: Bundle, bundleType: BundleType) =&gt; {
    if (!directoryHandle) return;

    try {
      const cntxDir = await directoryHandle.getDirectoryHandle(&#39;.cntx&#39;);
      const bundlesDir = await cntxDir.getDirectoryHandle(&#39;bundles&#39;);

      let targetDir: FileSystemDirectoryHandle;

      switch (bundleType) {
        case &#39;master&#39;:
          targetDir = await bundlesDir.getDirectoryHandle(&#39;master&#39;);
          break;
        case &#39;tag-derived&#39;:
          const tagBundlesDir = await bundlesDir.getDirectoryHandle(&#39;tag-bundles&#39;);
          targetDir = await tagBundlesDir.getDirectoryHandle(bundle.derivedFromTag!);
          break;
        case &#39;custom&#39;:
        default:
          targetDir = bundlesDir;
          break;
      }

      // Delete bundle file
      try {
        await targetDir.removeEntry(bundle.name);
        console.log(`🗑️ Deleted bundle file: ${bundle.name}`);
      } catch (error) {
        console.warn(`Could not delete bundle file ${bundle.name}:`, error);
      }

      // Delete manifest file
      const manifestName = `${bundle.id || bundle.name.replace(&#39;.txt&#39;, &#39;&#39;)}-manifest.json`;
      try {
        await targetDir.removeEntry(manifestName);
        console.log(`🗑️ Deleted manifest file: ${manifestName}`);
      } catch (error) {
        console.warn(`Could not delete manifest file ${manifestName}:`, error);
      }

    } catch (error) {
      console.error(&#39;Error deleting bundle files:&#39;, error);
      throw error;
    }
  };

  // 4. Fix Custom Bundle Update - Provide better UX
  const handleUpdateCustomBundle = async (bundle: Bundle) =&gt; {
    // For custom bundles, we need to ask user what to do since we don&#39;t know which files to include
    const message = `Custom bundle &quot;${bundle.name}&quot; requires manual recreation:

1. Select the files you want to include
2. Create a new bundle (this will replace the old one)
3. Or stage files and use &quot;Bundle&quot; button

Would you like to delete the old bundle now?`;

    if (confirm(message)) {
      try {
        await deleteBundleFiles(bundle, &#39;custom&#39;);
        await loadBundles();
        setError(`Old bundle &quot;${bundle.name}&quot; deleted. Create a new bundle with your selected files.`);
      } catch (error) {
        setError(`Failed to delete old bundle: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}`);
      }
    } else {
      setError(`To update &quot;${bundle.name}&quot;: select files and create a new bundle. The old one will remain for reference.`);
    }
  };

  // Universal bundle update dispatcher
  const handleUpdateBundle = async (bundle: Bundle) =&gt; {
    const bundleType = getBundleType(bundle);

    switch (bundleType) {
      case &#39;master&#39;:
        await handleUpdateMasterBundle();
        break;
      case &#39;tag-derived&#39;:
        await handleUpdateTagBundle(bundle);
        break;
      case &#39;custom&#39;:
        await handleUpdateCustomBundle(bundle);
        break;
      default:
        setError(`Unknown bundle type: ${bundleType}`);
    }
  };

  useEffect(() =&gt; {
    loadBundles();
  }, [loadBundles]);

  // Helper function to get bundle type display information
  const getBundleTypeDisplay = (bundle: Bundle) =&gt; {
    const bundleType = getBundleType(bundle);

    switch (bundleType) {
      case &#39;master&#39;:
        return {
          badge: (
            &lt;Badge variant=&quot;default&quot; className=&quot;bg-blue-600 hover:bg-blue-700&quot;&gt;
              &lt;Crown className=&quot;h-3 w-3 mr-1&quot; /&gt;
              Master
            &lt;/Badge&gt;
          ),
          icon: &lt;Crown className=&quot;h-4 w-4 text-blue-600&quot; /&gt;,
          description: &quot;Complete project snapshot&quot;,
          canUpdate: true
        };
      case &#39;tag-derived&#39;: {
        const tagName = bundle.derivedFromTag || &#39;Tag Bundle&#39;;
        const tagConfig = allTags[tagName];
        const tagColor = tagConfig?.color || &#39;#22c55e&#39;;
        const hexToRgba = (hex: string, alpha: number) =&gt; {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        return {
          badge: (
            &lt;Badge
              variant=&quot;outline&quot;
              style={{
                borderColor: tagColor,
                backgroundColor: hexToRgba(tagColor, 0.1),
                color: tagColor
              }}
            &gt;
              &lt;Tag className=&quot;h-3 w-3 mr-1&quot; /&gt;
              {tagName}
            &lt;/Badge&gt;
          ),
          icon: &lt;Tag className=&quot;h-4 w-4&quot; style={{ color: tagColor }} /&gt;,
          description: bundle.description || `Files tagged with &quot;${tagName}&quot;`,
          canUpdate: true
        };
      }
      case &#39;custom&#39;:
      default:
        return {
          badge: (
            &lt;Badge variant=&quot;secondary&quot; className=&quot;bg-gray-100 text-gray-700 dark:bg-gray-800&quot;&gt;
              &lt;Palette className=&quot;h-3 w-3 mr-1&quot; /&gt;
              Custom
            &lt;/Badge&gt;
          ),
          icon: &lt;Palette className=&quot;h-4 w-4 text-gray-600&quot; /&gt;,
          description: &quot;Manually selected files&quot;,
          canUpdate: true // FIXED: Custom bundles can now show update option (with explanation)
        };
    }
  };

  // Combine regular bundles with master bundle for display
  const allBundles = [...bundles];
  if (masterBundle) {
    const masterExists = allBundles.some(b =&gt; b.name === masterBundle.name);
    if (!masterExists) {
      allBundles.unshift(masterBundle);
    }
  }

  // Filter and sort bundles
  const filteredBundles = allBundles.filter(bundle =&gt; {
    const matchesSearch = bundle.name.toLowerCase().includes(filter.toLowerCase()) ||
      bundle.description?.toLowerCase().includes(filter.toLowerCase());

    const bundleType = getBundleType(bundle); // FIXED: Use the fixed type detection
    const matchesType = typeFilter === &#39;all&#39; || bundleType === typeFilter;
    return matchesSearch &amp;&amp; matchesType;
  });

  const sortedBundles = [...filteredBundles].sort((a, b) =&gt; {
    if (sortField === &#39;timestamp&#39;) {
      return sortDirection === &#39;asc&#39;
        ? a.timestamp.getTime() - b.timestamp.getTime()
        : b.timestamp.getTime() - a.timestamp.getTime();
    } else if (sortField === &#39;fileCount&#39;) {
      return sortDirection === &#39;asc&#39;
        ? a.fileCount - b.fileCount
        : b.fileCount - a.fileCount;
    } else {
      return sortDirection === &#39;asc&#39;
        ? a.name.localeCompare(b.name)
        : b.name.localeCompare(a.name);
    }
  });

  // Existing utility functions
  const handleSort = (field: &#39;name&#39; | &#39;timestamp&#39; | &#39;fileCount&#39;) =&gt; {
    if (field === sortField) {
      setSortDirection(sortDirection === &#39;asc&#39; ? &#39;desc&#39; : &#39;asc&#39;);
    } else {
      setSortField(field);
      setSortDirection(&#39;desc&#39;);
    }
  };

  const handleBundleSelect = (bundleName: string) =&gt; {
    setSelectedBundle(bundleName);
    setError(null);
  };

  const handleBackToBundles = () =&gt; {
    setSelectedBundle(null);
    setError(null);
  };

  const handleRefresh = async () =&gt; {
    await loadBundles();
  };

  const copyBundleContent = async (bundleName: string) =&gt; {
    console.log(&#39;Copy bundle content for:&#39;, bundleName);
  };

  const downloadBundle = async (bundleName: string) =&gt; {
    console.log(&#39;Download bundle:&#39;, bundleName);
  };

  const formatTimestamp = (date: Date) =&gt; {
    return new Intl.DateTimeFormat(&#39;en-US&#39;, {
      month: &#39;short&#39;,
      day: &#39;2-digit&#39;,
      hour: &#39;2-digit&#39;,
      minute: &#39;2-digit&#39;,
      year: &#39;numeric&#39;
    }).format(date);
  };

  // FIXED: Bundle statistics calculation with proper type detection
  const bundleStats = {
    total: allBundles.length,
    master: allBundles.filter(b =&gt; getBundleType(b) === &#39;master&#39;).length,
    tagDerived: allBundles.filter(b =&gt; getBundleType(b) === &#39;tag-derived&#39;).length,
    custom: allBundles.filter(b =&gt; getBundleType(b) === &#39;custom&#39;).length,
  };

  const selectedBundleObj = selectedBundle
    ? sortedBundles.find(b =&gt; b.name === selectedBundle)
    : null;

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;
          &lt;div className=&quot;flex justify-between items-center&quot;&gt;
            &lt;div&gt;
              {selectedBundle ? (
                &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                  &lt;Button
                    variant=&quot;ghost&quot;
                    onClick={handleBackToBundles}
                    className=&quot;flex items-center px-2&quot;
                  &gt;
                    &lt;ArrowLeft className=&quot;h-4 w-4 mr-1&quot; /&gt;
                    Bundles
                  &lt;/Button&gt;
                &lt;/div&gt;
              ) : (
                &lt;div&gt;
                  &lt;CardTitle className=&quot;flex items-center gap-2&quot;&gt;
                    &lt;Archive className=&quot;h-5 w-5&quot; /&gt;
                    Bundle Manager
                    &lt;div className=&quot;flex items-center gap-1 text-xs text-muted-foreground&quot;&gt;
                      ({bundleStats.total} total)
                    &lt;/div&gt;
                  &lt;/CardTitle&gt;
                  &lt;CardDescription&gt;
                    Manage your file bundles • {bundleStats.master} Master • {bundleStats.tagDerived} Tag-derived • {bundleStats.custom} Custom
                  &lt;/CardDescription&gt;
                &lt;/div&gt;
              )}
            &lt;/div&gt;
            &lt;div className=&quot;flex gap-2&quot;&gt;
              &lt;Button variant=&quot;outline&quot; onClick={handleRefresh} title=&quot;Refresh bundles&quot;&gt;
                &lt;RefreshCw className=&quot;h-4 w-4&quot; /&gt;
              &lt;/Button&gt;
              {!selectedBundle &amp;&amp; (
                &lt;Button onClick={handleUpdateMasterBundle} disabled={updatingBundles.has(&#39;master&#39;)}&gt;
                  {updatingBundles.has(&#39;master&#39;) ? (
                    &lt;RefreshCw className=&quot;h-4 w-4 mr-2 animate-spin&quot; /&gt;
                  ) : (
                    &lt;Plus className=&quot;h-4 w-4 mr-2&quot; /&gt;
                  )}
                  {masterBundle ? &#39;Update Master Bundle&#39; : &#39;Create Master Bundle&#39;}
                &lt;/Button&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/CardHeader&gt;
        &lt;CardContent&gt;
          {error &amp;&amp; (
            &lt;Alert variant=&quot;destructive&quot; className=&quot;mb-4&quot;&gt;
              &lt;AlertCircle className=&quot;h-4 w-4&quot; /&gt;
              &lt;AlertDescription className=&quot;whitespace-pre-line&quot;&gt;{error}&lt;/AlertDescription&gt;
            &lt;/Alert&gt;
          )}

          {selectedBundle &amp;&amp; selectedBundleObj ? (
            &lt;BundleView
              bundle={selectedBundleObj}
              onClose={handleBackToBundles}
            /&gt;
          ) : (
            &lt;&gt;
              {/* Filters */}
              &lt;div className=&quot;flex gap-4 mb-4&quot;&gt;
                &lt;Input
                  placeholder=&quot;Filter bundles...&quot;
                  value={filter}
                  onChange={(e) =&gt; setFilter(e.target.value)}
                  className=&quot;max-w-sm&quot;
                /&gt;
                &lt;Select value={typeFilter} onValueChange={(value) =&gt; setTypeFilter(value as BundleType | &#39;all&#39;)}&gt;
                  &lt;SelectTrigger className=&quot;w-[180px]&quot;&gt;
                    &lt;SelectValue placeholder=&quot;Filter by type&quot; /&gt;
                  &lt;/SelectTrigger&gt;
                  &lt;SelectContent&gt;
                    &lt;SelectItem value=&quot;all&quot;&gt;All Types ({bundleStats.total})&lt;/SelectItem&gt;
                    &lt;SelectItem value=&quot;master&quot;&gt;
                      &lt;div className=&quot;flex items-center&quot;&gt;
                        &lt;Crown className=&quot;h-4 w-4 mr-2 text-blue-600&quot; /&gt;
                        Master ({bundleStats.master})
                      &lt;/div&gt;
                    &lt;/SelectItem&gt;
                    &lt;SelectItem value=&quot;tag-derived&quot;&gt;
                      &lt;div className=&quot;flex items-center&quot;&gt;
                        &lt;Tag className=&quot;h-4 w-4 mr-2 text-muted-foreground&quot; /&gt;
                        Tag-derived ({bundleStats.tagDerived})
                      &lt;/div&gt;
                    &lt;/SelectItem&gt;
                    &lt;SelectItem value=&quot;custom&quot;&gt;
                      &lt;div className=&quot;flex items-center&quot;&gt;
                        &lt;Palette className=&quot;h-4 w-4 mr-2 text-gray-600&quot; /&gt;
                        Custom ({bundleStats.custom})
                      &lt;/div&gt;
                    &lt;/SelectItem&gt;
                  &lt;/SelectContent&gt;
                &lt;/Select&gt;
              &lt;/div&gt;

              &lt;ScrollArea className=&quot;h-[500px]&quot;&gt;
                &lt;Table&gt;
                  &lt;TableHeader&gt;
                    &lt;TableRow&gt;
                      &lt;TableHead className=&quot;w-[250px]&quot;&gt;
                        &lt;Button
                          variant=&quot;ghost&quot;
                          onClick={() =&gt; handleSort(&#39;name&#39;)}
                          className=&quot;flex items-center&quot;
                        &gt;
                          Bundle Name
                          {sortField === &#39;name&#39; &amp;&amp; (
                            &lt;ArrowUpDown className=&quot;ml-2 h-4 w-4&quot; /&gt;
                          )}
                        &lt;/Button&gt;
                      &lt;/TableHead&gt;
                      &lt;TableHead&gt;Type&lt;/TableHead&gt;
                      &lt;TableHead&gt;
                        &lt;Button
                          variant=&quot;ghost&quot;
                          onClick={() =&gt; handleSort(&#39;timestamp&#39;)}
                          className=&quot;flex items-center&quot;
                        &gt;
                          Created
                          {sortField === &#39;timestamp&#39; &amp;&amp; (
                            &lt;ArrowUpDown className=&quot;ml-2 h-4 w-4&quot; /&gt;
                          )}
                        &lt;/Button&gt;
                      &lt;/TableHead&gt;
                      &lt;TableHead&gt;
                        &lt;Button
                          variant=&quot;ghost&quot;
                          onClick={() =&gt; handleSort(&#39;fileCount&#39;)}
                          className=&quot;flex items-center&quot;
                        &gt;
                          Files
                          {sortField === &#39;fileCount&#39; &amp;&amp; (
                            &lt;ArrowUpDown className=&quot;ml-2 h-4 w-4&quot; /&gt;
                          )}
                        &lt;/Button&gt;
                      &lt;/TableHead&gt;
                      &lt;TableHead&gt;Status&lt;/TableHead&gt;
                      &lt;TableHead&gt;Actions&lt;/TableHead&gt;
                    &lt;/TableRow&gt;
                  &lt;/TableHeader&gt;
                  &lt;TableBody&gt;
                    {sortedBundles.length === 0 ? (
                      &lt;TableRow&gt;
                        &lt;TableCell colSpan={6} className=&quot;text-center text-muted-foreground py-8&quot;&gt;
                          {typeFilter === &#39;all&#39; ? &#39;No bundles found&#39; : `No ${typeFilter} bundles found`}
                        &lt;/TableCell&gt;
                      &lt;/TableRow&gt;
                    ) : (
                      sortedBundles.map((bundle) =&gt; {
                        const typeDisplay = getBundleTypeDisplay(bundle);
                        const isUpdating = updatingBundles.has(bundle.name);

                        return (
                          &lt;TableRow
                            key={bundle.name}
                            className=&quot;cursor-pointer hover:bg-muted/50&quot;
                            onClick={() =&gt; handleBundleSelect(bundle.name)}
                          &gt;
                            &lt;TableCell className=&quot;font-medium&quot;&gt;
                              &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                                {typeDisplay.icon}
                                &lt;div&gt;
                                  &lt;div className=&quot;font-medium&quot;&gt;{bundle.name}&lt;/div&gt;
                                  {bundle.description &amp;&amp; (
                                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                                      {bundle.description}
                                    &lt;/div&gt;
                                  )}
                                &lt;/div&gt;
                              &lt;/div&gt;
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              {typeDisplay.badge}
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              &lt;div className=&quot;flex items-center&quot;&gt;
                                &lt;Clock className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
                                &lt;div className=&quot;text-sm&quot;&gt;
                                  {formatTimestamp(bundle.timestamp)}
                                &lt;/div&gt;
                              &lt;/div&gt;
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              &lt;div className=&quot;flex items-center&quot;&gt;
                                &lt;FileText className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
                                &lt;span&gt;{bundle.fileCount}&lt;/span&gt;
                              &lt;/div&gt;
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              &lt;BundleAnalysisBadge bundle={bundle} /&gt;
                            &lt;/TableCell&gt;
                            &lt;TableCell&gt;
                              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                                {/* Quick actions */}
                                &lt;Button
                                  variant=&quot;outline&quot;
                                  size=&quot;sm&quot;
                                  onClick={(e) =&gt; {
                                    e.stopPropagation();
                                    copyBundleContent(bundle.name);
                                  }}
                                  title=&quot;Copy to clipboard&quot;
                                &gt;
                                  &lt;Copy className=&quot;h-4 w-4&quot; /&gt;
                                &lt;/Button&gt;

                                {/* More actions dropdown */}
                                &lt;DropdownMenu&gt;
                                  &lt;DropdownMenuTrigger asChild&gt;
                                    &lt;Button
                                      variant=&quot;outline&quot;
                                      size=&quot;sm&quot;
                                      onClick={(e) =&gt; e.stopPropagation()}
                                    &gt;
                                      &lt;MoreVertical className=&quot;h-4 w-4&quot; /&gt;
                                    &lt;/Button&gt;
                                  &lt;/DropdownMenuTrigger&gt;
                                  &lt;DropdownMenuContent align=&quot;end&quot;&gt;
                                    {/* FIXED: All bundle types can now show update option */}
                                    &lt;DropdownMenuItem
                                      onClick={(e) =&gt; {
                                        e.stopPropagation();
                                        handleUpdateBundle(bundle);
                                      }}
                                      disabled={isUpdating}
                                    &gt;
                                      {isUpdating ? (
                                        &lt;RefreshCw className=&quot;h-4 w-4 mr-2 animate-spin&quot; /&gt;
                                      ) : (
                                        &lt;RotateCcw className=&quot;h-4 w-4 mr-2&quot; /&gt;
                                      )}
                                      Update Bundle
                                    &lt;/DropdownMenuItem&gt;
                                    &lt;DropdownMenuSeparator /&gt;
                                    &lt;DropdownMenuItem
                                      onClick={(e) =&gt; {
                                        e.stopPropagation();
                                        copyBundleContent(bundle.name);
                                      }}
                                    &gt;
                                      &lt;Copy className=&quot;h-4 w-4 mr-2&quot; /&gt;
                                      Copy Content
                                    &lt;/DropdownMenuItem&gt;
                                    &lt;DropdownMenuItem
                                      onClick={(e) =&gt; {
                                        e.stopPropagation();
                                        downloadBundle(bundle.name);
                                      }}
                                    &gt;
                                      &lt;Download className=&quot;h-4 w-4 mr-2&quot; /&gt;
                                      Download
                                    &lt;/DropdownMenuItem&gt;
                                  &lt;/DropdownMenuContent&gt;
                                &lt;/DropdownMenu&gt;
                              &lt;/div&gt;
                            &lt;/TableCell&gt;
                          &lt;/TableRow&gt;
                        );
                      })
                    )}
                  &lt;/TableBody&gt;
                &lt;/Table&gt;
              &lt;/ScrollArea&gt;
            &lt;/&gt;
          )}
        &lt;/CardContent&gt;
      &lt;/Card&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/components/Dashboard.tsx</source>
      <tags>ui-components,business-logic</tags>
      <metadata>
        <size>16032</size>
        <lastModified>2025-05-27T00:42:48.858Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>// src/components/Dashboard.tsx - Updated to remove redundant MasterBundleButton
import { useEffect } from &#39;react&#39;;
import { useDirectory } from &#39;@/contexts/DirectoryContext&#39;;
import { useFiles } from &#39;@/contexts/FileContext&#39;;
import { useBundles } from &#39;@/contexts/BundleContext&#39;;
import { useTags } from &#39;@/contexts/TagContext&#39;;
import { useProjectConfig } from &#39;@/contexts/ProjectConfigContext&#39;;

import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from &quot;@/components/ui/card&quot;;
import { Progress } from &quot;@/components/ui/progress&quot;;
import { Button } from &quot;@/components/ui/button&quot;;
import { Badge } from &quot;@/components/ui/badge&quot;;
import { ScrollArea } from &quot;@/components/ui/scroll-area&quot;;
import { Alert, AlertDescription } from &quot;@/components/ui/alert&quot;;

import {
  BarChart,
  FileText,
  FolderOpen,
  Tag,
  Clock,
  FileCheck,
  FileEdit,
  RefreshCw,
  AlertTriangle,
  Archive
} from &quot;lucide-react&quot;;

export function Dashboard() {
  const { currentDirectory, isWatching, recentChanges } = useDirectory();
  const { watchedFiles, stagedFiles, refreshFiles } = useFiles();
  const { bundles, masterBundle, loadBundles } = useBundles();
  const { tags, getFilesWithTag } = useTags();
  const { isProjectInitialized } = useProjectConfig();

  // Calculate metrics for the dashboard
  const metrics = {
    totalFiles: watchedFiles.length,
    stagedFiles: stagedFiles.length,
    bundleCount: bundles.length,
    tagCount: Object.keys(tags).length,
    hasActiveMasterBundle: Boolean(masterBundle),
    changedFilesCount: watchedFiles.filter(file =&gt; file.isChanged).length,
    filesByExtension: watchedFiles.reduce((acc, file) =&gt; {
      const ext = file.path.split(&#39;.&#39;).pop()?.toLowerCase() || &#39;unknown&#39;;
      acc[ext] = (acc[ext] || 0) + 1;
      return acc;
    }, {} as Record&lt;string, number&gt;),
    mostUsedTags: Object.entries(tags)
      .map(([name]) =&gt; ({
        name,
        count: getFilesWithTag(name).length
      }))
      .sort((a, b) =&gt; b.count - a.count)
      .slice(0, 5)
  };

  // Format timestamp for display
  const formatTimestamp = (date: Date) =&gt; {
    return new Intl.DateTimeFormat(&#39;en-US&#39;, {
      month: &#39;short&#39;,
      day: &#39;2-digit&#39;,
      hour: &#39;2-digit&#39;,
      minute: &#39;2-digit&#39;,
    }).format(date);
  };

  useEffect(() =&gt; {
    if (isWatching) {
      refreshFiles();
      loadBundles();
    }
  }, [isWatching, refreshFiles, loadBundles]);

  // If project is not initialized, show setup guide
  if (!isProjectInitialized) {
    return (
      &lt;div className=&quot;p-4 space-y-6&quot;&gt;
        &lt;Card&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle&gt;Project Setup Required&lt;/CardTitle&gt;
            &lt;CardDescription&gt;
              Initialize your project to start tracking files and creating bundles
            &lt;/CardDescription&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent className=&quot;space-y-4&quot;&gt;
            &lt;Alert&gt;
              &lt;AlertTriangle className=&quot;h-4 w-4&quot; /&gt;
              &lt;AlertDescription&gt;
                Please select a directory and initialize it to use the full functionality.
              &lt;/AlertDescription&gt;
            &lt;/Alert&gt;
            &lt;div className=&quot;flex justify-center&quot;&gt;
              &lt;Button onClick={() =&gt; window.location.reload()}&gt;
                &lt;FolderOpen className=&quot;mr-2 h-4 w-4&quot; /&gt;
                Select Directory
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    );
  }

  // If no directory is being watched, show welcome screen
  if (!isWatching) {
    return (
      &lt;div className=&quot;p-4 space-y-6&quot;&gt;
        &lt;Card&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle&gt;Welcome to Cntx&lt;/CardTitle&gt;
            &lt;CardDescription&gt;
              Select a directory to start tracking files and creating bundles
            &lt;/CardDescription&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent className=&quot;flex justify-center py-12&quot;&gt;
            &lt;Button size=&quot;lg&quot; onClick={() =&gt; window.location.reload()}&gt;
              &lt;FolderOpen className=&quot;mr-2 h-4 w-4&quot; /&gt;
              Select Directory
            &lt;/Button&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;p-4 space-y-6&quot;&gt;
      {/* Project Overview Section */}
      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4&quot;&gt;
        &lt;Card&gt;
          &lt;CardHeader className=&quot;pb-2&quot;&gt;
            &lt;CardTitle className=&quot;text-sm font-medium flex items-center&quot;&gt;
              &lt;FolderOpen className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
              Current Directory
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;div className=&quot;text-2xl font-bold truncate&quot; title={currentDirectory || &#39;&#39;}&gt;
              {currentDirectory || &#39;None&#39;}
            &lt;/div&gt;
            &lt;p className=&quot;text-xs text-muted-foreground mt-1&quot;&gt;
              {metrics.totalFiles} files being tracked
            &lt;/p&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;

        &lt;Card&gt;
          &lt;CardHeader className=&quot;pb-2&quot;&gt;
            &lt;CardTitle className=&quot;text-sm font-medium flex items-center&quot;&gt;
              &lt;FileText className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
              Files
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;div className=&quot;flex items-baseline&quot;&gt;
              &lt;div className=&quot;text-2xl font-bold&quot;&gt;{metrics.totalFiles}&lt;/div&gt;
              {metrics.stagedFiles &gt; 0 &amp;&amp; (
                &lt;div className=&quot;ml-2 text-sm text-muted-foreground&quot;&gt;
                  ({metrics.stagedFiles} staged)
                &lt;/div&gt;
              )}
            &lt;/div&gt;
            {metrics.changedFilesCount &gt; 0 &amp;&amp; (
              &lt;div className=&quot;mt-2&quot;&gt;
                &lt;div className=&quot;flex justify-between text-xs mb-1&quot;&gt;
                  &lt;span&gt;Changed Files&lt;/span&gt;
                  &lt;span&gt;{metrics.changedFilesCount} of {metrics.totalFiles}&lt;/span&gt;
                &lt;/div&gt;
                &lt;Progress
                  value={(metrics.changedFilesCount / metrics.totalFiles) * 100}
                  className=&quot;h-1&quot;
                /&gt;
              &lt;/div&gt;
            )}
          &lt;/CardContent&gt;
        &lt;/Card&gt;

        &lt;Card&gt;
          &lt;CardHeader className=&quot;pb-2&quot;&gt;
            &lt;CardTitle className=&quot;text-sm font-medium flex items-center&quot;&gt;
              &lt;Archive className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
              Bundles
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;div className=&quot;text-2xl font-bold&quot;&gt;{metrics.bundleCount}&lt;/div&gt;
            &lt;div className=&quot;mt-2&quot;&gt;
              &lt;Badge variant={metrics.hasActiveMasterBundle ? &quot;default&quot; : &quot;outline&quot;}&gt;
                {metrics.hasActiveMasterBundle ? &quot;Master Bundle Active&quot; : &quot;No Master Bundle&quot;}
              &lt;/Badge&gt;
            &lt;/div&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;

        &lt;Card&gt;
          &lt;CardHeader className=&quot;pb-2&quot;&gt;
            &lt;CardTitle className=&quot;text-sm font-medium flex items-center&quot;&gt;
              &lt;Tag className=&quot;mr-2 h-4 w-4 text-muted-foreground&quot; /&gt;
              Tags
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;div className=&quot;text-2xl font-bold&quot;&gt;{metrics.tagCount}&lt;/div&gt;
            &lt;div className=&quot;mt-2 flex flex-wrap gap-1&quot;&gt;
              {metrics.mostUsedTags.slice(0, 3).map(tag =&gt; (
                &lt;Badge key={tag.name} variant=&quot;secondary&quot; className=&quot;text-xs&quot;&gt;
                  {tag.name}: {tag.count}
                &lt;/Badge&gt;
              ))}
            &lt;/div&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      &lt;/div&gt;

      {/* Main Dashboard Content */}
      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-4&quot;&gt;
        {/* Recent Changes */}
        &lt;Card className=&quot;md:col-span-1&quot;&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle className=&quot;text-lg flex items-center justify-between&quot;&gt;
              &lt;span className=&quot;flex items-center&quot;&gt;
                &lt;Clock className=&quot;mr-2 h-5 w-5&quot; /&gt;
                Recent Changes
              &lt;/span&gt;
              &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot; onClick={refreshFiles}&gt;
                &lt;RefreshCw className=&quot;h-4 w-4&quot; /&gt;
              &lt;/Button&gt;
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;ScrollArea className=&quot;h-[400px] pr-4&quot;&gt;
              {recentChanges.length === 0 ? (
                &lt;div className=&quot;text-center p-4 text-muted-foreground&quot;&gt;
                  No recent changes detected
                &lt;/div&gt;
              ) : (
                &lt;div className=&quot;space-y-2&quot;&gt;
                  {recentChanges.slice(0, 20).map((change, index) =&gt; (
                    &lt;div
                      key={index}
                      className=&quot;flex items-center justify-between py-2 border-b border-muted last:border-0&quot;
                    &gt;
                      &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                        {change.kind === &#39;create&#39; &amp;&amp; &lt;FileCheck className=&quot;h-4 w-4 text-green-500&quot; /&gt;}
                        {change.kind === &#39;modify&#39; &amp;&amp; &lt;FileEdit className=&quot;h-4 w-4 text-amber-500&quot; /&gt;}
                        {change.kind === &#39;remove&#39; &amp;&amp; &lt;AlertTriangle className=&quot;h-4 w-4 text-red-500&quot; /&gt;}
                        &lt;span className=&quot;text-sm truncate max-w-[160px]&quot; title={change.name}&gt;
                          {change.name.split(&#39;/&#39;).pop()}
                        &lt;/span&gt;
                      &lt;/div&gt;
                      &lt;span className=&quot;text-xs text-muted-foreground&quot;&gt;
                        {formatTimestamp(change.timestamp)}
                      &lt;/span&gt;
                    &lt;/div&gt;
                  ))}
                &lt;/div&gt;
              )}
            &lt;/ScrollArea&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;

        {/* Bundle Overview */}
        &lt;Card className=&quot;md:col-span-2&quot;&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle className=&quot;text-lg flex items-center justify-between&quot;&gt;
              &lt;span className=&quot;flex items-center&quot;&gt;
                &lt;Archive className=&quot;mr-2 h-5 w-5&quot; /&gt;
                Bundle Overview
              &lt;/span&gt;
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            {masterBundle ? (
              &lt;div className=&quot;space-y-6&quot;&gt;
                &lt;div className=&quot;flex flex-col space-y-1.5&quot;&gt;
                  &lt;div className=&quot;text-sm font-medium&quot;&gt;Master Bundle&lt;/div&gt;
                  &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                    Last updated: {masterBundle.timestamp.toLocaleString()}
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center space-x-2 mt-1&quot;&gt;
                    &lt;Badge&gt;{masterBundle.fileCount} files&lt;/Badge&gt;
                    {masterBundle.tagCount &amp;&amp; (
                      &lt;Badge variant=&quot;outline&quot;&gt;{masterBundle.tagCount} tagged&lt;/Badge&gt;
                    )}
                  &lt;/div&gt;
                &lt;/div&gt;

                &lt;div className=&quot;space-y-1.5&quot;&gt;
                  &lt;div className=&quot;text-sm&quot;&gt;Recent Bundles&lt;/div&gt;
                  &lt;ScrollArea className=&quot;h-[300px]&quot;&gt;
                    &lt;div className=&quot;space-y-2&quot;&gt;
                      {bundles.slice(0, 5).map(bundle =&gt; (
                        &lt;Card key={bundle.name} className=&quot;p-3&quot;&gt;
                          &lt;div className=&quot;flex justify-between items-center&quot;&gt;
                            &lt;div&gt;
                              &lt;div className=&quot;font-medium text-sm&quot;&gt;{bundle.name}&lt;/div&gt;
                              &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                                {bundle.timestamp.toLocaleDateString()} • {bundle.fileCount} files
                              &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;Badge variant={bundle.name.startsWith(&#39;master-&#39;) ? &quot;default&quot; : &quot;outline&quot;}&gt;
                              {bundle.name.startsWith(&#39;master-&#39;) ? &quot;Master&quot; : &quot;Regular&quot;}
                            &lt;/Badge&gt;
                          &lt;/div&gt;
                        &lt;/Card&gt;
                      ))}
                    &lt;/div&gt;
                  &lt;/ScrollArea&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ) : (
              &lt;div className=&quot;flex flex-col items-center justify-center py-12 space-y-4&quot;&gt;
                &lt;div className=&quot;text-center space-y-2&quot;&gt;
                  &lt;AlertTriangle className=&quot;h-10 w-10 mx-auto text-amber-500&quot; /&gt;
                  &lt;h3 className=&quot;text-lg font-medium&quot;&gt;No Master Bundle&lt;/h3&gt;
                  &lt;p className=&quot;text-sm text-muted-foreground max-w-md&quot;&gt;
                    Create a master bundle to track file changes and establish a snapshot of your project. Go to the Bundles tab to get started.
                  &lt;/p&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )}
          &lt;/CardContent&gt;
        &lt;/Card&gt;

        {/* File Types &amp; Tags Overview */}
        &lt;Card className=&quot;md:col-span-3&quot;&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle className=&quot;text-lg flex items-center&quot;&gt;
              &lt;BarChart className=&quot;mr-2 h-5 w-5&quot; /&gt;
              Project Composition
            &lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;
              {/* File Types */}
              &lt;div&gt;
                &lt;h3 className=&quot;text-sm font-medium mb-3&quot;&gt;File Types&lt;/h3&gt;
                &lt;div className=&quot;space-y-2&quot;&gt;
                  {Object.entries(metrics.filesByExtension)
                    .sort((a, b) =&gt; b[1] - a[1])
                    .slice(0, 7)
                    .map(([ext, count]) =&gt; (
                      &lt;div key={ext} className=&quot;flex items-center&quot;&gt;
                        &lt;div className=&quot;w-24 text-sm&quot;&gt;.{ext}&lt;/div&gt;
                        &lt;div className=&quot;flex-1&quot;&gt;
                          &lt;div className=&quot;flex items-center&quot;&gt;
                            &lt;div
                              className=&quot;bg-primary/80 h-2 rounded-full&quot;
                              style={{ width: `${(count / metrics.totalFiles) * 100}%` }}
                            /&gt;
                            &lt;span className=&quot;ml-2 text-sm&quot;&gt;{count}&lt;/span&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    ))}
                &lt;/div&gt;
              &lt;/div&gt;

              {/* Tags Distribution */}
              &lt;div&gt;
                &lt;h3 className=&quot;text-sm font-medium mb-3&quot;&gt;Tag Usage&lt;/h3&gt;
                {metrics.mostUsedTags.length &gt; 0 ? (
                  &lt;div className=&quot;space-y-2&quot;&gt;
                    {metrics.mostUsedTags.map(tag =&gt; (
                      &lt;div key={tag.name} className=&quot;flex items-center&quot;&gt;
                        &lt;div className=&quot;w-24 text-sm flex items-center&quot;&gt;
                          &lt;div
                            className=&quot;w-3 h-3 rounded-full mr-2&quot;
                            style={{ backgroundColor: tags[tag.name]?.color || &#39;#888&#39; }}
                          /&gt;
                          {tag.name}
                        &lt;/div&gt;
                        &lt;div className=&quot;flex-1&quot;&gt;
                          &lt;div className=&quot;flex items-center&quot;&gt;
                            &lt;div
                              className=&quot;h-2 rounded-full&quot;
                              style={{
                                width: `${(tag.count / metrics.totalFiles) * 100}%`,
                                backgroundColor: tags[tag.name]?.color || &#39;#888&#39;
                              }}
                            /&gt;
                            &lt;span className=&quot;ml-2 text-sm&quot;&gt;{tag.count}&lt;/span&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    ))}
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;text-center py-6 text-muted-foreground&quot;&gt;
                    &lt;Tag className=&quot;h-8 w-8 mx-auto mb-2&quot; /&gt;
                    &lt;p&gt;No tags used yet&lt;/p&gt;
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/CardContent&gt;
          &lt;CardFooter className=&quot;flex justify-between&quot;&gt;
            &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
              Total: {metrics.totalFiles} files tracked
            &lt;/div&gt;
          &lt;/CardFooter&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/lib/utils.ts</source>
      <tags>business-logic</tags>
      <metadata>
        <size>166</size>
        <lastModified>2025-05-22T00:43:04.232Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>import { clsx, type ClassValue } from &#39;clsx&#39;
import { twMerge } from &#39;tailwind-merge&#39;

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</content>
    </document>

    <document>
      <source>src/App.tsx</source>
      <tags>app-core,ui-components</tags>
      <metadata>
        <size>624</size>
        <lastModified>2025-05-23T18:26:41.778Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>// src/App.tsx
import { QueryClient, QueryClientProvider } from &#39;@tanstack/react-query&#39;;
import { CntxProvider } from &#39;@/contexts/CntxProvider&#39;;
import { ApplicationContainer } from &#39;./components/ApplicationContainer&#39;;
import { ThemeProvider } from &quot;@/components/theme/theme-provider&quot;

const queryClient = new QueryClient();

export default function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;CntxProvider&gt;
        &lt;ThemeProvider defaultTheme=&quot;dark&quot; storageKey=&quot;vite-ui-theme&quot;&gt;
          &lt;ApplicationContainer /&gt;
        &lt;/ThemeProvider&gt;
      &lt;/CntxProvider&gt;
    &lt;/QueryClientProvider&gt;
  );
}
</content>
    </document>

    <document>
      <source>src/index.css</source>
      <tags>theming-styles</tags>
      <metadata>
        <size>1795</size>
        <lastModified>2025-05-22T00:43:04.232Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>@tailwind base;
@tailwind components;
@tailwind utilities;

/* ... */

@layer base {
  :root {
    --background: 0 0% 100%;

    --foreground: 240 10% 3.9%;

    --card: 0 0% 100%;

    --card-foreground: 240 10% 3.9%;

    --popover: 0 0% 100%;

    --popover-foreground: 240 10% 3.9%;

    --primary: 240 5.9% 10%;

    --primary-foreground: 0 0% 98%;

    --secondary: 240 4.8% 95.9%;

    --secondary-foreground: 240 5.9% 10%;

    --muted: 240 4.8% 95.9%;

    --muted-foreground: 240 3.8% 46.1%;

    --accent: 240 4.8% 95.9%;

    --accent-foreground: 240 5.9% 10%;

    --destructive: 0 84.2% 60.2%;

    --destructive-foreground: 0 0% 98%;

    --border: 240 5.9% 90%;

    --input: 240 5.9% 90%;

    --ring: 240 10% 3.9%;

    --chart-1: 12 76% 61%;

    --chart-2: 173 58% 39%;

    --chart-3: 197 37% 24%;

    --chart-4: 43 74% 66%;

    --chart-5: 27 87% 67%;

    --radius: 0.4rem;
  }
  .dark {
    --background: 0, 0%, 5%;

    --foreground: 0 0% 80%;

    --card: 0, 0%, 5%;

    --card-foreground: 0 0% 80%;

    --popover: 240 10% 3.9%;

    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%;

    --primary-foreground: 240 5.9% 10%;

    --secondary: 240 3.7% 15.9%;

    --secondary-foreground: 0 0% 98%;

    --muted: 240 3.7% 15.9%;

    --muted-foreground: 240 5% 64.9%;

    --accent: 240 3.7% 15.9%;

    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;

    --destructive-foreground: 0 0% 98%;

    --border: 240 3.7% 15.9%;

    --input: 240 3.7% 15.9%;

    --ring: 240 4.9% 83.9%;

    --chart-1: 220 70% 50%;

    --chart-2: 160 60% 45%;

    --chart-3: 30 80% 55%;

    --chart-4: 280 65% 60%;

    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</content>
    </document>

    <document>
      <source>src/vite-env.d.ts</source>
      <tags>types-definitions,configuration</tags>
      <metadata>
        <size>38</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>ts</extension>
        <directory>src</directory>
      </metadata>
      <content>/// &lt;reference types=&quot;vite/client&quot; /&gt;
</content>
    </document>

    <document>
      <source>src/main.tsx</source>
      <tags>app-core</tags>
      <metadata>
        <size>246</size>
        <lastModified>2025-05-22T00:43:04.233Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>// src/main.tsx
import { StrictMode } from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import &#39;./index.css&#39;
import App from &#39;./App.tsx&#39;

createRoot(document.getElementById(&#39;root&#39;)!).render(
  &lt;StrictMode&gt;
    &lt;App /&gt;
  &lt;/StrictMode&gt;,
)
</content>
    </document>

    <document>
      <source>tsconfig.node.json</source>
      <tags>configuration</tags>
      <metadata>
        <size>480</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES2022&quot;,
    &quot;lib&quot;: [&quot;ES2023&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
  },
  &quot;include&quot;: [&quot;vite.config.ts&quot;]
}
</content>
    </document>

    <document>
      <source>tailwind.config.js</source>
      <tags>configuration,theming-styles</tags>
      <metadata>
        <size>1544</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>js</extension>
        <directory>Root</directory>
      </metadata>
      <content>/** @type {import(&#39;tailwindcss&#39;).Config} */
module.exports = {
    darkMode: [&quot;class&quot;],
    content: [&quot;./index.html&quot;, &quot;./src/**/*.{ts,tsx,js,jsx}&quot;],
  theme: {
  	extend: {
  		borderRadius: {
  			lg: &#39;var(--radius)&#39;,
  			md: &#39;calc(var(--radius) - 2px)&#39;,
  			sm: &#39;calc(var(--radius) - 4px)&#39;
  		},
  		colors: {
  			background: &#39;hsl(var(--background))&#39;,
  			foreground: &#39;hsl(var(--foreground))&#39;,
  			card: {
  				DEFAULT: &#39;hsl(var(--card))&#39;,
  				foreground: &#39;hsl(var(--card-foreground))&#39;
  			},
  			popover: {
  				DEFAULT: &#39;hsl(var(--popover))&#39;,
  				foreground: &#39;hsl(var(--popover-foreground))&#39;
  			},
  			primary: {
  				DEFAULT: &#39;hsl(var(--primary))&#39;,
  				foreground: &#39;hsl(var(--primary-foreground))&#39;
  			},
  			secondary: {
  				DEFAULT: &#39;hsl(var(--secondary))&#39;,
  				foreground: &#39;hsl(var(--secondary-foreground))&#39;
  			},
  			muted: {
  				DEFAULT: &#39;hsl(var(--muted))&#39;,
  				foreground: &#39;hsl(var(--muted-foreground))&#39;
  			},
  			accent: {
  				DEFAULT: &#39;hsl(var(--accent))&#39;,
  				foreground: &#39;hsl(var(--accent-foreground))&#39;
  			},
  			destructive: {
  				DEFAULT: &#39;hsl(var(--destructive))&#39;,
  				foreground: &#39;hsl(var(--destructive-foreground))&#39;
  			},
  			border: &#39;hsl(var(--border))&#39;,
  			input: &#39;hsl(var(--input))&#39;,
  			ring: &#39;hsl(var(--ring))&#39;,
  			chart: {
  				&#39;1&#39;: &#39;hsl(var(--chart-1))&#39;,
  				&#39;2&#39;: &#39;hsl(var(--chart-2))&#39;,
  				&#39;3&#39;: &#39;hsl(var(--chart-3))&#39;,
  				&#39;4&#39;: &#39;hsl(var(--chart-4))&#39;,
  				&#39;5&#39;: &#39;hsl(var(--chart-5))&#39;
  			}
  		}
  	}
  },
  plugins: [require(&quot;tailwindcss-animate&quot;)],
}
</content>
    </document>

    <document>
      <source>tsconfig.app.tsbuildinfo</source>
      <tags>configuration</tags>
      <metadata>
        <size>1834</size>
        <lastModified>2025-05-22T02:29:37.045Z</lastModified>
        <extension>tsbuildinfo</extension>
        <directory>Root</directory>
      </metadata>
      <content>{&quot;root&quot;:[&quot;./src/app.tsx&quot;,&quot;./src/main.tsx&quot;,&quot;./src/vite-env.d.ts&quot;,&quot;./src/components/applicationcontainer.tsx&quot;,&quot;./src/components/bundleanalysisbadge.tsx&quot;,&quot;./src/components/bundledetailsview.tsx&quot;,&quot;./src/components/bundlemainviewer.tsx&quot;,&quot;./src/components/bundleview.tsx&quot;,&quot;./src/components/configpanel.tsx&quot;,&quot;./src/components/consolelogs.tsx&quot;,&quot;./src/components/dashboard.tsx&quot;,&quot;./src/components/directorypanel.tsx&quot;,&quot;./src/components/directorytree.tsx&quot;,&quot;./src/components/filetagsdisplay.tsx&quot;,&quot;./src/components/initializationmodal.tsx&quot;,&quot;./src/components/maincontainer.tsx&quot;,&quot;./src/components/masterbundlebutton.tsx&quot;,&quot;./src/components/statewatcher.tsx&quot;,&quot;./src/components/tagsmainviewer.tsx&quot;,&quot;./src/components/theme/mode-toggle.tsx&quot;,&quot;./src/components/theme/theme-provider.tsx&quot;,&quot;./src/components/ui/alert-dialog.tsx&quot;,&quot;./src/components/ui/alert.tsx&quot;,&quot;./src/components/ui/avatar.tsx&quot;,&quot;./src/components/ui/badge.tsx&quot;,&quot;./src/components/ui/button.tsx&quot;,&quot;./src/components/ui/card.tsx&quot;,&quot;./src/components/ui/checkbox.tsx&quot;,&quot;./src/components/ui/dialog.tsx&quot;,&quot;./src/components/ui/dropdown-menu.tsx&quot;,&quot;./src/components/ui/input.tsx&quot;,&quot;./src/components/ui/popover.tsx&quot;,&quot;./src/components/ui/progress.tsx&quot;,&quot;./src/components/ui/scroll-area.tsx&quot;,&quot;./src/components/ui/select.tsx&quot;,&quot;./src/components/ui/table.tsx&quot;,&quot;./src/components/ui/tabs.tsx&quot;,&quot;./src/components/ui/tooltip.tsx&quot;,&quot;./src/constants/index.ts&quot;,&quot;./src/contexts/bundlecontext.tsx&quot;,&quot;./src/contexts/cntxprovider.tsx&quot;,&quot;./src/contexts/directorycontext.tsx&quot;,&quot;./src/contexts/filecontext.tsx&quot;,&quot;./src/contexts/projectconfigcontext.tsx&quot;,&quot;./src/contexts/tagcontext.tsx&quot;,&quot;./src/contexts/types.ts&quot;,&quot;./src/lib/utils.ts&quot;,&quot;./src/types/types.ts&quot;,&quot;./src/utils/bundle-utils.ts&quot;,&quot;./src/utils/directory-tree.ts&quot;,&quot;./src/utils/file-state.ts&quot;,&quot;./src/utils/file-utils.ts&quot;,&quot;./src/utils/project-utils.ts&quot;],&quot;errors&quot;:true,&quot;version&quot;:&quot;5.6.3&quot;}</content>
    </document>

    <document>
      <source>tsconfig.json</source>
      <tags>configuration</tags>
      <metadata>
        <size>213</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;files&quot;: [],
  &quot;references&quot;: [
    { &quot;path&quot;: &quot;./tsconfig.app.json&quot; },
    { &quot;path&quot;: &quot;./tsconfig.node.json&quot; }
  ],
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./src/*&quot;]
    }
  }
}
</content>
    </document>

    <document>
      <source>vite.config.ts</source>
      <tags>configuration</tags>
      <metadata>
        <size>240</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>ts</extension>
        <directory>Root</directory>
      </metadata>
      <content>import path from &#39;path&#39;
import react from &#39;@vitejs/plugin-react&#39;
import { defineConfig } from &#39;vite&#39;

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),
    },
  },
})
</content>
    </document>

    <document>
      <source>.gitignore</source>
      <tags>configuration</tags>
      <metadata>
        <size>1883</size>
        <lastModified>2025-05-26T20:53:40.040Z</lastModified>
        <extension>gitignore</extension>
        <directory>Root</directory>
      </metadata>
      <content># Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Build outputs
dist/
dist-ssr/
build/
*.local

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output/

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of &#39;npm pack&#39;
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env.test

# parcel-builder cache (https://parceljs.org/)
.cache/
.parcel-cache/

# Next.js build output
.next/

# Nuxt.js build / generate output
.nuxt/

# Vite build cache
.vite/

# Rollup cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# JSPM packages directory
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# microbundle cache
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of &#39;npm pack&#39;
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# parcel-builder cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt

# Gatsby files
.cache/
public

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Project specific
PROMPTS.md
*.local

# Test files
test-project/
example-*/
dsdfsdf
</content>
    </document>

    <document>
      <source>README.md</source>
      <tags>documentation</tags>
      <metadata>
        <size>6299</size>
        <lastModified>2025-05-26T20:52:15.437Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># cntx-ui

&gt; File bundling and tagging tool for AI development workflows

cntx helps developers organize, tag, and bundle their codebase files for AI tools like ChatGPT, Claude, and Cursor. Create structured bundles with semantic tags to provide better context to AI systems.

## ✨ Features

- 📁 **Direct File System Access** - Work with your files without uploads
- 🏷️ **Smart Tagging System** - Organize files with semantic tags
- 📦 **Bundle Creation** - Package files for AI consumption with metadata
- 🔍 **Bundle Analysis** - Track file changes and staleness over time
- 🎯 **Master Bundles** - Create snapshots to track project evolution
- 🤝 **Cursor Integration** - Import and sync with existing Cursor AI rules
- 🎨 **Modern Interface** - Clean, responsive web UI
- ⚡ **Real-time Updates** - Watch for file changes automatically
- 👥 **Team AI Context** - Share AI-friendly project context via git

## 🚀 Quick Start

```bash
npx cntx-ui
```

That&#39;s it! Cntx will start a local server and open in your browser.

## 📋 Requirements

- **Node.js 16+**
- **Chromium-based browser** (Chrome, Edge, Opera, Brave)
  - Firefox and Safari don&#39;t support File System Access API yet

## 🎯 How to Use

### 1. Initialize Your Project

1. Run `npx cntx-ui`
2. Click &quot;Select Directory&quot; and choose your project folder
3. Initialize the project (creates a `.cntx` folder with configuration)
4. **Commit the `.cntx` directory** - this shares your project&#39;s AI context with your team!

### 2. Import Existing AI Rules (Optional)

If you&#39;re already using Cursor or other AI tools:

- Go to the **Config** tab → **Cursor Rules**
- Cntx will automatically detect existing `.cursorrules` files
- Import them to merge with cntx&#39;s semantic organization
- Creates unified AI context that works across tools

### 3. Organize with Tags

- Use the **Tags** tab to create semantic tags (e.g., &quot;core&quot;, &quot;ui-components&quot;, &quot;utilities&quot;)
- Tag files using the paint brush icon in the file tree
- Tags help categorize files by their role in your project

### 4. Create Bundles

- Select files in the directory tree (checkbox selection)
- Click &quot;Bundle&quot; to create a package for AI tools
- Bundles include file content, metadata, and your tag organization

### 5. Master Bundles

- Create a &quot;Master Bundle&quot; to snapshot your entire project
- Use this as a reference point to track which files have changed
- Perfect for providing complete project context to AI tools

### 6. Bundle Analysis

- View bundle freshness and file staleness
- See which files have changed since the last bundle
- Analyze tag distribution and file types

## 🤝 Team Collaboration

**Commit Your `.cntx` Directory!** Unlike typical build artifacts, your `.cntx` directory contains valuable team context:

- **Shared semantic organization** - Everyone uses the same file tags
- **AI context standards** - Unified rules for AI tools across the team
- **Project understanding** - New team members get instant context
- **Documentation as code** - Your project describes itself

### What Gets Committed

```
your-project/
├── .cntx/
│   ├── config/
│   │   ├── tags.ts                  # Team&#39;s tag taxonomy
│   │   ├── project-metadata.json    # Project info for AI
│   │   ├── ai-instructions.json     # Imported AI rules
│   │   └── pattern-ignore.ts        # Agreed ignore patterns
│   ├── bundles/
│   │   ├── master/                  # Reference snapshots
│   │   └── [other-bundles]/         # Useful reference bundles
│   └── state/
│       └── file.json                # Current file tags &amp; organization
└── your-code-files...
```

## 🔧 Browser Compatibility

Cntx uses the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API), which requires:

- ✅ Chrome 86+
- ✅ Edge 86+
- ✅ Opera 72+
- ✅ Other Chromium-based browsers
- ❌ Firefox (not yet supported)
- ❌ Safari (not yet supported)

## 🤖 AI Integration

Cntx bundles are designed for AI tools:

- **Structured XML format** with file metadata
- **Directory tree visualization**
- **Tag-based organization** for context
- **Change tracking** to highlight recent modifications
- **Ignore patterns** to exclude irrelevant files
- **Cursor Rules compatibility** for seamless AI workflow integration

### Universal AI Context

Cntx creates a **repository-first AI context system**:

- Import existing `.cursorrules` or `.cursor/` configurations
- Merge with cntx&#39;s semantic file organization
- Export unified context that works across AI tools
- Share via git for consistent team AI interactions

## 💡 Tips

- **Tag Strategy**: Use tags like &quot;core&quot;, &quot;ui-components&quot;, &quot;utilities&quot;, &quot;configuration&quot;
- **Ignore Patterns**: Configure patterns to exclude `node_modules`, build files, etc.
- **Master Bundles**: Create these periodically to track project evolution
- **File Selection**: Use Shift+click for range selection in the file tree
- **Team Context**: Commit `.cntx` so your team shares the same AI context
- **Cursor Integration**: Import existing Cursor rules to bridge your current AI workflow

## 🚀 Workflow Examples

### For Individual Developers

1. Initialize project with cntx
2. Import existing Cursor rules
3. Tag files semantically
4. Create bundles for AI consumption
5. Commit `.cntx` for future reference

### For Teams

1. One team member initializes with cntx
2. Establishes tagging conventions and AI rules
3. Commits `.cntx` directory
4. Team members clone and get instant AI context
5. Collaborative tagging through pull requests
6. Shared understanding of codebase organization

## 🐛 Troubleshooting

**&quot;No files found&quot;**

- Check your ignore patterns in the Config tab
- Ensure you&#39;re using a supported browser

**&quot;Failed to access directory&quot;**

- Grant file system permissions when prompted
- Try refreshing and re-selecting the directory

**Bundle creation fails**

- Ensure files are staged (selected with checkboxes)
- Check browser console for detailed errors

**Cursor rules not detected**

- Verify `.cursorrules` file exists in project root
- Check for `.cursor/` directory with configuration files

## 📄 License

MIT

## 🤝 Contributing

See [DEVELOPMENT.md](./DEVELOPMENT.md) for local development setup.

---

**Made for AI-powered development workflows** 🤖✨  
**Now with team collaboration and universal AI context** 👥🌐
</content>
    </document>

    <document>
      <source>tsconfig.node.tsbuildinfo</source>
      <tags>configuration</tags>
      <metadata>
        <size>47</size>
        <lastModified>2025-05-22T02:29:37.202Z</lastModified>
        <extension>tsbuildinfo</extension>
        <directory>Root</directory>
      </metadata>
      <content>{&quot;root&quot;:[&quot;./vite.config.ts&quot;],&quot;version&quot;:&quot;5.6.3&quot;}</content>
    </document>

    <document>
      <source>tsconfig.app.json</source>
      <tags>configuration</tags>
      <metadata>
        <size>635</size>
        <lastModified>2025-05-22T00:43:04.235Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES2020&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./src/*&quot;
      ]
    }
  },
  &quot;include&quot;: [&quot;src&quot;]
}
</content>
    </document>

    <document>
      <source>index.html</source>
      <tags>app-core</tags>
      <metadata>
        <size>427</size>
        <lastModified>2025-05-22T00:43:06.221Z</lastModified>
        <extension>html</extension>
        <directory>Root</directory>
      </metadata>
      <content>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link
      rel=&quot;icon&quot;
      type=&quot;image/svg+xml&quot;
      href=&quot;/cntx.svg&quot;
    /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, initial-scale=1.0&quot;
    /&gt;
    &lt;title&gt;cntx - from @nothingdao&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script
      type=&quot;module&quot;
      src=&quot;/src/main.tsx&quot;
    &gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content>
    </document>

    <document>
      <source>.npmignore</source>
      <tags>configuration,cli-package</tags>
      <metadata>
        <size>383</size>
        <lastModified>2025-05-22T02:29:16.100Z</lastModified>
        <extension>npmignore</extension>
        <directory>Root</directory>
      </metadata>
      <content># Source files
src/
public/
docs/

# Development files
.vscode/
.idea/
*.log
.env*
.DS_Store

# Build artifacts not needed in package
node_modules/
coverage/
.nyc_output/

# Development configs
vite.config.ts
tsconfig*.json
eslint.config.js
tailwind.config.js
postcss.config.js

# Git
.git/
.gitignore

# Only include built files and essentials
!dist/
!bin/
!README.md
!package.json
</content>
    </document>

    <document>
      <source>postcss.config.cjs</source>
      <tags>configuration,theming-styles</tags>
      <metadata>
        <size>82</size>
        <lastModified>2025-05-22T02:39:25.675Z</lastModified>
        <extension>cjs</extension>
        <directory>Root</directory>
      </metadata>
      <content>module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</content>
    </document>

    <document>
      <source>package.json</source>
      <tags>configuration,cli-package</tags>
      <metadata>
        <size>2444</size>
        <lastModified>2025-05-24T20:54:59.589Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;name&quot;: &quot;cntx-ui&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;version&quot;: &quot;1.0.9&quot;,
  &quot;description&quot;: &quot;File bundling and tagging tool for AI development&quot;,
  &quot;keywords&quot;: [
    &quot;ai&quot;,
    &quot;bundling&quot;,
    &quot;file-management&quot;,
    &quot;development-tools&quot;,
    &quot;codebase&quot;
  ],
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;git+https://github.com/nothingdao/cntx-ui.git&quot;
  },
  &quot;homepage&quot;: &quot;https://github.com/nothingdao/cntx-ui#readme&quot;,
  &quot;bugs&quot;: {
    &quot;url&quot;: &quot;https://github.com/nothingdao/cntx-ui/issues&quot;
  },
  &quot;author&quot;: &quot;whaleen&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;bin&quot;: {
    &quot;cntx-ui&quot;: &quot;./bin/cntx.cjs&quot;
  },
  &quot;files&quot;: [
    &quot;dist&quot;,
    &quot;bin&quot;,
    &quot;README.md&quot;
  ],
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;=16.0.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;build-with-types&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;prepare&quot;: &quot;npm run build&quot;,
    &quot;start&quot;: &quot;node bin/cntx.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@radix-ui/react-alert-dialog&quot;: &quot;^1.1.4&quot;,
    &quot;@radix-ui/react-avatar&quot;: &quot;^1.1.2&quot;,
    &quot;@radix-ui/react-checkbox&quot;: &quot;^1.1.3&quot;,
    &quot;@radix-ui/react-dialog&quot;: &quot;^1.1.4&quot;,
    &quot;@radix-ui/react-dropdown-menu&quot;: &quot;^2.1.4&quot;,
    &quot;@radix-ui/react-label&quot;: &quot;^2.1.7&quot;,
    &quot;@radix-ui/react-popover&quot;: &quot;^1.1.14&quot;,
    &quot;@radix-ui/react-progress&quot;: &quot;^1.1.7&quot;,
    &quot;@radix-ui/react-scroll-area&quot;: &quot;^1.2.2&quot;,
    &quot;@radix-ui/react-select&quot;: &quot;^2.1.4&quot;,
    &quot;@radix-ui/react-separator&quot;: &quot;^1.1.7&quot;,
    &quot;@radix-ui/react-slot&quot;: &quot;^1.1.1&quot;,
    &quot;@radix-ui/react-switch&quot;: &quot;^1.2.5&quot;,
    &quot;@radix-ui/react-tabs&quot;: &quot;^1.1.2&quot;,
    &quot;@radix-ui/react-tooltip&quot;: &quot;^1.1.6&quot;,
    &quot;@tanstack/react-query&quot;: &quot;^5.62.8&quot;,
    &quot;class-variance-authority&quot;: &quot;^0.7.1&quot;,
    &quot;clsx&quot;: &quot;^2.1.1&quot;,
    &quot;console-feed&quot;: &quot;^3.6.0&quot;,
    &quot;dotenv&quot;: &quot;^16.4.7&quot;,
    &quot;express&quot;: &quot;^4.18.2&quot;,
    &quot;lucide-react&quot;: &quot;^0.469.0&quot;,
    &quot;open&quot;: &quot;^8.4.2&quot;,
    &quot;react&quot;: &quot;^18.3.1&quot;,
    &quot;react-dom&quot;: &quot;^18.3.1&quot;,
    &quot;simple-git&quot;: &quot;^3.27.0&quot;,
    &quot;tailwind-merge&quot;: &quot;^2.5.5&quot;,
    &quot;tailwindcss-animate&quot;: &quot;^1.0.7&quot;,
    &quot;zustand&quot;: &quot;^5.0.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.17.0&quot;,
    &quot;@types/react&quot;: &quot;^18.3.17&quot;,
    &quot;@types/react-dom&quot;: &quot;^18.3.5&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.3.4&quot;,
    &quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
    &quot;eslint&quot;: &quot;^9.17.0&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^5.0.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.16&quot;,
    &quot;globals&quot;: &quot;^15.13.0&quot;,
    &quot;postcss&quot;: &quot;^8.4.49&quot;,
    &quot;tailwindcss&quot;: &quot;^3.4.17&quot;,
    &quot;typescript&quot;: &quot;~5.6.2&quot;,
    &quot;typescript-eslint&quot;: &quot;^8.18.1&quot;,
    &quot;vite&quot;: &quot;5.4.2&quot;
  }
}
</content>
    </document>

    <document>
      <source>eslint.config.js</source>
      <tags>configuration</tags>
      <metadata>
        <size>734</size>
        <lastModified>2025-05-22T00:43:04.221Z</lastModified>
        <extension>js</extension>
        <directory>Root</directory>
      </metadata>
      <content>import js from &#39;@eslint/js&#39;
import globals from &#39;globals&#39;
import reactHooks from &#39;eslint-plugin-react-hooks&#39;
import reactRefresh from &#39;eslint-plugin-react-refresh&#39;
import tseslint from &#39;typescript-eslint&#39;

export default tseslint.config(
  { ignores: [&#39;dist&#39;] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: [&#39;**/*.{ts,tsx}&#39;],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      &#39;react-hooks&#39;: reactHooks,
      &#39;react-refresh&#39;: reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      &#39;react-refresh/only-export-components&#39;: [
        &#39;warn&#39;,
        { allowConstantExport: true },
      ],
    },
  },
)
</content>
    </document>

    <document>
      <source>components.json</source>
      <tags>configuration,ui-primitives</tags>
      <metadata>
        <size>440</size>
        <lastModified>2025-05-22T00:43:04.221Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;$schema&quot;: &quot;https://ui.shadcn.com/schema.json&quot;,
  &quot;style&quot;: &quot;new-york&quot;,
  &quot;rsc&quot;: false,
  &quot;tsx&quot;: true,
  &quot;tailwind&quot;: {
    &quot;config&quot;: &quot;tailwind.config.js&quot;,
    &quot;css&quot;: &quot;src/index.css&quot;,
    &quot;baseColor&quot;: &quot;zinc&quot;,
    &quot;cssVariables&quot;: true,
    &quot;prefix&quot;: &quot;&quot;
  },
  &quot;aliases&quot;: {
    &quot;components&quot;: &quot;@/components&quot;,
    &quot;utils&quot;: &quot;@/lib/utils&quot;,
    &quot;ui&quot;: &quot;@/components/ui&quot;,
    &quot;lib&quot;: &quot;@/lib&quot;,
    &quot;hooks&quot;: &quot;@/hooks&quot;
  },
  &quot;iconLibrary&quot;: &quot;lucide&quot;
}</content>
    </document>

    <document>
      <source>DEVELOPMENT.md</source>
      <tags>documentation</tags>
      <metadata>
        <size>7862</size>
        <lastModified>2025-05-24T20:29:51.011Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># Development Guide

This guide covers how to set up Cntx for local development, contribute to the project, and understand the codebase architecture.

## 🛠️ Local Development Setup

### Prerequisites

- Node.js 16+
- npm or yarn
- Git
- Chromium-based browser for testing

### Clone and Install

```bash
git clone https://github.com/nothingdao/cntx-ui.git
cd cntx-ui
npm install
```

### Development Commands

```bash
# Start development server with hot reload
npm run dev

# Build for production
npm run build

# Preview production build locally
npm run preview

# Run linting
npm run lint

# Test the NPX package locally
npm run start
```

### Development Workflow

1. **Start dev server**: `npm run dev`
2. **Open**: http://localhost:5173
3. **Make changes** - Hot reload is enabled
4. **Test with File System API** - Use Chrome/Edge for full functionality

## 🏗️ Project Architecture

### Tech Stack

- **React 18** with TypeScript
- **Vite** for build tooling
- **Tailwind CSS** for styling
- **shadcn/ui** for UI components
- **Lucide React** for icons
- **File System Access API** for file operations

### Folder Structure

```
src/
├── components/           # React components
│   ├── ui/              # shadcn/ui components
│   ├── theme/           # Theme system
│   ├── Dashboard.tsx    # Main dashboard
│   ├── DirectoryTree.tsx # File tree component
│   ├── BundleView.tsx   # Bundle analysis
│   └── ...
├── contexts/            # React Context providers
│   ├── DirectoryContext.tsx  # File system state
│   ├── BundleContext.tsx     # Bundle management
│   ├── TagContext.tsx        # Tag system
│   └── ...
├── utils/               # Business logic
│   ├── file-utils.ts    # File system operations
│   ├── bundle-utils.ts  # Bundle creation/analysis
│   ├── project-utils.ts # Project initialization
│   └── ...
├── types/               # TypeScript definitions
├── constants/           # App constants
└── lib/                 # Utility libraries
```

### Key Components

#### Contexts (State Management)

- **DirectoryContext**: File system access and watching
- **FileContext**: File tracking and staging
- **BundleContext**: Bundle creation and management
- **TagContext**: Tag system and file tagging
- **ProjectConfigContext**: Project configuration

#### Core Components

- **DirectoryTree**: File browser with selection
- **Dashboard**: Overview and project metrics
- **BundleMainViewer**: Bundle list and management
- **BundleView**: Detailed bundle analysis
- **TagsMainViewer**: Tag management interface

#### Utilities

- **file-utils.ts**: File system operations, ignore patterns
- **bundle-utils.ts**: Bundle creation, analysis, manifest handling
- **project-utils.ts**: Project initialization, master bundles
- **directory-tree.ts**: Tree structure generation

## 🔧 File System Access API

This project heavily uses the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API):

### Key APIs Used

```typescript
// Directory picker
const dirHandle = await window.showDirectoryPicker({ mode: &#39;readwrite&#39; })

// Read files
const fileHandle = await dirHandle.getFileHandle(&#39;file.txt&#39;)
const file = await fileHandle.getFile()
const content = await file.text()

// Write files
const writable = await fileHandle.createWritable()
await writable.write(content)
await writable.close()

// Iterate directory
for await (const entry of dirHandle.values()) {
  if (entry.kind === &#39;file&#39;) {
    // Handle file
  }
}
```

### Browser Support Limitations

- Only works in Chromium-based browsers
- Requires HTTPS in production (localhost is fine for dev)
- User must grant permissions for each directory

## 🏷️ Tag System

### Tag Configuration

Tags are defined in `.cntx/config/tags.ts`:

```typescript
export default {
  core: {
    color: &#39;#dc2626&#39;,
    description: &#39;Essential application files&#39;,
  },
  &#39;ui-components&#39;: {
    color: &#39;#0ea5e9&#39;,
    description: &#39;Reusable UI components&#39;,
  },
} as const
```

### Tag Assignment

File tags are stored in `.cntx/state/file.json`:

```json
{
  &quot;files&quot;: {
    &quot;src/App.tsx&quot;: {
      &quot;tags&quot;: [&quot;core&quot;],
      &quot;lastModified&quot;: &quot;2025-01-01T00:00:00.000Z&quot;,
      &quot;isStaged&quot;: false
    }
  }
}
```

## 📦 Bundle System

### Bundle Format

Bundles are XML files with structured content:

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bundle id=&quot;bundle-id&quot; created=&quot;timestamp&quot; fileCount=&quot;5&quot;&gt;
  &lt;metadata&gt;
    &lt;projectName&gt;my-project&lt;/projectName&gt;
    &lt;ignorePatterns&gt;
      &lt;pattern&gt;node_modules&lt;/pattern&gt;
    &lt;/ignorePatterns&gt;
  &lt;/metadata&gt;

  &lt;directoryTree&gt;&lt;!-- ASCII tree --&gt;&lt;/directoryTree&gt;

  &lt;documents&gt;
    &lt;document&gt;
      &lt;source&gt;src/App.tsx&lt;/source&gt;
      &lt;tags&gt;core&lt;/tags&gt;
      &lt;content&gt;&lt;!-- file content --&gt;&lt;/content&gt;
    &lt;/document&gt;
  &lt;/documents&gt;
&lt;/bundle&gt;
```

### Bundle Types

- **Regular Bundles**: Selected files for specific tasks
- **Master Bundles**: Complete project snapshots for tracking changes

## 🧪 Testing &amp; Debugging

### Local Testing

```bash
# Test the built package locally
npm run build
npm pack
npm install -g cntx-ui-1.0.0.tgz
cntx-ui

# Or test without installing
node bin/cntx.mjs
```

### Debugging Tips

- Use Chrome DevTools for File System API debugging
- Check console for file operation errors
- Monitor network tab for bundle size issues
- Use React DevTools for component state

### Common Issues

- **CORS errors**: Ensure running on localhost or HTTPS
- **File access denied**: Check browser permissions
- **Bundle too large**: Review ignore patterns
- **Performance issues**: Optimize file watching

## 📝 Code Style

### TypeScript

- Strict mode enabled
- Explicit return types for public functions
- Proper error handling with try/catch

### React Patterns

- Functional components with hooks
- Context for state management
- Custom hooks for reusable logic
- Proper dependency arrays in useEffect

### File Naming

- PascalCase for components: `DirectoryTree.tsx`
- kebab-case for utilities: `file-utils.ts`
- camelCase for functions and variables

## 🚀 Building &amp; Publishing

### Build Process

```bash
# Full build with type checking
npm run build

# Quick build (skips TypeScript for faster iteration)
vite build
```

### Publishing to NPM

```bash
# Bump version
npm version patch|minor|major

# Build and publish
npm run build
npm publish

# Push changes and tags
git push &amp;&amp; git push --tags
```

### NPX Package Structure

```
dist/           # Built React app
bin/cntx.mjs   # NPX entry point (Express server)
package.json   # Package metadata
README.md      # User documentation
```

## 🤝 Contributing

### Pull Request Process

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Make your changes
4. Add tests if applicable
5. Update documentation
6. Submit a pull request

### Commit Message Format

```
feat: add new bundle analysis feature
fix: resolve file watching memory leak
docs: update API documentation
refactor: simplify bundle creation logic
```

### Areas for Contribution

- **Browser compatibility**: Firefox/Safari support when APIs available
- **Performance**: Large directory handling optimization
- **Features**: New bundle formats, advanced filtering
- **UI/UX**: Accessibility improvements, mobile support
- **Documentation**: Tutorials, examples, API docs

## 🐛 Known Issues

- File System Access API only works in Chromium browsers
- Large directories (&gt;1000 files) may have performance issues
- Bundle sizes can grow large with many files
- No offline functionality (requires file system access)

## 📚 Resources

- [File System Access API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API)
- [React Context Best Practices](https://react.dev/reference/react/useContext)
- [Vite Build Configuration](https://vitejs.dev/config/)
- [shadcn/ui Components](https://ui.shadcn.com/)

---

Happy trails!
</content>
    </document>
    
  </documents>

</bundle>